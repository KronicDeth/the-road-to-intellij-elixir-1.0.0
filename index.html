<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>ElixirConf 2015 - The Road to IntelliJ Elixir 1.0.0</title>

		<meta name="description" content="How I went from &quot;I wonder if there's an Rubymine plugin for Elixir?&quot; to writing one myself and eventually using it to find bugs in native Elixir.">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="stack">
					<section>
						<h1>ElixirConf 2015</h1>
						<h2>The Road to IntelliJ Elixir 1.0.0</h2>
						<p>2015-10-02 to 2015-10-03</p>
						<p>Luke Imhoff</p>
						<table>
							<tbody>
							<tr>
								<th>
									<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                                     version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px"
                                     viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                     <g>
                                        <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                        <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                        <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                        <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                     </g>
                                </svg>
								</th>
								<td>Kronic.Deth@gmail.com</td>
							</tr>
							<tr>
								<th>
									<svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg"
                                     xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16"
                                     enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                               </svg>
								</th>
								<td>
									<a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
								</td>
							</tr>
							<tr>
								<th>
									<svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
								</th>
								<td>
									<a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Hello, my name is Luke Imhoff. I am the maintainer of intellij-elixir, the Elixir plugin
								for Jetbrains IDEs, including IntelliJ itself and Rubymine.  I have contributed to the
								Elixir standard library and found bugs in the native tokenizer and parser through my
								work on intellij-elixir.  I help run the Austin Elixir meetup.
							</p>
						</aside>
					</section>
					<section>
						<h1>This Presentation</h1>
						<dl>
							<dt>Slides</dt>
							<dd>
								<dl>
									<dt>Viewable</dt>
									<dd>
										<a href="https://kronicdeth.github.io/the-road-to-intellij-elixir-1.0.0">
											https://kronicdeth.github.io/the-road-to-intellij-elixir-1.0.0
										</a>
									</dd>
									<dt>Source</dt>
									<dd>
										<a href="https://github.com/KronicDeth/the-road-to-intellij-elixir-1.0.0/tree/gh-pages">
											https://github.com/KronicDeth/the-road-to-intellij-elixir-1.0.0/tree/gh-pages
										</a>
									</dd>
								</dl>
							</dd>
							<dt>Project Source</dt>
							<dd>
								<a href="https://github.com/KronicDeth/intellij-elixir/tree/v1.0.0">
									https://github.com/KronicDeth/intellij-elixir/tree/v1.0.0
								</a>
							</dd>
						</dl>
						<aside class="notes">
							<p>
								For viewers that want to follow along with their own copy of the slides or project
								source, they can be accessed at the shown addresses.
							</p>
						</aside>
					</section>
					<section>
						<h1>Outline</h1>
						<ul>
							<li>
								<a href="#/introduction">Introduction</a>
							</li>
							<li>
								<a href="#/bnf">BNF</a>
							</li>
							<li>
								<a href="#/syntax">Syntax</a>
							</li>
                            <li>
                                <a href="#/interpolation">Interpolation</a>
                            </li>
							<li>
								<a href="#/matched-expressions">Matched Expressions</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls">No Parentheses Function Calls</a>
							</li>
							<li>
								<a href="#/jinterface">JInterface</a>
							</li>
							<li>
								<a href="#/significant-whitespace">Significant Whitespace</a>
							</li>
							<li>
								<a href="#/stab">Stab</a>
							</li>
							<li>
								<a href="#/unmatched-expressions">Unmatched Expressions</a>
							</li>
							<li>
								<a href="#/parsing-elixir-lang-elixir">
									Parsing
									<code>elixir-lang/elixir</code>
								</a>
							</li>
						</ul>
					</section>
				</section>
				<section class="stack">
					<section id="introduction">
						<h1>Introduction</h1>
						<ul>
							<li>
								<a href="#/introduction-why-an-intellij-plugin">
									Why an IntelliJ Plugin?
								</a>
							</li>
							<li>
								<a href="#/introduction-timeline">
									Timeline
								</a>
							</li>
						</ul>
					</section>
					<section id="introduction-why-an-intellij-plugin">
						<h1>Why an IntelliJ Plugin?</h1>
						<ul>
							<li>I use Rubymine for Ruby development</li>
							<li>Wanted vim key bindings</li>
							<li>Wanted Cmd+Click Go To Definition for Elixir</li>
							<li>Wanted Search Everywhere for Elixir</li>
							<li>There was a tutorial</li>
						</ul>
						<aside class="notes">
							<p>
								People may wonder why I took it upon myself to make an IDE plugin for Elixir, when I
								could have used a vim or emacs plugin.
							</p>
							<p>
								I've used both emacs and vim.  I started with emacs when I worked at Cray, only
								switching to vim when I needed something that worked over a high-latency, low-bandwidth
								CDMA modem on the high-way.
							</p>
							<p>
								I started using Rubymine when my boss at a previous job, Nicholas Cancelliere,
								introduced me to it.  I was shocked that an IDE for a dynamic language like Ruby could
								support Find Usage, Go To Definition, and Refactor.  I had been use to using ctags for
								vim.
							</p>
							<p>
								I haven't complete abandoned using vim either.  I still use syntax highlighting plugins
								for vim in iTerm when I need to edit configuration files and I use the IDEAVim plugin
								for Jetbrains IDEs like Rubymine, Webstorm, and IntelliJ.
							</p>
							<p>
								Without Rubymine I don't think I'd have been able to as quickly dive through the complex
								code-base in Metasploit and the graphical debugger allowed me to teach myself the
								internals of Rails and other DSLs.
							</p>
							<p>
								I understood that many of the features I liked about Rubymine were shared across
								JetBrains' various IDEs, so if I could write the parts of a plugin to get JetBrains APIs
								to understand Elixir syntax and semantics, the features I really wanted would just work
								without me having to understand how to write the parts that were cross-language.
							</p>
							<p>
								However, just getting syntax lexing and parsing right ended up taking a year...
							</p>
						</aside>
					</section>
					<section id="introduction-timeline">
						<h1>Timeline</h1>
						<table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th colspan="2">Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
								<th>Name</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2014-07-27</td>
								<td>0</td>
								<td>0</td>
								<td>1</td>
								<td>1</td>
								<td>1.00</td>
								<td>Initial</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;02</td>
								<td>6</td>
								<td>6</td>
								<td>18</td>
								<td>19</td>
								<td>3.00</td>
								<td>0.0.1</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;03</td>
								<td>1</td>
								<td>7</td>
								<td>14</td>
								<td>33</td>
								<td>14.00</td>
								<td>0.0.2</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;08</td>
								<td>5</td>
								<td>12</td>
								<td>10</td>
								<td>43</td>
								<td>2.00</td>
								<td>0.0.3</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;13</td>
								<td>36</td>
								<td>48</td>
								<td>64</td>
								<td>107</td>
								<td>1.78</td>
								<td>0.1.0</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;20</td>
								<td>7</td>
								<td>55</td>
								<td>4</td>
								<td>111</td>
								<td>0.57</td>
								<td>0.1.1</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;25</td>
								<td>5</td>
								<td>60</td>
								<td>12</td>
								<td>123</td>
								<td>2.50</td>
								<td>0.1.2</td>
							</tr>
							<tr>
								<td>2014&#8209;10&#8209;14</td>
								<td>19</td>
								<td>79</td>
								<td>23</td>
								<td>146</td>
								<td>1.21</td>
								<td>0.1.3</td>
							</tr>
							<tr>
								<td>2014&#8209;11&#8209;30</td>
								<td>47</td>
								<td>126</td>
								<td>226</td>
								<td>373</td>
								<td>4.81</td>
								<td>0.2.0</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;03</td>
								<td>124</td>
								<td>250</td>
								<td>521</td>
								<td>894</td>
								<td>4.20</td>
								<td>0.2.1</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;10</td>
								<td>7</td>
								<td>257</td>
								<td>27</td>
								<td>921</td>
								<td>3.86</td>
								<td>0.3.0</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;27</td>
								<td>17</td>
								<td>274</td>
								<td>66</td>
								<td>987</td>
								<td>3.88</td>
								<td>0.3.1</td>
							</tr>
							<tr>
								<td>2015&#8209;05&#8209;01</td>
								<td>4</td>
								<td>278</td>
								<td>8</td>
								<td>995</td>
								<td>2.00</td>
								<td>0.3.2</td>
							</tr>
							<tr>
								<td>2015&#8209;05&#8209;15</td>
								<td>14</td>
								<td>292</td>
								<td>34</td>
								<td>1029</td>
								<td>2.43</td>
								<td>0.3.3</td>
							</tr>
							<tr>
								<td>2015&#8209;06&#8209;04</td>
								<td>20</td>
								<td>312</td>
								<td>86</td>
								<td>1115</td>
								<td>4.30</td>
								<td>0.3.4</td>
							</tr>
							<tr>
								<td>2015&#8209;07&#8209;08</td>
								<td>34</td>
								<td>346</td>
								<td>83</td>
								<td>1198</td>
								<td>2.44</td>
								<td>0.3.5</td>
							</tr>
							<tr>
								<td>2015&#8209;07&#8209;27</td>
								<td>19</td>
								<td>365</td>
								<td>158</td>
								<td>1356</td>
								<td>2.44</td>
								<td>1.0.0</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								I was exactly 1 year between the initial commit of the project skeleton to the v1.0.0 tag.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="bnf">
						<h1>BNF</h1>
						<ul>
							<li>
								<a href="#/bnf-backus-naur-form">Backus Naur Form</a>
							</li>
							<li>
								<a href="#/bnf-yecc">YECC</a>
							</li>
							<li>
								<a href="#/bnf-grammar-kit">Grammar Kit</a>
							</li>
							<li>
								<a href="#/bnf-v0.0.1">v0.0.1</a>
							</li>
						</ul>
					</section>
					<section id="bnf-backus-naur-form">
						<h1>Backus-Naur Form</h1>
						<table>
							<thead>
							<tr>
								<th>Read as</th>
								<th>Symbol</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Metasyntactic Variable</td>
								<td>
									<pre><code class="bnf">&lt;variable&gt;</code></pre>
								</td>
							</tr>
							<tr>
								<td>is defined as</td>
								<td>
									<pre><code class="bnf">::=</code></pre>
								</td>
							</tr>
							<tr>
								<td>or</td>
								<td>
									<pre><code class="bnf">|</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<pre><code data-trim>
&lt;expr&gt; ::= &lt;integer&gt; | &lt;expr&gt; &lt;op&gt; &lt;integer&gt;
						</code></pre>
						<aside class="notes">
							<p>
								One of the standard ways of defining a syntax is in BNF, or Backus-Naur Form, which
								was first used for the Algol 60 standard.
							</p>
							<p>
								Both YECC and GrammarKit use a form of BNF, so I assumed it was just a matter of
								porting elixir dot Y-R-L to elixir dot B-N-F.
							</p>
						</aside>
					</section>
					<section id="bnf-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/12f89a30b46279398fc7143e433681c2194b03d9/lib/elixir/src/elixir_parser.yrl#L77-L82">
									lib/elixir/src/elixir_parser.yrl
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 300%; line-height: 100%">
grammar -> eoe : nil.
grammar -> expr_list : to_block('$1').
grammar -> eoe expr_list : to_block('$2').
grammar -> expr_list eoe : to_block('$1').
grammar -> eoe expr_list eoe : to_block('$2').
grammar -> '$empty' : nil.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								YECC is a parser generator written in Erlang (and part of the standard distribution)
								that is based on yacc (with an 'a' instead of an 'e'), which is a parser generator
								written in C.
							</p>
							<p>
								The YECC syntax differs from B-N-F in that it uses a skinny arrow (<code>-></code>)
								instead of colon colon equals (<code>::=</code>) and instead of using pipe
								(<code>|</code>) for OR, lines with the same rule name are repeated with alternative
								definitions. Finally, YECC supports running Erlang code on the tokens using dollar
								number (<code>$n</code>) for positional references to the matches tokens.
							</p>
							<p>
								dollar empty (<code>$empty</code>) is a special token that matches no input.  In
								formal grammars this is usually referred to as (lowercase) epsilon (<code>É›</code>).
							</p>
						</aside>
					</section>
					<section id="bnf-grammar-kit">
						<h1>Grammar Kit</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf">
									src/org/elixir_lang/Elixir.bnf
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 165%; line-height: 100%">
private elixirFile ::= endOfExpression? (expressionList endOfExpression?)?
private expressionList ::= expression (endOfExpression expression | adjacentExpression)*
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Grammar Kit is a parser generator written in Java and created by JetBrains.
							</p>
							<p>
								GrammarKit's B-N-F format <strong>does</strong> use colon colon equals (<code>::=</code>)
								like Backus-Naur Form, but it has some more power constructs above pipe (<code>|</code>)
								for OR.
							</p>
							<p>
								Question mark (<code>?</code>) can be used for 0 or 1, parentheses (<code>()</code>)
								can be used for grouping; and star can be used for 0 or more.  Empty can be implied
								by question mark (<code>?</code>) or star (<code>*</code>) matching nothing or there
								being nothing on the right-hand-side of the colon colon equals (<code>::=</code>).
							</p>
							<p>
								You'll also notice that there is no inline Java code after the rule definition unlike
								in YECC where there as Erlang code.  This is because GrammarKit automatically generates
								an AST, which it calls a PSI (or Program Structure Interface) Tree from the matched
								rules, so there's no need to define how to build the tree.
							</p>
							<p>
								Having GrammarKit generate the AST is both good and bad.  It's good because it removes
								a lot of redundant code, but it's bad because rules must evaluate in the correct order
								to reflect the desired nesting and associativity without any manual fixups, which are
								possible with the Erlang code in YECC.
							</p>
						</aside>
					</section>
					<section id="bnf-v0.0.1">
						<h1>v0.0.1</h1>
                        <table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th colspan="2">Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
							</thead>
							<tbody>
                            <tr>
								<td>2014&#8209;08&#8209;02</td>
								<td>6</td>
								<td>6</td>
								<td>18</td>
								<td>19</td>
								<td>3.00</td>
							</tr>
                            </tbody>
                        </table>
						<ol>
							<li>Translate from YECC to Grammar Kit</li>
							<li>Freeze IDE</li>
						</ol>
						<aside class="notes">
							<p>
								YECC and Grammar Kit both support a form of BNF and Grammar Kit seems like it would
								support even a more compact grammar because question mark (<code>?</code>), star
								(<code>star</code>), pipe (<code>|</code>) and parentheses (<code>()</code>) could
								eliminate some of the redundancy needed in the multi-clause rules in YECC.
							</p>
							<p>
								After only 6 days I had quote unquote translated the BNF from yecc to Grammar Kit and
								ended up with a parser that froze the IDE, which Julius "h4cc" Beckmann reported. That
								left the slow process of translating the grammar correctly over the next 359 days.  At
								the time of the freeze, I didn't even really understand translating the BNF didn't work,
								all I knew was I needed to go slower and build the grammar up from simpler, testable
								pieces.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="syntax">
						<h1>Syntax</h1>
						<ul>
							<li>
								<a href="#/syntax-analysis">Syntactic Analysis</a>
							</li>
							<li>
								<a href="#/syntax-lexing">Lexing/Tokenizing</a>
							</li>
                            <li>
                                <a href="#/syntax-ignored">Ignoring Characters</a>
                            </li>
						</ul>
					</section>
					<section id="syntax-analysis">
						<h1>Syntactic Analysis</h1>
						<table>
							<thead>
							<tr>
								<th>Step</th>
								<th>Elixir</th>
								<th>IntelliJ Elixir</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Lexing</th>
								<td>
									Erlang
								</td>
								<td>
									JFlex
								</td>
							</tr>
							<tr>
								<th>Parsing</th>
								<td>
									YECC
								</td>
								<td>
									GrammarKit
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								So, I went back and actually started to do the JetBrains tutorial step by step instead
								of jumping ahead and searched Wikipedia, trying to find CompSci articles that explained
								the correct way to do this.
							</p>
							<p>
								In order to support color syntax highlighting and mark syntax errors with the nice
								red squiggly under line, IntelliJ Elixir needed to be able to analyze Elixir syntax.
							</p>
							<p>
								Syntactic analysis is usually broken down into two parts: the first breaks the raw text
								into tokens and the second checks if those tokens are arranged in the correct order.
							</p>
							<p>
								In most programming languages, both lexers and parsers are built using generators that
								have an external DSL.  In Elixir, the lexer is built using Erlang directly because
								Erlang pattern matching is compact enough that a generator is unnecessary.
								Additionally, Elixir syntax contains some features that normal lexer generator aren't
								expecting.
							</p>
							<p>
								For IntelliJ Elixir, I used JFlex because it was the lexer generator recommended by
								JetBrain's plugin tutorial.
							</p>
							<p>
								For parsing Elixir does use a generator, called yecc, which generates Erlang code.
							</p>
							<p>
								For IntelliJ Elixir, I used JetBrains' GrammarKit.
							</p>
							<p>
								When I first started IntelliJ Elixir I didn't understand the important difference
								between these two stacks, but I hope to explain what I learned along the way to you.
							</p>
						</aside>
					</section>
					<section id="syntax-lexing">
						<h1>Lexing/Tokenizing</h1>
						<ol>
							<li>Match Input</li>
							<li>Emit Token</li>
						</ol>
						<aside class="notes">
							<p>
								The first step of syntactic analysis is lexing, also known as tokenizing.  Lexing
								breaks up the raw text into tokens, such as keywords, literals, operators, and
								identifiers.
							</p>
							<p>
								Input is matched using some pattern.  In native Elixir, this is pattern matching on
								Erlang string prefixes.  In IntelliJ Elixir's JFlex file, it's regular expressions.
							</p>
						</aside>
					</section>
					<section id="syntax-ignored">
						<h1>Ignoring Characters</h1>
						<table class="stretch">
							<thead>
							<tr>
								<th>Token</th>
								<th>Erlang</th>
								<th>JFlex</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Comments</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L133-L137">
										<pre><code class="erlang" data-trim style="font-size: 85%; line-height: 100%">
tokenize([$#|String], Line, Scope, Tokens) ->
  Rest = tokenize_comment(String),
  tokenize(Rest, Line, Scope, Tokens);

tokenize_comment("\r\n" ++ _ = Rest) -> Rest;
tokenize_comment("\n" ++ _ = Rest)   -> Rest;
tokenize_comment([_|Rest])           -> tokenize_comment(Rest);
tokenize_comment([])                 -> [].
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L21-L63">
										<pre><code data-trim>
COMMENT = "#" [^\r\n]* {EOL}?

&lt;YYINITIAL&gt; {
  {COMMENT} { yybegin(BODY); return ElixirTypes.COMMENT; }
}
&lt;BODY&gt; {
  {COMMENT} { return ElixirTypes.COMMENT; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							<tr>
								<td>EOL</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L320-L324">
										<pre><code class="erlang" data-trim>
tokenize("\n" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line + 1, Scope, eol(Line, newline, Tokens));

tokenize("\r\n" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line + 1, Scope, eol(Line, newline, Tokens));

eol(_Line, _Mod, [{',',_}|_] = Tokens)   -> Tokens;
eol(_Line, _Mod, [{eol,_,_}|_] = Tokens) -> Tokens;
eol(Line, Mod, Tokens) -> [{eol,Line,Mod}|Tokens].
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L18-L59">
										<pre><code data-trim style="font-size: 95%; line-height: 100%;">
EOL = \n|\r|\r\n

&lt;YYINITIAL&gt; {
  ({EOL}|{WHITE_SPACE})+      { yybegin(BODY);
                                return TokenType.WHITE_SPACE; }
}
&lt;BODY&gt; {
  {EOL}({EOL}|{WHITE_SPACE})* { return ElixirTypes.EOL; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							<tr>
								<td>Whitespace</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L478-L479">
										<pre><code class="erlang" data-trim style="font-size: 90%; line-height: 100%">
tokenize([T|Rest], Line, Scope, Tokens) when ?is_horizontal_space(T) ->
  tokenize(strip_horizontal_space(Rest), Line, Scope, Tokens);

strip_horizontal_space([H|T]) when ?is_horizontal_space(H) ->
  strip_horizontal_space(T);
strip_horizontal_space(T) ->
  T.
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L21-L63">
										<pre><code data-trim>
&lt;BODY&gt; {
  {WHITE_SPACE}+ { return TokenType.WHITE_SPACE; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								In addition to turning runs of characters into single tokens, the lexer can be used
								to filter out runs that don't affect the meaning of code, such as spaces, extra new
								lines and comments.
							</p>
							<p>
								The JFlex code has two states because in v0.0.2, I used the Y-Y-INITIAL state to ignore
								newlines or whitespace at the beginning of the file.
							</p>
							<p>
								I also made the assumption that runs of EOLs could be ignored at the parser level.
							</p>
                            <p>
                                The Erlang lexer in elixir tokenizer dot erl processes the raw text as a char list.
                                Pattern matching on the head of the list and then recursively calling tokenize on the
                                rest of the raw text.  The Erlang lexer only keeps track of the effect of ignored
                                characters on the current line number, which was the only metadata in Elixir v0.14.3.
                            </p>
                            <p>
                                In contrast, the JFlex lexer processes the raw text as unicode characters.  Regular
                                expressions and references to other named regular expressions (as seen in COMMENT using
                                EOL) can be used to match text with the longest match in a given state while in the
                                Erlang Lexer, the order matches the order of the clauses.  The JFlex lexer emits a token
                                for even ignored characters because in an editor, unlike a compiler, one cares about
                                comments, whitespace and extra newlines.
                            </p>
						</aside>
					</section>
				</section>
                <section class="stack">
                    <section id="interpolation">
                        <h1>Interpolation</h1>
                        <ul>
							<li>
								<a href="#/interpolation-interpolation">Interpolation</a>
							</li>
							<li>
								<a href="#/interpolation-computational-hierarchy">Computational Hierarchy</a>
							</li>
                            <li>
                                <a href="#/interpolation-elixir-native">Elixir Native</a>
                            </li>
                            <li>
                                <a href="#/interpolation-jflex">JFlex</a>
                            </li>
                        </ul>
                    </section>
					<section id="interpolation-interpolation">
						<h1>Interpolation</h1>
						<pre><code class="elixir strech" data-trim style="font-size: 195%; line-height: 100%">
iex> greeting = "Hello #{"W#{"or"}ld"}"
"Hello World"
iex> tuple = "A tuple #{inspect {"Containing an #{:interpolated} string"}}"
"A tuple {\"Containing an interpolated string\"}"
						</code></pre>
						<ul>
							<li>
								Starts with <code>#{</code> and ends with <code>}</code>
							</li>
							<li>
								Valid in Char Lists, Strings, and (interpolating) Sigils
							</li>
							<li>
								Recursive
							</li>
						</ul>
						<aside class="notes">
							<p>
								Add support for interpolation was tricky.  At first glance the hash opening curly and
								closing curly that surround interpolation should work just curly braces in a language
								like C or Java, but the braces in C or Java can just be lexed and the parser can decide
								about whether they are matched.  In languages like Ruby or Elixir that support
								interpolation, whether the you're parsing fragments for the string, char list or sigil
								or if you're in normal code needs to be tracked as fragments will be syntax highlighted
								and parsed differently than normal code.  Finally, code inside interpolation can
								itself have strings, char lists, or sigil that also contain interpolation, recursively.
							</p>
							<p>
								This recursion means that a non-deterministic finite automaton as generated by JFlex
								can no longer parser Elixir!
							</p>
						</aside>
					</section>
					<section id="interpolation-computational-hierarchy">
						<h1>Computational Heirarchy</h1>
						<table>
							<thead>
							<tr>
								<th>Language Class</th>
								<th>Computational Model</th>
								<th>Example</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Regular</td>
								<td>Finite Automaton/State Machine</td>
								<td>Multiples of 3 in binary</td>
							</tr>
							<tr>
								<td>Context-Free</td>
								<td>Pushdown Automaton</td>
								<td>Balanced Parentheses</td>
							</tr>
							<tr>
								<td>Decidable</td>
								<td>(Always-halting) Turing machine</td>
								<td><code>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup></code></td>
							</tr>
							<tr>
								<td>Semidecidable</td>
								<td>Turing machine</td>
								<td>Halting Problem</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Finite Automatons can lex regular languages, which are languages that match formal
								regular expressions.  Formal regular expression only allow pipe (<code>|</code>) for or,
								parentheses (<code>()</code>) for grouping, and asterisk (<code>*</code>) for Kleene
								star, which means zero or more.  They also can have question mark (<code>?</code>) to
								mean zero or one, if they can't use a symbol for no input, which would be lowercase
								epsilon formally.
							</p>
							<p>
								Context-free languages are a step above regular expressions and can be lexed by pushdown
								automatons, which have a stack for keeping track of state.  A pushdown automaton can use
								the current state along with the current input to decide whether parentheses are matched
								by pushing opening parentheses onto a stack and popping on closing parentheses.  If
								you try to pop when the stack is empty, then you have an unmatched closing parenthesis
								and if the string ends with a non-empty stack then you have an unmatched opening
								parenthesis.
							</p>
							<p>
								You may be thinking, "Wait! I know I can match parentheses with a regex in Ruby or Perl!"
								Well, you can, but this is because the back references to previous groups supported
								in Ruby with slash g (<code>\g</code>) and question mark R in Perl and Perl-Compatible
								Regular Expressions (<code>?R</code>).  This feature is not actually part of formal
								regular expressions and actually promotes extend regular expressions to pushdown
								automaton.
							</p>
							<p>
								When writing compilers and IDEs, designers have to care about the computational hierarchy
								because performance guarantees get fuzzy and get more complex until you hit
								semidecidable and Turing machines, which may just spin forever on bad input.
							</p>
						</aside>
					</section>
					<section id="interpolation-elixir-native">
						<h1>Elixir Native Interpolation</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L234-L529">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 140%; line-height: 100%">
tokenize([$"|T], Line, Scope, Tokens) ->
  handle_strings(T, Line, $", Scope, Tokens);
tokenize([$'|T], Line, Scope, Tokens) ->
  handle_strings(T, Line, $', Scope, Tokens);

handle_strings(T, Line, H, Scope, Tokens) ->
  case elixir_interpolation:extract(Line, Scope, true, T, H) of
    {error, Reason} ->
      interpolation_error(Reason, [H|T], Tokens, " (for string starting at line ~B)", [Line]);
    {NewLine, Parts, [$:|Rest]} when ?is_space(hd(Rest)) ->
      Unescaped = unescape_tokens(Parts),
      Key = case Scope#elixir_tokenizer.existing_atoms_only of
        true  -> kw_identifier_safe;
        false -> kw_identifier_unsafe
      end,
      tokenize(Rest, NewLine, Scope, [{Key, Line, Unescaped}|Tokens]);
    {NewLine, Parts, Rest} ->
      Token = {string_type(H), Line, unescape_tokens(Parts)},
      tokenize(Rest, NewLine, Scope, [Token|Tokens])
  end.
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_interpolation.erl#L39-L50">
									<code>lib/elixir/src/elixir_interpolation.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 140%; line-height: 100%">
extract(Line, Scope, true, [$#, ${|Rest], Buffer, Output, Last) ->
  Output1 = build_string(Line, Buffer, Output),

  case elixir_tokenizer:tokenize(Rest, Line, Scope) of
    {error, {EndLine, _, "}"}, [$}|NewRest], Tokens} ->
      Output2 = build_interpol(Line, Tokens, Output1),
      extract(EndLine, Scope, true, NewRest, [], Output2, Last);
    {error, Reason, _, _} ->
      {error, Reason};
    {ok, _EndLine, _} ->
      {error, {string, Line, "missing interpolation terminator:}", []}}
  end;
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In native Elixir, elixir tokenizer's tokenize
								(<code>elixir_tokenizer:tokenize/4</code>) calls handle strings
								(<code>handle_strings/5</code>, which calls elixir interpolation's
								extract, which calls elixir tokenizer's colon tokenize
								(<code>elixir_tokenizer:tokenize</code>), meaning the native
								lexer uses normal Erlang recursion.
							</p>
						</aside>
					</section>
					<section id="interpolation-jflex">
						<h1>JFlex Interpolation</h1>
						<figure>
							<figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.3/src/org/elixir_lang/Elixir.flex">
                                    <code>src/org/elixir_lang/Elixr.flex</code>
                                </a>
							</figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 165%; line-height: 100%;">
%{
  private java.util.Stack&lt;Integer&gt; lexicalStateStack = new java.util.Stack&lt;Integer&gt;();
%}

&lt;YYINITIAL&gt; {
  {DOUBLE_QUOTES}  { lexicalStateStack.push(BODY);
                     yybegin(DOUBLE_QUOTED_STRING);
                     return ElixirTypes.DOUBLE_QUOTES; }
}

&lt;DOUBLE_QUOTED_STRING&gt; {
  {INTERPOLATION_START} { lexicalStateStack.push(yystate());
                          yybegin(INTERPOLATION);
                          return ElixirTypes.INTERPOLATION_START; }
  {DOUBLE_QUOTES}       { int previousLexicalState = lexicalStateStack.pop();
                          yybegin(previousLexicalState);
                          return ElixirTypes.DOUBLE_QUOTES; }
}

&lt;BODY, INTERPOLATION&gt; {
  {DOUBLE_QUOTES} { lexicalStateStack.push(yystate());
                    yybegin(DOUBLE_QUOTED_STRING);
                    return ElixirTypes.DOUBLE_QUOTES; }
}

&lt;INTERPOLATION&gt; {
  {INTERPOLATION_END} { int previousLexicalState = lexicalStateStack.pop();
                        yybegin(previousLexicalState);
                        return ElixirTypes.INTERPOLATION_END; }
}
                            </code></pre>
						</figure>
						<aside class="notes">
							<p>
								JFlex's flex DSL only supports creating finite automaton, so how did I enhance the
								generated parser so it was a pushdown automaton?  I added a manually managed stack
								in the Java code that I can run on each rule match.
							</p>
                            <p>
                                If the lexer hits a non-escaped double quote, it enters the
                                <code>DOUBLE_QUOTED_STRING</code> state, which treats the hash curly brace
                                (<code>#{</code>) of the interpolation start token special: it pushes the current state
                                on top the stack and begins the <code>INTERPOLATION</code> state.
                            </p>
                            <p>
                                The <code>INTERPOLATION</code> and <code>BODY</code> states are the same except
                                that <CODE>INTERPOLATION</CODE> needs to pop and restore the previous lexical state
                                if the closing curly brace (<code>}</code>) for <code>INTERPOLATION</code> is hit.
                            </p>
						</aside>
					</section>
                </section>
				<section class="stack">
                    <section id="matched-expressions">
                        <h1>Matched Expressions</h1>
                        <ul>
                            <li>
                                <a href="#/matched-expressions-call-syntaxes">Call Syntaxes</a>
                            </li>
                            <li>
                                <a href="#/matched-expressions-yecc-associativity-and-precedence">YECC Associativity and Precedence</a>
                            </li>
                            <li>
                                <a href="#/matched-expressions-grammar-kit-precedence">Grammar Kit Precedence</a>
                            </li>
                            <li>
								<a href="#/matched-expressions-grammar-kit-associativity">Grammar Kit Associativity</a>
                            </li>
							<li>
								<a href="#/matched-expressions-grammars">Grammars</a>
							</li>
							<li>
								<a href="#/matched-expressions-associativity">Associativity</a>
							</li>
							<li>
								<p>Pratt Parsing</p>
								<ul>
									<li>
										<a href="#/matched-expressions-pratt-parsing-head">Head</a>
									</li>
									<li>
										<a href="#/matched-expressions-pratt-parsing-tail">Tail</a>
									</li>
								</ul>
							</li>
                        </ul>
                    </section>
                    <section id="matched-expressions-call-syntaxes">
                        <h1>Call Syntaxes</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>
                                    <code>elixir_parser.yrl</code>
                                </th>
                                <th>
                                    <code>Elixir.bnf</code>
                                </th>
                                <th>Description</th>
								<th>Example</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L113-L122">
                                        <code>matched_expr</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/0f8e974c4ec965c2f06653c8bddce7ddd3e80335/src/org/elixir_lang/Elixir.bnf#L191-L211">
                                        <code>matchedExpression</code>
                                    </a>
                                </td>
                                <td>
                                    With Parentheses*
                                </td>
								<td>
									<ul>
										<li>
											<code>function()</code>
										</li>
										<li>
											<code>function</code>
										</li>
										<li>
											<code>function&nbspone</code>
										</li>
									</ul>
								</td>
                            </tr>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L124-L125">
                                        <code>no_parens_expr</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf#L248-L259">
                                        <code>unqualifiedNoParenthesesManyArgumentsCall</code>
                                    </a>
                                </td>
                                <td>
                                    Without Parentheses
                                </td>
								<td>
									<ul>
										<li>
											<code>function&nbsp;one, two</code>
										</li>
										<li>
											<code>function&nbsp;one, key: value</code>
										</li>
									</ul>
								</td>
                            </tr>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L127-L133">
                                        <code>unmatched_expr</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf#L2335-L2370">
                                        <code>unmatchedExpression</code>
                                    </a>
                                </td>
                                <td>
                                    With Do Block
                                </td>
								<td>
									<ul>
										<li>
											<code>function() do end</code>
										</li>
										<li>
											<code>function one, two do end</code>
										</li>
									</ul>
								</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Elixir parser dot yurl (<code>elixir_parser.yrl</code>) explains that there are 3 call
                                syntaxes in Elixir: matched, no parentheses, and unmatched.
                            </p>
                            <p>
                                Matched also implies parentheses, except for one argument no parentheses calls because
                                they can be chained together, which looks a lot like Haskell.
                            </p>
                        </aside>
                    </section>
                    <section id="matched-expressions-yecc-associativity-and-precedence">
                        <h1>YECC associativity and precedence</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L44-L71">
                                    <code>lib/elixir/src/elixir_parser.yrl</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 175%; line-height: 100%">
%% Changes in ops and precedence should be reflected on lib/elixir/lib/macro.ex
%% Note though the operator => in practice has lower precedence than all others,
%% its entry in the table is only to support the %{user | foo => bar} syntax.
Left       5 do.
Right     10 stab_op_eol.     %% ->
Left      20 ','.
Nonassoc  30 capture_op_eol.  %% &
Left      40 in_match_op_eol. %% <-, \\ (allowed in matches along =)
Right     50 when_op_eol.     %% when
Right     60 type_op_eol.     %% ::
Right     70 pipe_op_eol.     %% |
Right     80 assoc_op_eol.    %% =>
Right     90 match_op_eol.    %% =
Left     130 or_op_eol.       %% ||, |||, or, xor
Left     140 and_op_eol.      %% &&, &&&, and
Left     150 comp_op_eol.     %% ==, !=, =~, ===, !==
Left     160 rel_op_eol.      %% <, >, <=, >=
Left     170 arrow_op_eol.    %% < (op), (op) > (e.g |>, <<<, >>>)
Left     180 in_op_eol.       %% in
Right    200 two_op_eol.      %% ++, --, .., <>
Left     210 add_op_eol.      %% + (op), - (op)
Left     220 mult_op_eol.     %% * (op), / (op)
Left     250 hat_op_eol.      %% ^ (op) (e.g ^^^)
Nonassoc 300 unary_op_eol.    %% +, -, !, ^, not, ~~~
Left     310 dot_call_op.
Left     310 dot_op.          %% .
Nonassoc 320 at_op_eol.       %% @
Nonassoc 330 dot_identifier.
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The YECC format has a section for declaring both the associativity and precedence of
                                operators.  The operator table doesn't completely reflect the precedence of all operator
                                combinations because there are some precedence swaps, such as for `not in`.
                            </p>
							<p>
								<code>Nonassoc</code> is used for non-binary, prefix operators that don't have
								associativity rules.
							</p>
							<p>
								Higher precedence operators (with greater numbers) in the table can act as arguments
								to the lower precedence operators, so and operators like double ampersand
								(<code>&&</code>) take comparison operation using comparison operators like double
								equals (<code>==</code>) at arguments.
							</p>
                        </aside>
                    </section>
                    <section id="matched-expressions-grammar-kit-precedence">
						<h1>Grammar Kit Precedence</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/src/org/elixir_lang/Elixir.bnf#L191-L211">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 230%; line-height: 100%">
matchedExpression ::= matchedExpressionCaptureOperation |
                      matchedExpressionInMatchOperation |
                      matchedExpressionWhenOperation |
                      matchedExpressionTypeOperation |
                      matchedExpressionPipeOperation |
                      matchedExpressionMatchOperation |
                      matchedExpressionOrOperation |
                      matchedExpressionAndOperation |
                      matchedExpressionComparisonOperation |
                      matchedExpressionRelationalOperation |
                      matchedExpressionArrowOperation |
                      matchedExpressionInOperation |
                      matchedExpressionTwoOperation |
                      matchedExpressionAdditionOperation |
                      matchedExpressionMultiplicationOperation |
                      matchedExpressionHatOperation |
                      matchedExpressionUnaryOperation |
                      matchedExpressionDotOperation |
                      matchedExpressionAtOperation |
                      identifierExpression |
                      accessExpression
							</code></pre>
						</figure>
                        <aside class="notes">
                            <p>
                                There isn't a unified associativity and precedence table for Grammar Kit's BNF.
                                Instead, the precedence is order of choice in parent expression, which is also the
								argument expression.
                            </p>
							<p>
								Instead of stating the precedence of the operators as is done in YECC, the precedence
								of operations using those operator is done in Grammar Kit.
							</p>
                        </aside>
                    </section>
					<section id="matched-expressions-grammar-kit-associativity">
						<h1>Grammar Kit Associativity</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/src/org/elixir_lang/Elixir.bnf#L214-L232">
									<code>src/org/elixir/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 115%; line-height: 100%">
matchedExpressionAdditionOperation ::= matchedExpression DUAL_OPERATOR EOL* matchedExpression
matchedExpressionAndOperation ::= matchedExpression EOL* AND_OPERATOR EOL* matchedExpression
matchedExpressionArrowOperation ::= matchedExpression EOL* ARROW_OPERATOR EOL* matchedExpression
matchedExpressionAtOperation ::= AT_OPERATOR EOL* matchedExpression
matchedExpressionCaptureOperation ::= CAPTURE_OPERATOR EOL* matchedExpression
matchedExpressionComparisonOperation ::= matchedExpression EOL* COMPARISON_OPERATOR EOL* matchedExpression
matchedExpressionDotOperation ::= matchedExpression EOL* DOT_OPERATOR EOL* matchedExpression
matchedExpressionHatOperation ::= matchedExpression EOL* HAT_OPERATOR EOL* matchedExpression
matchedExpressionInMatchOperation ::= matchedExpression EOL* IN_MATCH_OPERATOR EOL* matchedExpression
matchedExpressionInOperation ::= matchedExpression EOL* IN_OPERATOR EOL* matchedExpression
matchedExpressionMatchOperation ::= matchedExpression EOL* MATCH_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionMultiplicationOperation ::= matchedExpression EOL* MULTIPLICATION_OPERATOR EOL* matchedExpression
matchedExpressionOrOperation ::= matchedExpression EOL* OR_OPERATOR EOL* matchedExpression
matchedExpressionPipeOperation ::= matchedExpression EOL* PIPE_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionRelationalOperation ::= matchedExpression EOL* RELATIONAL_OPERATOR EOL* matchedExpression
matchedExpressionTwoOperation ::= matchedExpression EOL* TWO_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionTypeOperation ::= matchedExpression EOL* TYPE_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionUnaryOperation ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* matchedExpression
matchedExpressionWhenOperation ::= matchedExpression EOL* WHEN_OPERATOR EOL* matchedExpression { rightAssociative = true }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, the pattern for binary operations are matched expression
								(<code>matchedExpression</code>) on either side of the actual operator token with
								optional newlines around the operator.
							</p>
							<p>
								Left associativity is assumed by default, so right associativity is indicated with
								right associative equals true (<code>rightAssociative = true</code>) in the braces after
								the rule.
							</p>
							<p>
								You may have noticed that these rules appear to be recursive: on the previous slide,
								matched expression (<code>matchedExpression</code>) was defined as the ordered choice
								of all the operations on this on this slide, but all the operations use matched
								expression (<code>matchedExpression</code>) as both the left and right argument, so
								why doesn't parser go into an infinite loop on the first binary rule, matched
								expression in match operation (<code>matchedExpressionInMatchOperation</code>)?
							</p>
							<p>
								There is no loop because Grammar Kit has some extensions that allow it to detect this
								pattern of rules.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-grammars">
						<h1>Grammars</h1>
						<table>
							<thead>
							<tr>
								<th></th>
								<th>Look-ahead, Left-to-Right, Rightmost deriviation (LALR)</th>
								<th>Parsing Expression Grammar</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Inventor</th>
								<td>Frank DeRemer</td>
								<td>Bryan Ford</td>
							</tr>
							<tr>
								<th>Invented</th>
								<td>1969</td>
								<td>2004</td>
							</tr>
							<tr>
								<th>Terminal symbols</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Nonterminal rules</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Empty string</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Sequence</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Choice</th>
								<td>Ambiguous</td>
								<td>Ordered</td>
							</tr>
							<tr>
								<th>Zero-or-more</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>*</code>
								</td>
							</tr>
							<tr>
								<th>One-or-more</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>+</code>
								</td>
							</tr>
							<tr>
								<th>Optional</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>?</code>
								</td>
							</tr>
							<tr>
								<th>Positive Look-ahead</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>&</code>
								</td>
							</tr>
							<tr>
								<th>Negative Look-ahead</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>!</code>
								</td>
							</tr>
							<tr>
								<th>Derivation</th>
								<td>Rightmost</td>
								<td>Leftmost</td>
							</tr>
							<tr>
								<th>Left-Recursion</th>
								<td>Favored</td>
								<td>Infinite Loop</td>
							</tr>
							<tr>
								<th>Right-Recursion</th>
								<td>Unfavored</td>
								<td>Favored</td>
							</tr>
							<tr>
								<th>Direction</th>
								<td>Bottom-up</td>
								<td>Top-down</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								YECC is a LALR, or look-ahead, left-to-right, rightmost derivation parser generator.
								Grammar Kit is a Parsing Expression Grammar parser generator.
							</p>
							<p>
								Rightmost derivation means the parse tree is actually built up from the right-most end
								of the text, so opposite the way the text is read, which is somewhat counter-intuitive
								for human, but turns out to be really powerful.
							</p>
							<p>
								Leftmost derivation means the parse tree is built in the same order as the text is
								read and is easier for humans to understand, but it's not a theoretically powerful.
							</p>
							<p>
								LALR grammars don't have syntax for zero-or-more, one-or-more, or optional, instead they
								have to be constructed with recursive rules or rule clauses involving empty strings,
								so the grammar has to be more verbose.
							</p>
							<p>
								LALR has look-ahead in its name, but the grammar itself has no control of how far to
								look-ahead.  Instead, it's hard-coded to be one token.  In parsing expression grammars
								any rule can be put after ampersand (<code>&</code>) to do a positive look-ahead or
								after exclamation point (<code>!</code>) to do negative look-ahead.
							</p>
							<p>
								This look-ahead being rule-based instead of token-based means it is potentially
								infinite, but that also means that performance in both memory and speed can be worse
								if the look-ahead is chosen poorly.  For LALR, the look-ahead is automatically one
								token and the best rule can be chosen as the match, but the rule order and look-ahead
								is under control of the grammar for Parsing Expression Grammars.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-associativity">
						<h1>Associativity</h1>
						<table>
							<thead>
							<tr>
								<th>Associativity</th>
								<th>Left</th>
								<th>Right</th>
							</tr>
							<tr>
								<th>Code</th>
								<td>
									<code>a or b || c</code>
								</td>
								<td>
									<code>a ++ b <> c</code>
								</td>
							</tr>
							<tr>
								<th>Nesting</th>
								<td>
									<ul>
										<li>
											<code>||</code>
											<ul>
												<li>
													<code>or</code>
													<ul>
														<li>
															<code>a</code>
														</li>
														<li>
															<code>b</code>
														</li>
													</ul>
												</li>
												<li>
													<code>c</code>
												</li>
											</ul>
										</li>
									</ul>
								</td>
								<td>
									<ul>
										<li>
											<code>++</code>
											<ul>
												<li>
													<code>a</code>
												</li>
												<li>
													<code>&lt;&gt;</code>
													<ul>
														<li>
															<code>b</code>
														</li>
														<li>
															<code>c</code>
														</li>
													</ul>
												</li>
											</ul>
										</li>
									</ul>
								</td>
							</tr>
							<tr>
								<th>Effective Parentheses</th>
								<td>
									<code>(a or b) || c</code>
								</td>
								<td>
									<code>a ++ (b <> c)</code>
								</td>
							</tr>
							<tr>
								<th>Execution Pipeline</th>
								<td>
									a |> Kernel.or(b) |> Kernel.||(c)
								</td>
								<td>
									a |> Kernel.++(b |> Kernel.<>(c))
								</td>
							</tr>
							</thead>
						</table>
						<aside class="notes">
							<p>
								Instead of having to visual that in your head, let's see a nested example for
								left- and right-associative operators.
							</p>
							<p>
								I'm using the or operators, the word <code>or</code> and double pipes (<code>||</code>)
								for the left-associative operator because they're easy to distingish.  Similarly,
								I'm using the two operators, double plus (<code>++</code>) and diamond
								(<code>&lt;&gt;</code>), for the right-associative operator.  Remember, the two
								operators in each example are of the same precedence, so it's just the associativity
								controlling the nesting.
							</p>
							<p>
								For left-associative, the left-most operator becomes the root of the tree with
								the right operand executing first, so it looks like the operators are in the wrong
								order, but if you rearrange the nesting to pipeline order it makes sense.
							</p>
							<p>
								For right-associative, reading the tree in order, it looks like it matches, the order
								of the code, but when you change it to pipeline order you can see the the second
								operation must actually complete at the same time as the first argument.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-pratt-parsing-head">
						<h1>Pratt Parsing</h1>
						<h2>Head</h2>
						<figure>
							<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/gen/org/elixir_lang/parser/ElixirParser.java#L1804-L1842">
								<code>gen/org/elixir_lang/parser/ElixirParser.java</code>
							</a>
							<pre><code class="java stretch" data-trim style="font-size: 110%; line-height: 100%">
public class ElixirParser implements PsiParser {
  /* ********************************************************** */
  // Expression root: matchedExpression
  // Operator priority table:
  // 0: PREFIX(matchedExpressionCaptureOperation)
  // 1: BINARY(matchedExpressionInMatchOperation)
  // 2: BINARY(matchedExpressionWhenOperation)
  // 3: BINARY(matchedExpressionTypeOperation)
  // 4: BINARY(matchedExpressionPipeOperation)
  // 5: BINARY(matchedExpressionMatchOperation)
  // 6: BINARY(matchedExpressionOrOperation)
  // 7: BINARY(matchedExpressionAndOperation)
  // 8: BINARY(matchedExpressionComparisonOperation)
  // 9: BINARY(matchedExpressionRelationalOperation)
  // 10: BINARY(matchedExpressionArrowOperation)
  // 11: BINARY(matchedExpressionInOperation)
  // 12: BINARY(matchedExpressionTwoOperation)
  // 13: BINARY(matchedExpressionAdditionOperation)
  // 14: BINARY(matchedExpressionMultiplicationOperation)
  // 15: BINARY(matchedExpressionHatOperation)
  // 16: PREFIX(matchedExpressionUnaryOperation)
  // 17: BINARY(matchedExpressionDotOperation)
  // 18: PREFIX(matchedExpressionAtOperation)
  // 19: ATOM(identifierExpression)
  // 20: ATOM(accessExpression)
  public static boolean matchedExpression(PsiBuilder b, int l, int g) {
    if (!recursion_guard_(b, l, "matchedExpression")) return false;
    addVariant(b, "&lt;matched expression&gt;");
    boolean r, p;
    Marker m = enter_section_(b, l, _NONE_, "&lt;matched expression&gt;");
    r = matchedExpressionCaptureOperation(b, l + 1);
    if (!r) r = matchedExpressionUnaryOperation(b, l + 1);
    if (!r) r = matchedExpressionAtOperation(b, l + 1);
    if (!r) r = identifierExpression(b, l + 1);
    if (!r) r = accessExpression(b, l + 1);
    p = r;
    r = r && matchedExpression_0(b, l + 1, g);
    exit_section_(b, l, m, null, r, p, null);
    return r || p;
  }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The rules for parsing expression grammars say that left recursion is impossible, so how
								am I allowed to have matched expression (<code>matchedExpression</code>) as the
								left-most rule in a rule that's part of matched expression
								(<code>matchedExpression</code>) itself?
							</p>
							<p>
								Pratt parsing is an extension to recursive-descent parsers, which include parsing
								expression grammars, that allows for optimization for parsing operators by noticing
								patterns in how humans write binary operators to eliminate left-recursion.
							</p>
							<p>
								The optimization involves noticing that eventually all operation rules get to
								rules that aren't left-recursive or that are tokens, so the parser generator itself
								can do the left-recursion elimination by looking for those non-left-recursive rules
								first, then try to consume an operator, then do it all over again, but keep track
								of the precedence of the operator.
							</p>
							<p>
								Here, you can see that the prefix operations,
								<code>matchedExpressionUnaryOperation</code> and
								<code>matchedexpressionAtOperation</code>, can be checked for because they consume
								an operator token first and so aren't left-recursive.
							</p>
							<p>
								Likewise, <code>identifierExpression</code> and access expression
								<code>accessExpression</code> are atoms, so they don't include
								<code>matchedExpression</code> at all and so can be used to consume input immediately.
							</p>
							<p>
								Once some input is consumed, <code>matchedExpression</code> goes into matched expression
								underscore 0 (<code>matchedExpression_0</code>).  For user written rules the underscore
								number system is used for anonymous groups in parentheses, but here's it's meant to
								indicate that the parser is checking the tail of all the <code>matchedExpression</code>
								rules.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-pratt-parsing-tail">
						<h1>Pratt Parsing</h1>
						<h2>Tail</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/gen/org/elixir_lang/parser/ElixirParser.java#L1844-L1919">
									<code>gen/org/elixir_lang/parser/ElixirParser.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 120%; line-height: 100%">
public class ElixirParser implements PsiParser {
 public static boolean matchedExpression_0(PsiBuilder b, int l, int g) {
    if (!recursion_guard_(b, l, "matchedExpression_0")) return false;
    boolean r = true;
    while (true) {
      Marker m = enter_section_(b, l, _LEFT_, null);
      if (g &lt; 1 && matchedExpressionInMatchOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 1);
        exit_section_(b, l, m, MATCHED_EXPRESSION_IN_MATCH_OPERATION, r, true, null);
      }
      else if (g &lt; 2 && matchedExpressionWhenOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 1);
        exit_section_(b, l, m, MATCHED_EXPRESSION_WHEN_OPERATION, r, true, null);
      }
      else if (g &lt; 3 && matchedExpressionTypeOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 2);
        exit_section_(b, l, m, MATCHED_EXPRESSION_TYPE_OPERATION, r, true, null);
      }
      else if (g &lt; 4 && matchedExpressionPipeOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 3);
        exit_section_(b, l, m, MATCHED_EXPRESSION_PIPE_OPERATION, r, true, null);
      }
      else if (g &lt; 5 && matchedExpressionMatchOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 4);
        exit_section_(b, l, m, MATCHED_EXPRESSION_MATCH_OPERATION, r, true, null);
      }
      else if (g < 6 && matchedExpressionOrOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 6);
        exit_section_(b, l, m, MATCHED_EXPRESSION_OR_OPERATION, r, true, null);
      }
      // ...
      else {
        exit_section_(b, l, m, null, false, false, null);
        break;
      }
    }
    return r;
  }								
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The pattern used in matched expression (<code>matchedExpression</code>) and matced
								expression zero (<code>matchedExpression_0</code>) is based on Douglas Crockford's
								Top Down Operator Precedence implementation in Javascript.
							</p>
							<p>
								<code>g</code> is the right-binding power of the currently matched operator.  Only
								operators with a stronger binding power (because they are higher precedence) can
								be matched when recursing, but if no stronger rule is matched on the recursive
								call to matched expression (<code>matchedExpression</code>), then the while loop
								allows for matching operators of equal right-binding power.
							</p>
							<p>
								The left-associative, in match at the beginning and or at the end of the excerpt all
								follow the pattern of recursive call to matched expression
								(<code>matchedExpression</code>) with <code>g</code> one greater than the max for the
								current operator (so g less than 1 and 1 is passed; g less than 6 and 6 is passed).
								This ensures that adjacent left operators at the same level are matched by the while
								loop, which are then properly left-nested by the underscore left
								underscore (<code>_LEFT_</code>) directive in the <code>m</code> marker at the top of
								while loop.
							</p>
							<p>
								The underscore left underscore (<code>_LEFT_</code>) directive is similar how the
								pipelines are rearranged in Elixir.
							</p>
							<p>
								For right-associative operators, like when, type, pipe, and match, the if clauses
								recursively calls matched expression (<code>matchedExpression</code> with
								<code>g</code> that can match the current operator, which means adjacent
								right-associative operators or any higher precedence operator is properly nested at a
								lower level.  Since the parser is left-most derivation, any nesting occurs on the
								right-end, so nesting gets the proper right-associative behavior.
							</p>
						</aside>
					</section>

				</section>
				<section class="stack">
					<section id="no-parentheses-function-calls">
						<h1>No Parentheses Function Calls</h1>
						<ul>
							<li>
								<a href="#/no-parentheses-function-calls-yecc">YECC</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-conversion">Conversion</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-unqualified">Unqualified</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-qualified">Qualified</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-arguments">Arguments</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-no-parentheses-strict">No Parentheses Strict</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-many-arguments">Many Arguments</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-expression">No Parentheses Expression</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-matched-expression-vs-keyword-key">MatchedExpression vs KeywordKey</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-matched-expression">In Matched Expression</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-call-matched-call-operation">
									<code>matchedCallOperation</code>
								</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-qualified-matched-call-operation">
									Qualified <code>matchedCallOperation</code>
								</a>
							</li>
						</ul>
					</section>
					<section id="no-parentheses-function-calls-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L88-L421">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
expr -&gt; no_parens_expr : '$1'.

no_parens_expr -&gt; dot_op_identifier call_args_no_parens_many_strict : build_identifier('$1', '$2').
no_parens_expr -&gt; dot_identifier call_args_no_parens_many_strict : build_identifier('$1', '$2').

dot_identifier -&gt; identifier : '$1'.
dot_identifier -&gt; matched_expr dot_op identifier : build_dot('$2', '$1', '$3').

dot_op_identifier -&gt; op_identifier : '$1'.
dot_op_identifier -&gt; matched_expr dot_op op_identifier : build_dot('$2', '$1', '$3').

call_args_no_parens_comma_expr -&gt; matched_expr ',' call_args_no_parens_expr : ['$3', '$1'].
call_args_no_parens_comma_expr -&gt; call_args_no_parens_comma_expr ',' call_args_no_parens_expr : ['$3'|'$1'].

call_args_no_parens_many -&gt; matched_expr ',' call_args_no_parens_kw : ['$1', '$3'].
call_args_no_parens_many -&gt; call_args_no_parens_comma_expr : reverse('$1').
call_args_no_parens_many -&gt; call_args_no_parens_comma_expr ',' call_args_no_parens_kw : reverse(['$3'|'$1']).

call_args_no_parens_many_strict -&gt; call_args_no_parens_many : '$1'.
call_args_no_parens_many_strict -&gt; empty_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -&gt; open_paren call_args_no_parens_kw close_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -&gt; open_paren call_args_no_parens_many close_paren : throw_no_parens_strict('$1').
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								No parentheses function calls were the first function calls to be implemented because
								no parens expr (<code>no_parens_expr</code>) is a direct child of the root
								<code>expr</code> rule.
							</p>
							<p>
								I knew from using Elixir that these rules had to match parentheses-less calls I was
								used to writing.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-conversion">
						<h1>Conversion</h1>
						<ol>
							<li>
								<figure>
									<figcaption>
										Original
									</figcaption>
									<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%">
no_parens_expr -&gt; dot_identifier call_args_no_parens_many_strict

dot_identifier -&gt; identifier
dot_identifier -&gt; matched_expr dot_op identifier
									</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>
										Compact <code>dot_identifier</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%">
no_parens_expr -&gt; dot_identifier call_args_no_parens_many_strict

dot_identifier ::= (matched_expr dot_op)? identifier
									</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>
										Inline <code>dot_identifer</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%; width: 51em">
no_parens_expr ::= (matched_expr dot_op)? identifier call_args_no_parens_many_strict
									</code></pre>
								</figure>
							</li>
						</ol>
						<aside class="notes">
							<p>
								When converting the YECC BNF to Grammar Kit BNF, I need to combine clauses using the
								extra features available in Parsing Expression Grammars.  This also helps me reason
								about the rule as Parsing Expression Grammars have more regular expression like
								syntax. I can evaluate those in my mind easier as they eliminate redundancies in the
								grammar and make the branch points more obvious to me.
							</p>
							<p>
								That first anonymous group was a problem: the pratt parser generator for Grammar Kit
								only works if a rule is used as a direct operand and matched expression
								(<code>matched_expr</code>) needs to be indirect to allow both qualified and
								unqualified no parentheses calls.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-unqualified">
						<h1>Unqualified</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L82-L162">
									<code>src/org/elixir_lang/Elixir.bnf#</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 105%; line-height: 100%">
private expression ::= emptyParentheses |
                       unqualifiedNoParenthesesManyArgumentsCall |
                       matchedExpression

noParenthesesManyArgumentsUnqualifiedIdentifier ::= IDENTIFIER
                                                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
unqualifiedNoParenthesesManyArgumentsCall ::= noParenthesesManyArgumentsUnqualifiedIdentifier
                                              noParenthesesManyArgumentsStrict
                                              {
                                                implements = "org.elixir_lang.psi.Call"
                                                methods = [
                                                  getArguments
                                                  getIdentifier
                                                  quote
                                                ]
                                              }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Now, the only duplication is having a special rule for the IDENTIFIER token quoting.
							</p>
							<p>
								So, an unqualified no parentheses many arguments call
								(<code>unqualfifiedNoParenthesesManyArgumentsCall</code>) is exactly what it sounds
								like: unqualified because it's only an identifier, no parentheses, and has many
								arguments, which I'll get to in a bit.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-qualified">
						<h1>Qualified</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L190-L1338">
									<code>src/org/elixir_lang/Elixir.bnf#</code>
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 120%; line-height: 100%">
noParenthesesNoArgumentsUnqualifiedCallOrVariable ::= IDENTIFIER
                                                      { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

matchedExpression ::= matchedCaptureNonNumericOperation |
                      // ...
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                      accessExpression

matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
                         {
                           implements = "org.elixir_lang.psi.Call"
                           methods = [
                             getArguments
                             getIdentifier
                             quote
                           ]
                         }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So's there's another rule just for quoting the <code>IDENTIFIER</code> token, but
								they need to be separate because no parentheses no arguments qualified call or variable
								(<code>noParenthesesNoArgumentsUnqualifiedCallOrVariable</code>) extends matched
								expression (<code>matchedExpession</code>) for the Pratt Parser, so using it directly
								is the same as using matched expression (<code>matchedExpression</code>) directly.  That
								was a fun bug to figure out!
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-arguments">
						<h1>Arguments</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L418-L421">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
call_args_no_parens_many_strict -> call_args_no_parens_many : '$1'.
call_args_no_parens_many_strict -> empty_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -> open_paren call_args_no_parens_kw close_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -> open_paren call_args_no_parens_many close_paren : throw_no_parens_strict('$1').
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L122-L147">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 135%; line-height: 100%">
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS
                        { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Instead of having all 4 clauses from call args no parens many strict
								(<code>call_args_no_parens_many_strict</code>) directly under no parentheses many
								arguments strict (<code>noParenthesesManyArgumentStrict</code>) because it allowed
								me to use a single node, no parentheses strict (<code>noParenthesesStrict</code>),
								which was helpful for the first Intent.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-no-parentheses-strict">
						<h1>No Parentheses Strict</h1>
						<figure>
							<figcaption>
								Test Code
							</figcaption>
							<pre><code class="elixir stretch" data-trim>
function (first_positional, second_positional, key: value)
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<code>Code.string_to_quoted</code>
							</figcaption>
							<pre><code class="elixir stretch" data-trim style="font-size: 85%; line-height: 100%">
{:error,
 {1,
  "unexpected parenthesis. If you are making a function call, do not insert spaces in between the function name and the opening parentheses. Syntax error before: ",
  "'('"}}
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								Error highlighting and Quick Fix
							</figcaption>
							<img class="stretch" src="images/Remove%20Spaces%20Before%20Ambiguous%20Parentheses.gif" style="height: auto; width: 100%"/>
						</figure>
						<aside class="notes">
							<p>
								The Elixir parser throws errors immediately, but this stops the user from being able to
								correct later errors.  This can be a wise choice if anyone has ever seen the noise that
								a single error in C or C++ can make later in the file.
							</p>
							<p>
								For an IDE however, it would be annoying if syntax and error highlighting stopped at the
								first error, so invalid syntax, such as ambiguous parentheses are allowed in IntelliJ
								Elixir's parser and only marked as errors using an Inspection, which then allows the user
								to Quick Fix the error with Alt Enter (<code>ALT+Enter</code>) when the cursor is hovering
								over it.
							</p>
							<p>
								Being able to correct errors is one of the reasons that an IDEs grammar can be more
								permissive than the compiler's grammar: permissiveness in parser allows for more robust
								heuristics to mark the errors later.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-many-arguments">
						<h1>Many Arguments</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L400-L416">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 130%; line-height: 100%">
call_args_no_parens_expr -> matched_expr : '$1'.
call_args_no_parens_expr -> empty_paren : nil.
call_args_no_parens_expr -> no_parens_expr : throw_no_parens_many_strict('$1').

call_args_no_parens_comma_expr -> matched_expr ',' call_args_no_parens_expr : ['$3', '$1'].
call_args_no_parens_comma_expr -> call_args_no_parens_comma_expr ',' call_args_no_parens_expr : ['$3'|'$1'].

call_args_no_parens_many -> matched_expr ',' call_args_no_parens_kw : ['$1', '$3'].
call_args_no_parens_many -> call_args_no_parens_comma_expr : reverse('$1').
call_args_no_parens_many -> call_args_no_parens_comma_expr ',' call_args_no_parens_kw : reverse(['$3'|'$1']).
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L105-L138">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim>
private noParenthesesCommaExpression ::= matchedExpression (infixComma noParenthesesExpression)+
noParenthesesFirstPositional ::= matchedExpression
                                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
noParenthesesOnePositionalAndKeywordsArguments ::= noParenthesesFirstPositional infixComma noParenthesesKeywords
                                                   { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
noParenthesesManyPositionalAndMaybeKeywordsArguments ::= noParenthesesCommaExpression (infixComma noParenthesesKeywords)?
                                                         { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								calls args no parens comma expr many (<code>call_args_no_parens_many</code>) 3 clauses
								are just a way of saying there needs to be at least 2 arguments and keywords can only
								appear at the end.  This can be expressed slightly more compactly in Grammar Kit,
								but there still needs to be 2 rules to ensure that if there is only one positional
								argument there are also keyword arguments.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-expression">
						<h1>No Parentheses Expression</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L400-L402">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
								<pre><code class="stretch" data-trim style="font-size: 185%; line-height: 100%">
call_args_no_parens_expr -> matched_expr : '$1'.
call_args_no_parens_expr -> empty_paren : nil.
call_args_no_parens_expr -> no_parens_expr : throw_no_parens_many_strict('$1').
								</code></pre>
							</figcaption>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf#L201-L211">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
noParenthesesExpression ::= emptyParentheses |
                            /* Must be before matchedExpression because noParenthesesExpression is
                               `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is longer
                               than `matchedExpressionDotIdentifier` in matchedExpression. */
                            /* This will be marked as an error by
                               {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                            noParenthesesManyStrictNoParenthesesExpression |
                            matchedExpression !KEYWORD_PAIR_COLON
                            { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								As I already mentioned: more comments means I had more problems getting the grammar
								right.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-matched-expression-vs-keyword-key">
						<h1>MatchedExpression vs KeywordKey</h1>
						<ol>
							<li>
								<code>matchedExpression</code>
							</li>
							<li class="fragment">
								<code>matchedExpression ::= accessExpression</code>
							</li>
							<li class="fragment">
								<code>accessionExpression ::= stringLine</code>
							</li>
							<li class="fragment">
								<code>quote ::= stringLine</code>
							</li>
							<li class="fragment">
								<code>keywordKey ::= quote</code>
							</li>
							<li class="fragment">
								<code>private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*</code>
								<br/>
								<code>noParenthesesKeywordPair ::= keywordKeyColonEOL noParenthesesExpression</code>
							</li>
							<li class="fragment">
								<code>noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*</code>
							</li>
							<li class="fragment">
								<code>noParenthesesOnePositionalAndKeywordsArguments ::= noParenthesesFirstPositional infixComma noParenthesesKeywords</code>
								<br/>
								<code>noParenthesesManyPositionalAndMaybeKeywordsArguments ::= noParenthesesCommaExpression (infixComma noParenthesesKeywords)?</code>
							</li>
						</ol>
						<aside class="notes">
							<p>
								Having to put not keyword pair colon (<code>!KEYWORD_PAIR_COLON</code>) after
								matchedExpression is one of the places where one has to think recursively through the
								rules: matched expression (<code>matchedExpression</code>) contains access expession
								(<code>accessExpression</code>). [hit space]  Access expression contains string line
								(<code>stringLine</code>) [hit space], but a string (or char list) is contained in
								quoted [hit space], which is contained in keyword key (<code>keywordKey</code>)
								[hit space], which is contained in no parentheses keyword pair
								(<code>noParenthesesKeywordPair</code> [hit space], which is contained in no parentheses
								keywords (<code>noParenthesesKeywords</code>) [hit space], which is the tail of
								no parentheses function calls. [hit space]
							</p>
							<p>
								The native parser does not have this problem because it tokenizes quoted keyword key
								atoms as just keyword identifiers, which it can do since it can hold as much text
								as it wants in a buffer to represent a token.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-matched-expression">
						<h1>In Matched Expression</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L113-L169">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 145%; line-height: 100%">
matched_expr -> matched_expr no_parens_op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
matched_expr -> unary_op_eol no_parens_expr : build_unary_op('$1', '$2').
matched_expr -> at_op_eol no_parens_expr : build_unary_op('$1', '$2').
matched_expr -> capture_op_eol no_parens_expr : build_unary_op('$1', '$2').

no_parens_op_expr -> match_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> add_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> mult_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> hat_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> two_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> and_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> or_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> in_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> in_match_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> type_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> pipe_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> comp_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> rel_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> arrow_op_eol no_parens_expr : {'$1', '$2'}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Adding no parentheses function calls on their own was simple enough, but getting no
								parentheses function calls as the right-most operand (and only the right-most operand)
								in a matched expression took up the majority of the version zero dot two dot one
								(<code>v0.2.1</code>): 454 of 521 commits in
								<a href="https://github.com/KronicDeth/intellij-elixir/pull/105">pull request 105</a>.
								It involved abandonning the succinct Pratt Parser for the majority of the time because
								I couldn't figure out how to get
							</p>
							<p>
								For a very long time I was stuck on how to ensure that a <code>no_parens_expr</code>
								could only appear on the right hand-side of a matched expression and knowing that
								it had to be the the end of the matched expression because otherwise two
								no parentheses calls could be next to each other.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-call-matched-call-operation">
						<h1>Matched Call Operation</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/2c9892cacd00a8bb6d0d456ebf0e3899219b89ef/src/org/elixir_lang/Elixir.bnf#L908-L1338">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 195%; line-height: 100%">
matchedExpression ::= matchedCaptureNonNumericOperation |
                      matchedInMatchOperation |
                      matchedWhenNoParenthesesKeywordsOperation |
                      matchedWhenOperation |
                      matchedTypeOperation |
                      matchedPipeOperation |
                      matchedMatchOperation |
                      matchedOrOperation |
                      matchedAndOperation |
                      matchedComparisonOperation |
                      matchedRelationalOperation |
                      matchedArrowOperation |
                      matchedInOperation |
                      matchedTwoOperation |
                      matchedAdditionOperation |
                      matchedMultiplicationOperation |
                      matchedHatOperation |
                      matchedUnaryNonNumericOperation |
                      matchedDotOperation |
                      matchedAtNonNumericOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                      accessExpression

matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								What finally cracked the problem was when I realized that the no parentheses calls
								by their very nature would consume function calls to the right of the first
								no parentheses call as either a positional argument to the right call, which the
								inspections could pick up as an error or as a keyword value, which is actually legal.
							</p>
							<p>
								Because the way the Pratt Parser works, matchedCallOperation can either be the only
								element of an expression or the right-most expression.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-qualified-matched-call-operation">
						<h1>Qualified Matched Call Operation</h1>
						<ol>
							<li>
								<figure>
									<figcaption>
										Rule Subset
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                      accessExpression
matchedDotOperation ::= matchedExpression dotInfixOperator matchedExpression
matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
accessExpression ::= alias
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Inline <code>alias</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable
matchedDotOperation ::= alias dotInfixOperator matchedExpression
matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Inline <code>matchedCallOperation</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
matchedDotOperation ::= alias dotInfixOperator matchedCallOperation
matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Expand <code>matchedCallOperation</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable
matchedDotOperation ::= alias dotInfixOperator matchedExpression noParenthesesManyArgumentsStrict
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Inline <code>noParenthesesNoArgumentsUnqualifiedCallOrVariable</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedDotOperation ::= alias dotInfixOperator noParenthesesNoArgumentsUnqualifiedCallOrVariable noParenthesesManyArgumentsStrict
									</code></pre>
									<pre class="fragment"><code class="stretch" style="width: 78em">
                        Kernel .               inspect                                           0..1, structs: false
									</code></pre>
								</figure>
							</li>
						</ol>
						<aside class="notes">
							<p>
								Using the precedence rules for Pratt Parsers, any early choice can chose a later choice
								as a substitution for the base rule, <code>matchedExpression</code>.
							</p>
							<p>
								Starting with a subset of the rules including dot and alias, [hit space]
								the alias is substituted into the lower precedence dot operation because lower
								precedence operations wrap higher precedence operators, think additions taking
								multiplications as arguments.
							</p>
							<p>
								[hit space] On the right-hand operand, <code>matchedCallOperation</code>, is
								substituted, which [hit space] can be expanded to another <code>matchedExpression</code>,
								[hit space] which will be an identifer, which [hit space] matches a remote no
								parentheses call.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="jinterface">
						<h1>JInterface</h1>
						<ul>
							<li>
								<a href="#/jinterface-quoted-vs-psi">Quoted vs PSI</a>
							</li>
							<li>
								<a href="#/jinterface-node">Node</a>
							</li>
							<li>
								<a href="#/jinterface-mailbox">Mailbox</a>
							</li>
							<li>
								<a href="#/jinterface-message">Message</a>
							</li>
							<li>
								<p>Quoted</p>
								<ul>
									<li>
										<a href="#/jinterface-quoted-expected">Expected</a>
									</li>
									<li>
										<p>Pattern</p>
										<ul>
											<li>
												<a href="#/jinterface-quoted-pattern-yecc">YECC</a>
											</li>
											<li>
												<a href="#/jinterface-quoted-pattern-intellij-elixir">IntelliJ Elixir</a>
											</li>
										</ul>
									</li>
									<li>
										<a href="#/jinterface-quoted-actual">Actual</a>
									</li>
									<li>
										<a href="#/jinterface-quoted-block">Block</a>
									</li>
									<li>
										<a href="#/jinterface-quoted-comparison">Comparison</a>
									</li>
								</ul>
							</li>
							<li>
								<a href="#/jinterface-char-list">Char List</a>
							</li>
							<li>
								<a href="#/jinterface-protocol">Protocol</a>
							</li>
							</li>
						</ul>
					</section>
					<section id="jinterface-quoted-vs-psi">
						<h1>Quoted vs PSI</h1>
						<table>
							<caption>
								<code>1 + 2 = 3 + 4</code>
							</caption>
							<thead>
							<tr>
								<th>
									<code>Code.string_to_quoted!</code>
								</th>
								<th>
									<code>psiToString</code>
								</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<pre><code class="elixir fade-out fragment stretch" data-fragment-index="1" data-trim style="width: 40em">
{:=, [line: 1], [{:+, [line: 1], [1, 2]}, {:+, [line: 1], [3, 4]}]}
									</code></pre>
									<pre><code class="elixir fragment stretch" data-fragment-index="1" data-trim>
{
 :=,
 [line: 1],
 [
  {
   :+,
   [line: 1],
   [
    1,
    2
   ]
  },
  {
   :+,
   [line: 1],
   [
    3,
    4
   ]
  }
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="stretch" data-trim style="width: 43em">
Elixir File(0,13)
  ElixirMatchedMatchOperationImpl(MATCHED_MATCH_OPERATION)(0,13)
    ElixirMatchedAdditionOperationImpl(MATCHED_ADDITION_OPERATION)(0,5)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(0,1)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(0,1)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(0,1)
            PsiElement(VALID_DECIMAL_DIGITS)('1')(0,1)
      PsiWhiteSpace(' ')(1,2)
      ElixirAdditionInfixOperatorImpl(ADDITION_INFIX_OPERATOR)(2,3)
        PsiElement(DUAL_OPERATOR)('+')(2,3)
      PsiWhiteSpace(' ')(3,4)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(4,5)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(4,5)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(4,5)
            PsiElement(VALID_DECIMAL_DIGITS)('2')(4,5)
    PsiWhiteSpace(' ')(5,6)
    ElixirMatchInfixOperatorImpl(MATCH_INFIX_OPERATOR)(6,7)
      PsiElement(MATCH_OPERATOR)('=')(6,7)
    PsiWhiteSpace(' ')(7,8)
    ElixirMatchedAdditionOperationImpl(MATCHED_ADDITION_OPERATION)(8,13)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(8,9)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(8,9)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(8,9)
            PsiElement(VALID_DECIMAL_DIGITS)('3')(8,9)
      PsiWhiteSpace(' ')(9,10)
      ElixirAdditionInfixOperatorImpl(ADDITION_INFIX_OPERATOR)(10,11)
        PsiElement(DUAL_OPERATOR)('+')(10,11)
      PsiWhiteSpace(' ')(11,12)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(12,13)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(12,13)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(12,13)
            PsiElement(VALID_DECIMAL_DIGITS)('4')(12,13)
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Through part of version zero dot two dot one (<code>v0.2.1</code>), I had to manually
								compare the PSI format output by the test cases for IntelliJ Elixir and the output of
								code dot string to quoted (<code>Code.string_to_quoted</code>) in I-E-X
								(<code>iex</code>).
							</p>
							<p>
								It's not easy to compare quoted form to the PSI tree as shown. [hit space]  So,
								I normally would have to indent the quoted form to match the PSI tree.
							</p>
							<p>
								So, I'd read this as there's an equals at the top level and that matches the elixir
								matched match operation implementation (<code>ElixirMatchedMatchOperationImpl</code>).
								Then, there's two additions operation siblings, which matches the elixir matched
								addition operation implementations (<code>ElixirMatchedAdditionOperationImpl</code>)
								siblings, but I have to know to ignore the PSIWhitespace and the elixir match infix
								operator implementation (<code>ElixirMatchInfixOperatorImpl</code>) that's between
								the two addition operations.  Finally, as I need to check that the operand order: one
								two three four (<code>1 2 3 4</code>) matches.
							</p>
							<p>
								I'd have to do this any time I changed the nesting of the grammar such as when
								introducing new error handling or making some nodes private so they don't appear in the
								output PSI.
							</p>
						</aside>
					</section>
					<section id="jinterface-node">
						<h1>Node</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/IntellijElixir.java">
									<code>src/org/elixir_lang/IntellijElixir.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 200%; line-height: 100%">
package org.elixir_lang;

import com.ericsson.otp.erlang.OtpNode;

import java.io.IOException;

public class IntellijElixir {
    private static OtpNode localNode = null;
    public static final String REMOTE_NODE = "intellij_elixir@127.0.0.1";

    public static OtpNode getLocalNode() throws IOException {
        if (localNode == null) {
            localNode = new OtpNode(
                "intellij-elixir@127.0.0.1",
                "intellij_elixir"
            );
        }

        return localNode;
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								IntelliJ's SDK is written in Java and I knew one could use Java to talk to Erlang
								through JInterface, so I decided just have JInterface tell me if I got the PSI correct
								by using nodes respond to <code>quote</code>, which would spit out JInterface objects
								that matched the output from code dot string to quoted
								(<code>Code.string_to_quoted</code>).
							</p>
							<p>
								The first step in using JInterface is creating a Java node using O-T-P Node
								(<code>OtpNode</code>).  The first argument is the node name.  I use a full name
								instead of a short name so I can ensure that it binds to the IPv4 loop-back address,
								127 dot 0 dot 0 dot 1 (<code>127.0.0.1</code>) so it doesn't randomly bind to the
								IPv6 address or to 0 dot 0 dot 0 dot 0 (<code>0.0.0.0</code>), which would allow the
								entire network to talk to the node.
							</p>
							<p>
								The local and remote names are very close: the Java node uses a dash between intellij
								and elixir while the Elixir node uses an underscore.
							</p>
						</aside>
					</section>
					<section id="jinterface-mailbox">
						<h1>Mailbox</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/intellij_elixir/Quoter.java#L222-L230">
									<code>src/org/elixir_lang/intellij_elixir/Quoter.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 155%; line-height: 100%">
package org.elixir_lang.intellij_elixir;

public class Quoter {
    public static OtpErlangTuple quote(@NotNull String code) throws IOException,
                                                                    OtpErlangExit,
                                                                    OtpErlangDecodeException {
        final OtpNode otpNode = IntellijElixir.getLocalNode();
        final OtpMbox otpMbox = otpNode.createMbox();

        OtpErlangObject quoteMessage = Quoter.quoteMessage(code, otpMbox.self());
        otpMbox.send(REMOTE_NAME, IntellijElixir.REMOTE_NODE, quoteMessage);

        return (OtpErlangTuple) otpMbox.receive(TIMEOUT_IN_MILLISECONDS);
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Once we have a node, we need a pid send so the Elixir code can talk back to Java.  Java
								doesn't have processes, so instead of getting a process from the node and then getting its
								pid, one instead creates a mailbox, which has a pid.
							</p>
							<p>
								Java has no pattern matching, so <code>receive</code> just grabs the next message that is
								available.  It's up to the Java code to maintain unmatched messages, but that wasn't
								necessary here.
							</p>
						</aside>
					</section>
					<section id="jinterface-message">
						<h1>Message</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/intellij_elixir/Quoter.java#L237-L248">
									<code>src/org/elixir_lang/intellij_elixir/Quoter.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 155%; line-height: 100%">
package org.elixir_lang.intellij_elixir;

public class Quoter {
    public static OtpErlangObject quoteMessage(final String text, final OtpErlangPid self) {
        final OtpErlangAtom[] messageKeys = new OtpErlangAtom[]{
                new OtpErlangAtom("quote"),
                new OtpErlangAtom("for")
        };
        final OtpErlangObject[] messageValues = new OtpErlangObject[]{
                elixirString(text),
                self
        };

        return new OtpErlangMap(messageKeys, messageValues);
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								A the time, I hadn't see Joe Devivo's code for gen_java, so I wasn't sure how to fake
								a gen server call format message, so I just used a map.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-expected">
						<h1>Quoted</h1>
						<h2>Expected</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij_elixir/blob/25d5ea28ed0d92aaf9bc7cdfcbeb3f8e019ad4e3/lib/intellij_elixir/supervisor.ex">
									<code>lib/intellij_elixir/supervisor.ex</code>
								</a>
							</figcaption>
							<pre><code class="elixir stretch" data-trim style="font-size: 130%; line-height: 100%">
defmodule IntellijElixir.Supervisor do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, :ok)
  end

  @quoter_module IntellijElixir.Quoter

  def init(:ok) do
    children = [
      worker(@quoter_module, [[], [name: @quoter_module]])
    ]

    supervise(children, strategy: :one_for_one)
  end
end
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij_elixir/blob/25d5ea28ed0d92aaf9bc7cdfcbeb3f8e019ad4e3/lib/intellij_elixir/quoter.ex">
									<code>lib/intellij_elixir/quoter.ex</code>
								</a>
							</figcaption>
							<pre><code class="elixir stretch" data-trim style="font-size: 130%; line-height: 100%">
defmodule IntellijElixir.Quoter do
  use GenServer

  def start_link(args, opts \\ []) do
    GenServer.start_link(__MODULE__, args, opts)
  end

  def handle_info(%{quote: code, for: pid}, state) do
    {status, quoted} = Code.string_to_quoted(code)
    send pid, {status, %{code: code, quoted: quoted}}

    {:noreply, state}
  end
end
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								intellij underscore elixir (<code>intellij_elixir</code> is very simple:  it is
								supervised gen server (<code>GenServer</code>) that takes the quote-for
								(<code>%{quote:, for:}</code>) messages, runs code dot string to quoted
								(<code>Code.string_to_quoted</code>) on the code and sends back the status and quoted
								form.
							</p>
							<p>
								Originally, I thought the supervisor was overkill, but it turned out very useful when
								starting to test when the IntelliJ Elixir could parse around errors (as most IDEs do):
								code dot string to quoted (<code>Code.string_to_quoted</code>), in addition to returning
								tuples with ok (<code>:ok</code>) or error (<code>:error</code>) for the status can
								also raise an exception, so with the supervisor, the quoter would restart for the next
								test case and I got a nice exit message in Java.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-pattern-yecc">
						<h1>Quoted</h1>
						<h2>Pattern</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L113-L189">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 145%; line-height: 100%">
matched_expr -> matched_expr matched_op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
matched_expr -> matched_expr no_parens_op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).

matched_op_expr -> match_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> add_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> mult_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> hat_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> two_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> and_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> or_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> in_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> in_match_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> type_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> when_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> pipe_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> comp_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> rel_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> arrow_op_eol matched_expr : {'$1', '$2'}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In YECC, I have to repeat the pattern for quoting the tail of infix operations for each
								tail.  The pattern is short, so it's not a big deal, but it's not easy to know that this
								two tuple pattern is unrelated to the two tuple pattern used for keyword pairs.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-pattern-intellij-elixir">
						<h1>Quoted</h1>
						<h2>Pattern</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L1048-L1067">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 120%; line-height: 100%">
matchedMatchOperation ::= matchedExpression matchInfixOperator matchedExpression
                          { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] rightAssociative = true }

matchedOrOperation ::= matchedExpression orInfixOperator matchedExpression
                       { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#L525-L549">
									<code>src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 120%; line-height: 100%">
public class ElixirPsiImplUtil {
    @Contract(pure = true)
    @NotNull
    public static OtpErlangObject quote(@NotNull final InfixOperation infixOperation) {
        PsiElement[] children = infixOperation.getChildren();

        if (children.length != 3) {
            throw new NotImplementedException(
                "BinaryOperation expected to have 3 children (left operand, operator, right operand"
            );
        }

        Quotable leftOperand = (Quotable) children[0];
        OtpErlangObject quotedLeftOperand = leftOperand.quote();

        Quotable operator = (Quotable) children[1];
        OtpErlangObject quotedOperator = operator.quote();

        Quotable rightOperand = (Quotable) children[2];
        OtpErlangObject quotedRightOperand = rightOperand.quote();

        return quotedFunctionCall(
                quotedOperator,
                metadata(operator),
                quotedLeftOperand,
                quotedRightOperand
        );
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In Grammar Kit, I can have nodes implement interfaces, and then have methods defined
								for those interfaces, so I can more explicitly indicate that the quoting pattern is
								the same for match and or operation.
							</p>
							<p>
								Of course, this being Java, it is much more verbose than the Erlang in YECC.
							</p>
							<p>
								The error handle on children length is there because I wanted to make sure the
								parser couldn't have silent errors where it ignores input if I ended up having to
								make a systemic change the rules.  It also can prevent the IDE freezing that
								version zero dot zero dot one (<code>v0.0.1</code>) exhibited.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-actual">
						<h1>Quoted</h1>
						<h2>Actual</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#L1075-L1099">
									<code>src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 145%; line-height: 100%">
package org.elixir_lang.psi.impl;

public class ElixirPsiImplUtil {
    public static OtpErlangObject quote(ElixirFile file) {
        final Deque&lt;OtpErlangObject&gt; quotedChildren = new LinkedList&lt;OtpErlangObject&gt;();

        file.acceptChildren(
                new PsiElementVisitor() {
                    @Override
                    public void visitElement(PsiElement element) {
                        if (element instanceof Quotable) {
                            visitQuotable((Quotable) element);
                        } else if (!isUnquoted(element)) {
                            throw new NotImplementedException("Don't know how to visit " + element);
                        }

                        super.visitElement(element);
                    }

                    public void visitQuotable(@NotNull Quotable child) {
                        final OtpErlangObject quotedChild = child.quote();
                        quotedChildren.add(quotedChild);
                    }
                }
        );

        return block(quotedChildren);
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								P-S-I element (<code>PSIElement</code>) has an accept children
								(<code>acceptChildren</code>) method that allows the code to quote a file by just
								quoting the top-level elements and then turning it into a block.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-block">
						<h1>Quoted</h1>
						<h2>Block</h2>
						<table>
							<thead>
							<tr>
								<th>Erlang</th>
								<th>Java</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<figure>
										<figcaption>
											<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L717-L718">
												<code>lib/elixir/src/elixir_parser.yrl</code>
											</a>
										</figcaption>
										<pre><code class="erlang stretch" data-trim style="width: 32em">
to_block([One]) -> One;
to_block(Other) -> {'__block__', [], reverse(Other)}.
										</code></pre>
									</figure>
								</td>
								<td>
									<figure>
										<figcaption>
											<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#L118-L140">
												<code>src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java</code>
											</a>
											<pre><code class="java stretch" data-trim style="width: 57em">
package org.elixir_lang.psi.impl;

public class ElixirPsiImplUtil {
    @Contract(pure = true)
    @NotNull
    public static OtpErlangObject block(@NotNull final Deque&lt;OtpErlangObject&gt; quotedChildren) {
        OtpErlangObject asBlock;
        final int size = quotedChildren.size();

        if (size == 0) {
            asBlock = NIL;
        } else if (size == 1) {
            asBlock = quotedChildren.getFirst();
        } else {
            OtpErlangObject[] quotedArray = new OtpErlangObject[size];
            OtpErlangList blockMetadata = new OtpErlangList();

            asBlock = quotedFunctionCall(
                    BLOCK,
                    blockMetadata,
                    quotedChildren.toArray(quotedArray)
            );
        }

        return asBlock;
    }
}
											</code></pre>
										</figcaption>
									</figure>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								to block (<code>to_block</code>) in Erlang and block (<code>block</code>) in Java are
								similar, but of course, the Java code is way more verbose to make a tuple.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-comparison">
						<h1>Quoted</h1>
						<h1>Comparison</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/intellij_elixir/Quoter.java#L62-L103">
									<code>src/org/elixir_lang/intellij_elixir/Quoter.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 95%; line-height: 100%">
package org.elixir_lang.intellij_elixir;

public class Quoter {
    public static void assertQuotedCorrectly(PsiFile file) {
        final String text = file.getText();

        try {
            OtpErlangTuple quotedMessage = Quoter.quote(text);
            Quoter.assertMessageReceived(quotedMessage);

            OtpErlangAtom status = (OtpErlangAtom) quotedMessage.elementAt(0);
            String statusString = status.atomValue();
            OtpErlangMap map = (OtpErlangMap) quotedMessage.elementAt(1);
            assertCodeEquals(text, map);
            OtpErlangObject expectedQuoted = quoted(map);

            if (statusString.equals("ok")) {
                OtpErlangObject actualQuoted = ElixirPsiImplUtil.quote(file);
                assertEquals(expectedQuoted, actualQuoted);
            } else if (statusString.equals("error")) {
                OtpErlangTuple error = (OtpErlangTuple) expectedQuoted;

                OtpErlangLong line = (OtpErlangLong) error.elementAt(0);

                OtpErlangBinary messageBinary = (OtpErlangBinary) error.elementAt(1);
                String message = javaString(messageBinary);

                OtpErlangBinary tokenBinary = (OtpErlangBinary) error.elementAt(2);
                String token = javaString(tokenBinary);

                throw new AssertionError(
                        "intellij_elixir returned \"" + message + "\" on line " + line + " due to " + token  +
                                ", use assertQuotesAroundError if error is expect in Elixir natively, " +
                                "but not in intellij-elixir plugin"
                );
            }
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        } catch (OtpErlangDecodeException e) {
            throw new RuntimeException(e);
        } catch (OtpErlangExit e) {
            throw new RuntimeException(e);
        }
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The actual comparison comes down to just equals call between the actual quoted form
								from the Elixir File and the expected quoted from code dot strin to quoted
								(<code>Code.string_to_quoted</code>)
							</p>
						</aside>
					</section>
					<section id="jinterface-char-list">
						<h1>Char List</h1>
						<table>
							<thead>
							<tr>
								<th colspan="2">Range</th>
								<th rowspan="2">Java Class</th>
							</tr>
							<tr>
								<th>Start</th>
								<th>End</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>0</td>
								<td>255</td>
								<td>
									<code>OtpErlangString</code>
								</td>
							</tr>
							<tr>
								<td>256</td>
								<td>N/A</td>
								<td>
									<code>OtpErlangList</code>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								From the Basic Types of the Getting Started guide for Elixir or just messing around
								in I-E-X (<code>iex</code>), we know that sometimes lists of numbers will render as
								a single-quoted char list.  From this, we have a mental model that a char list is
								just formatting decision: a list of whole numbers is rendered as a char list if all the
								numbers are printable ASCII.
							</p>
							<p>
								But, the name char list is much more precise: O-T-P erlang string
								(<code>OtpErlangString</code>) is only returned from receive if all the numbers fit in
								an unsigned char C type, i.e. 0 to 255.
							</p>

						</aside>
					</section>
					<section id="jinterface-protocol">
						<h1>Protocol</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/jinterface/java_src/com/ericsson/otp/erlang/OtpInputStream.java#L1214-L1227">
									<code>lib/jinterface/java_src/com/ericsson/otp/erlang/OtpInputStream.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 165%; line-height: 100%">
package com.ericsson.otp.erlang;

public class OtpInputStream extends ByteArrayInputStream {
    public OtpErlangObject read_any() throws OtpErlangDecodeException {
        // ...
        switch(tag) {
        // ...
        case OtpExternal.stringTag:
            return new OtpErlangString(this);

        case OtpExternal.listTag:
            return new OtpErlangList(this);
        // ...
        }
    }
}
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/jinterface/java_src/com/ericsson/otp/erlang/OtpExternal.java#L59-L66">
									<code>lib/jinterface/java_src/com/ericsson/otp/erlang/OtpExternal.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 165%; line-height: 100%">
package com.ericsson.otp.erlang;

public class OtpExternal {
    /** The tag used for empty lists */
    public static final int nilTag = 106;

    /** The tag used for strings and lists of small integers */
    public static final int stringTag = 107;

    /** The tag used for non-empty lists */
    public static final int listTag = 108;
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								This isn't just an artifact of JInterface, the actual Erlang wire protocol uses a
								different tag for Erlang Strings (in other words Elixir Char Lists) vs
								generic strings.  It even goes so far to reserve a special tag for empty lists because
								they are so common.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="significant-whitespace">
						<h1>Significant Whitespace</h1>
						<ul>
							<li>
								<a href="#/significant-whitespace-comment-after-dot">
									Comment After Dot
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-dot-operation">
									<code>DOT_OPERATION</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-strip-dot-space">
									<code>strip_dot_space</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-arguments-vs-calls">
									Arguments vs Calls
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-bracket-identifier-and-paren-identifier">
									<code>bracket_identifier</code> and <code>paren_identifier</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-zero-width-call">
									<code>CALL</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-operations">
									Operations
								</a>
							</li>
						</ul>
					</section>
					<section id="significant-whitespace-comment-after-dot">
						<h1>Comment after Dot</h1>
						<table style="font-size: 90%">
							<caption>
								Issue
								<a href="https://github.com/elixir-lang/elixir/issues/3316">
									#3316
								</a>
								<a href="https://github.com/elixir-lang/elixir/commit/970f84382bdcdb4621d62bb765f94f280d313c99">Fixed</a>
								in Elixir v1.1.0
							</caption>
							<thread>
								<tr>
									<th colspan="2">Uncommented</th>
									<th colspan="2">Commented</th>
								</tr>
								<tr>
									<th>Code</th>
									<th>Quoted</th>
									<th>Code</th>
									<th>Quoted</th>
								</tr>
							</thread>
							<tbody>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module.
identifier
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :ok,
 {
  {
   :.,
   [line: 1],
   [
    {
     :__aliases__,
     [counter: 0, line: 1],
     [:Module]
    },
    :function
   ]
  },
  [line: 1],
  []
 }
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module. # a comment
identifier
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :ok,
 {
  {
   :.,
   [line: 1],
   [
    {
     :__aliases__,
     [counter: 0, line: 1],
     [:Module]
    },
    :function
   ]
  },
  [line: 1],
  []
 }
}
									</code></pre>
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module.
|>
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :ok,
 {
  {
   :.,
   [line: 1],
   [
    {
     :__aliases__,
     [counter: 0, line: 1],
     [:Module]
    },
    :|>
   ]
  },
  [line: 1],
  []
 }
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module. # a comment
|>
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :error,
 {
  2,
  "syntax error before: ",
  "'|>'"
  }
}
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The first bug I discovered in the native tokenizer involved how it handled dots and
								comments: the fact that a dot preceded a token, and so the token should act as an
								identifier wasn't tracked.  It just happened to work for identifiers because they're
								always identifiers, but operators are only identifiers if only whitespace separates
								the dot and the operator.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-dot-operation">
						<h1>Dot Operation</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/22d358b28516aa2448d0cd032742d4a48fc61292/src/org/elixir_lang/Elixir.flex#L585-L828">
									<code>src/org/elixir_lang/Elixir.flex</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%">
&lt;YYINITIAL, INTERPOLATION&gt; {
  {DOT_OPERATOR} { pushAndBegin(DOT_OPERATION);
                   return ElixirTypes.DOT_OPERATOR; }
}

&lt;DOT_OPERATION&gt; {
  {AND_OPERATOR} { yybegin(CALL_MAYBE);
                   return ElixirTypes.AND_OPERATOR; }

  /*
   * Emulates strip_space in elixir_tokenizer.erl
   */

  {ESCAPED_EOL}|{WHITE_SPACE}+ { return TokenType.WHITE_SPACE; }
  {EOL}                        { return ElixirTypes.EOL; }

  {COMMENT}                    { return ElixirTypes.COMMENT; }

  .                            { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                                 handleInState(stackFrame.getLastLexicalState()); }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In order to handle operators as identifiers, but only after dot, I had to add a dot
								operation (<code>DOT_OPERATION</code>) state to elixir dot flex
								(<code>Elixir.flex</code>).
							</p>
							<p>
								Ensuring a operator works as an identifier was just a matter of adding the comment
								(<code>{COMMENT}</code>) rule to the state so a comment would state in dot operation
								(<code>DOT_OPERATION</code>), just like white space and E-O-L instead of using the catch
								all rule that pops the stack.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-strip-dot-space">
						<h1>
							<a href="https://github.com/elixir-lang/elixir/commit/970f84382bdcdb4621d62bb765f94f280d313c99">
								<code>strip_dot_space</code>
							</a>
						</h1>
						<table>
							<tr>
								<th>Time</th>
								<th>Code</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Before</td>
								<td>
									<pre><code class="erlang stretch" data-trim style="font-size: 185%; line-height: 100%; width: 45em">
tokenize([$.|T], Line, Column, Scope, Tokens) ->
  {Rest, Counter, Offset} = strip_space(T, 0, Column + 1),
  handle_dot([$.|Rest], Line + Counter, Offset - 1, Column, Scope, Tokens);

strip_space(T, Counter, Column) ->
  case strip_horizontal_space(T) of
    {"\r\n" ++ Rest, _} -> strip_space(Rest, Counter + 1, 1);
    {"\n" ++ Rest, _}   -> strip_space(Rest, Counter + 1, 1);
    {Rest, Length}      -> {Rest, Counter, Column + Length}
  end.
									</code></pre>
								</td>
							</tr>
							<tr>
								<td>
									After
								</td>
								<td>
									<pre><code class="erlang stretch" data-trim style="font-size: 185%; line-height: 100%; width: 48em">
tokenize([$.|T], Line, Column, Scope, Tokens) ->
  {Rest, Counter, Offset} = strip_dot_space(T, 0, Column + 1),
  handle_dot([$.|Rest], Line + Counter, Offset - 1, Column, Scope, Tokens);

strip_dot_space(T, Counter, Column) ->
  case strip_horizontal_space(T) of
    {"#" ++ Rest, _}    -> strip_dot_space(tokenize_comment(Rest), Counter, 1);
    {"\r\n" ++ Rest, _} -> strip_dot_space(Rest, Counter + 1, 1);
    {"\n" ++ Rest, _}   -> strip_dot_space(Rest, Counter + 1, 1);
    {Rest, Length}      -> {Rest, Counter, Column + Length}
  end.
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								JosÃ©'s fix in Elixir itself follows a similar pattern of not just stripping spaces, but
								also comments after dot.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-arguments-vs-calls">
						<h1>Arguments vs Calls</h1>
						<table>
							<thead>
							<tr>
								<th rowspan="2"></th>
								<th colspan="2">No Space</th>
								<th colspan="2">Space</th>
							</tr>
							<tr>
								<th>Code</th>
								<th>Quoted</th>
								<th>Code</th>
								<th>Quoted</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Parentheses</th>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 12em">
function(positional)
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 19em">
{
 :function,
 [line: 1],
 [
  {:positional, [line: 1], nil}
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 11em">
function (grouped)
									</code></pre>
								</td>
								<td>
									Error
								</td>
							</tr>
							<tr>
								<th>Brackets</th>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 6em">
dict[key]
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stetch" data-trim style="font-size: 135%; line-height: 100%; width: 16em">
{
 {
  :.,
  [line: 1],
  [Access, :get]
 },
 [line: 1],
 [
  {:dict, [line: 1], nil},
  {:key, [line: 1], nil}
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 11em">
function [element]
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 18em">
{
 :function,
 [line: 1],
 [
  [
   {:element, [line: 1], nil}
  ]
 ]
}
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The only thing that separates an ambiguous parentheses and a parenthetical function
								call is the space between the identifier and the opening parentheses.
							</p>
							<p>
								Worse, a space or no space between an identifier and an opening square bracket is both
								valid: no space and it's a bracket operation, which used the access protocol; a
								space and it's a list as a argument to a no parentheses call.
							</p>
							<p>
								So, in order to support no parentheses function calls, parentheses function calls, and
								brackets, the space or lack thereof, becomes significant.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-bracket-identifier-and-paren-identifier">
						<h1>Bracket and Paren Identifier</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L454-L822">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 130%; line-height: 100%">
tokenize([H|_] = String, Line, Scope, Tokens) when ?is_downcase(H); H == $_ ->
  case tokenize_any_identifier(String, Line, Scope, Tokens) of
    {keyword, Rest, Check, T} ->
      handle_terminator(Rest, Line, Scope, Check, T);
    {identifier, Rest, Token} ->
      tokenize(Rest, Line, Scope, [Token|Tokens]);
    {error, _, _, _} = Error ->
      Error
  end;

tokenize_any_identifier(Original, Line, Scope, Tokens) ->
  {Rest, Identifier} = tokenize_identifier(Original, []),

  {AllIdentifier, AllRest} =
    case Rest of
      [H|T] when H == $?; H == $! -> {Identifier ++ [H], T};
      _ -> {Identifier, Rest}
    end,

  case unsafe_to_atom(AllIdentifier, Line, Scope) of
    {ok, Atom} ->
      tokenize_kw_or_other(AllRest, identifier, Line, Atom, Tokens);
    {error, Reason} ->
      {error, Reason, Original, Tokens}
  end.

tokenize_kw_or_other(Rest, Kind, Line, Atom, Tokens) ->
  case check_keyword(Line, Atom, Tokens) of
    nomatch ->
      {identifier, Rest, check_call_identifier(Kind, Line, Atom, Rest)};
    {ok, [Check|T]} ->
      {keyword, Rest, Check, T};
    {error, Token} ->
      {error, {Line, "syntax error before: ", Token}, atom_to_list(Atom) ++ Rest, Tokens}
  end.

check_call_identifier(_Kind, Line, Atom, [$(|_]) -> {paren_identifier, Line, Atom};
check_call_identifier(_Kind, Line, Atom, [$[|_]) -> {bracket_identifier, Line, Atom};
check_call_identifier(Kind, Line, Atom, _Rest)   -> {Kind, Line, Atom}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The Elixir tokenizer handles the no space and space situation by using separate tokens
								for identifier if there is no space: bracket identifier
								(<code>bracket_identifier</code>) when before an opening square bracket and paren
								identifier (<code>paren_identifier</code>) when before an opening parenthesis.
							</p>
							<p>
								How it gets to that point is somewhat long, from tokenizing an underscore or a lower
								case letter, it has to decide whether the identifier is a keyword or not.  While
								deciding if it's a keyword, it checks if it's a call identifier or a normal identifier.
								If it's a call identifier then it's broken down into a bracket identifier, paren
								identifier or normal identifier.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-zero-width-call">
						<h1>Zero-Width Call</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.3/src/org/elixir_lang/Elixir.flex#L616-L810">
									<code>src/org/elixir_lang/Elixir.flex</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 150%; line-height: 100%">
&lt;YYINITIAL, INTERPOLATION&gt; {
  {IDENTIFIER} { pushAndBegin(CALL_OR_KEYWORD_PAIR_MAYBE);
                 return ElixirTypes.IDENTIFIER; }
}

&lt;CALL_MAYBE, CALL_OR_KEYWORD_PAIR_MAYBE&gt; {
  {OPENING_BRACKET}|{OPENING_PARENTHESIS} { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                                            handleInState(stackFrame.getLastLexicalState());
                                            // zero-width token
                                            return ElixirTypes.CALL; }
}

&lt;DOT_OPERATION&gt; {
  {AND_OPERATOR} { yybegin(CALL_MAYBE);
                   return ElixirTypes.AND_OPERATOR; }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Because tokens are tided to highlighting in the JetBrains API, I didn't want to have
								to have separate bracket and parentheses identifier.  It would also be more complicated
								for me because operators and quoted need to be bracket and parentheses identifier, but
								I can't tokenize them that way with JFlex.
							</p>
							<p>
								So, instead of changing the identifier token type, I added a zero-width
								<code>CALL</code> token for when something that could act as an identifer is immediately
								followed by an opening bracket or a parentheses.
							</p>
							<p>
								I needed a token for when there WASN'T a space instead of when there is a space because
								whitepace tokens are stripped when going from the tokenizer to the parser and I'd have
								had to change more rules to have significant white space instead of significant
								non-space.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-operations">
						<h1>Operations</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.3/src/org/elixir_lang/Elixir.bnf#L932-L1493">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 120%; line-height: 100%">
matchedExpression ::= matchedBracketOperation |
                      matchedQualifiedBracketOperation |
                      matchedQualifiedParenthesesCall |
                      matchedQualifiedNoArgumentsCall |
                      matchedUnqualifiedParenthesesCall |
                      matchedUnqualifiedBracketOperation |
                      variable |
                      accessExpression

matchedParenthesesArguments ::= CALL parenthesesArguments parenthesesArguments?

matchedBracketOperation ::= matchedExpression bracketArguments
matchedQualifiedBracketOperation ::= matchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments
matchedQualifiedParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments
matchedQualifiedNoArgumentsCall ::= matchedExpression dotInfixOperator relativeIdentifier !CALL
matchedUnqualifiedParenthesesCall ::= IDENTIFIER matchedParenthesesArguments
matchedUnqualifiedBracketOperation ::= IDENTIFIER CALL bracketArguments
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								With the zero-width <code>CALL</code> token, all the calls that allow parentheses can
								use the matched parentheses arguments (<code>matchedParenthesesArguments</code>) rule,
								which ensures there is no whitespace.
							</p>
							<p>
								matched qualified no arguments call (<code>matchedQualifiedNoArgumentsCall</code>) needs
								to do a negative look-ahead for <code>CALL</code> because it can be a right-operand
								of a further qualifiers or it will quote incorrectly.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="stab">
						<h1>Stab</h1>
						<ul>
							<li>
								<a href="#/stab-usage">
									Usage
								</a>
							</li>
							<li>
								<a href="#/stab-yecc">
									YECC
								</a>
							</li>
							<li>
								<a href="#/stab-merging">
									Merging expressions into clauses
								</a>
							</li>
							<li>
								<a href="#/stab-grammar-kit">
									Grammar Kit
								</a>
							</li>
						</ul>
					</section>
					<section id="stab-usage">
						<h1>Usage</h1>
						<table>
							<thead>
							<tr>
								<th>Code</th>
								<th>Description</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%; width: 11em">
fn x -> x + 1 end
									</code></pre>
								</td>
								<td>Anonymous function clause</td>
							</tr>
							<tr>
								<td style="padding-right: 63px">
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%; width: 20em">
receive do
  {:ping, pid} -> send pid, :pong
after
  10 -> :timeout
end
									</code></pre>
								</td>
								<td>
									Do block clauses
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%">
try do
  raise "oops"
rescue
  e in Runtimeerror -> e
end
									</code></pre>
								</td>
								<td>
									Do block start
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%; width: 5em">
(1 + 2)
									</code></pre>
								</td>
								<td>
									Parenthetical groups
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Stabs are the hyphen greater than symbol used to map anonymous function arguments to
								the function clauses.  They are also used in pattern matching in do blocks, but
								from the parser's perspective, stabs don't actually need the stab operator.  They
								can just contain an expression, such as the first part of a try block or even
								any parenthetical group.  That was weird when I figured that out.
							</p>
						</aside>
					</section>
					<section id="stab-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L205-L276">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 160%; line-height: 100%">
access_expr -> fn_eol stab end_eol : build_fn('$1', build_stab(reverse('$2'))).
access_expr -> open_paren stab close_paren : build_stab(reverse('$2')).

stab -> stab_expr : ['$1'].
stab -> stab eol stab_expr : ['$3'|'$1'].

stab_eol -> stab : '$1'.
stab_eol -> stab eol : '$1'.

stab_expr -> expr : '$1'.
stab_expr -> stab_op_eol stab_maybe_expr : build_op('$1', [], '$2').
stab_expr -> call_args_no_parens_all stab_op_eol stab_maybe_expr :
               build_op('$2', unwrap_when(unwrap_splice('$1')), '$3').
stab_expr -> stab_parens_many stab_op_eol stab_maybe_expr :
               build_op('$2', unwrap_splice('$1'), '$3').
stab_expr -> stab_parens_many when_op expr stab_op_eol stab_maybe_expr :
               build_op('$4', [{'when', meta('$2'), unwrap_splice('$1') ++ ['$3']}], '$5').

stab_maybe_expr -> 'expr' : '$1'.
stab_maybe_expr -> '$empty' : nil.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								To get a plain parenthetical group, like addition in parentheses, you start with
								<code>access_expr</code>, then get an open parenthesis.  Dive into stab, then
								<code>stab_expr</code>.  <code>stab_expr</code> can just be an expression, such
								as adding <code>1 + 2</code>, so you climb back up to the close parenthesis and
								you have <code>1 + 2</code> in parentheses and not actual stab operator.
							</p>
							<p>
								The other part of stabs that I couldn't figure out at first was how any anonymous
								function clause could have more than one line of code in it because expression
								(<code>expr</code>) and an expression list (<code>expr_list</code>), but there is
								a pseudo-expression list because the second rule for stab says a stab is stab followed
								by an E-O-L and a stab_expr, so that can just recursively add more eol expressions
								on the right.
							</p>
							<p>
								But, that still leaves the problem that all the expressions in a row aren't actually
								associated with the pattern or argument names before the stab operator.
							</p>
						</aside>
					</section>
					<section id="stab-merging">
						<h1>Merging expressions into clauses</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L679-L694">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 210%; line-height: 100%">
build_stab([{'->', Meta, [Left, Right]}|T]) ->
  build_stab(Meta, T, Left, [Right], []);

build_stab(Else) ->
  build_block(Else).

build_stab(Old, [{'->', New, [Left, Right]}|T], Marker, Temp, Acc) ->
  H = {'->', Old, [Marker, build_block(reverse(Temp))]},
  build_stab(New, T, Left, [Right], [H|Acc]);

build_stab(Meta, [H|T], Marker, Temp, Acc) ->
  build_stab(Meta, T, Marker, [H|Temp], Acc);

build_stab(Meta, [], Marker, Temp, Acc) ->
  H = {'->', Meta, [Marker, build_block(reverse(Temp))]},
  reverse([H|Acc]).
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, this is where the YECC grammar is a little sneaky: it doesn't actually build up
								the parse tree a function clause at a time, instead the stab operation and plain
								expressions are all siblings and instead the Erlang <code>build_stab</code> function
								called in access expression (<code>access_expr</code>) actually merges all adjacent
								expressions into children of the prior stab operation until the next stab operation is
								hit.
							</p>
						</aside>
					</section>
					<section id="stab-grammar-kit">
						<h1>Grammar Kit</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.4/src/org/elixir_lang/Elixir.bnf#L1648-L1770">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 175%; line-height: 100%">
stabNoParenthesesSignature ::= noParenthesesArguments

stabParenthesesSignature ::= parenthesesArguments (whenInfixOperator expression)?
stabSignature ::= (stabParenthesesSignature |
                   stabNoParenthesesSignature)?

stabInfixOperator ::= EOL* STAB_OPERATOR EOL*

private stabOperationPrefix ::= stabSignature stabInfixOperator
private stabBodyExpression ::= !stabOperationPrefix expression
stabBody ::= stabBodyExpression (endOfExpression+ stabBodyExpression)*

stabOperation ::= stabOperationPrefix stabBody?
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

stab ::= stabOperation (endOfExpression stabOperation)* |
         stabBody

anonymousFunction ::= FN endOfExpression?
                      stab
                      endOfExpression* END

parentheticalStab ::= OPENING_PARENTHESIS EOL*
                      (infixSemicolon? stab infixSemicolon? | infixSemicolon)
                      EOL* CLOSING_PARENTHESIS

accessExpression ::= anonymousFunction |
                     parentheticalStab
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Like, I said, I thought that was a dirty trick to not have the grammar actually represent
								the AST directly, so I made IntellIJ Elixir's stab definition match the clauses directly
								and not do merge in Java.
							</p>
							<p>
								The key to making this work is the negative look-ahead in stab body expression
								(<code>stabBodyExpression</code>), which prevent the start of a new stab clause from
								being included in the body of the previous stab.
							</p>
							<p>
								This look-ahead is more expensive in terms of parse time because the look-ahead includes
								stab signature (<code>stabSignature</code>), which can be any matched expression, which
								can be quite large, but in real world Elixir code, the function clause arguments
								and bodies should be small enough that this backtracking isn't an issue.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="unmatched-expressions">
						<h1>Unmatched Expressions</h1>
						<ul>
							<li>
								<a href="#/unmatched-expressions-unmatched-expr">
									<code>unmatched_expr</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-block-expr">
									<code>block_expr</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-block-list">
									<code>block_list</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-block-identifier">
									<code>block_identifier</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-dangling-else-problem">
									Dangling Else Problem
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-unmatched-expression">
									<code>unmatchedExpression</code>
								</a>
							</li>
						</ul>
					</section>
					<section id="unmatched-expressions-unmatched-expr">
						<h1>
							<code>unmatched_expr</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L89-L154">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 155%; line-height: 100%">
expr -> unmatched_expr : '$1'.

unmatched_expr -> empty_paren op_expr : build_op(element(1, '$2'), nil, element(2, '$2')).
unmatched_expr -> matched_expr op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
unmatched_expr -> unmatched_expr op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
unmatched_expr -> unary_op_eol expr : build_unary_op('$1', '$2').
unmatched_expr -> at_op_eol expr : build_unary_op('$1', '$2').
unmatched_expr -> capture_op_eol expr : build_unary_op('$1', '$2').
unmatched_expr -> block_expr : '$1'.

op_expr -> match_op_eol expr : {'$1', '$2'}.
op_expr -> add_op_eol expr : {'$1', '$2'}.
op_expr -> mult_op_eol expr : {'$1', '$2'}.
op_expr -> hat_op_eol expr : {'$1', '$2'}.
op_expr -> two_op_eol expr : {'$1', '$2'}.
op_expr -> and_op_eol expr : {'$1', '$2'}.
op_expr -> or_op_eol expr : {'$1', '$2'}.
op_expr -> in_op_eol expr : {'$1', '$2'}.
op_expr -> in_match_op_eol expr : {'$1', '$2'}.
op_expr -> type_op_eol expr : {'$1', '$2'}.
op_expr -> when_op_eol expr : {'$1', '$2'}.
op_expr -> pipe_op_eol expr : {'$1', '$2'}.
op_expr -> comp_op_eol expr : {'$1', '$2'}.
op_expr -> rel_op_eol expr : {'$1', '$2'}.
op_expr -> arrow_op_eol expr : {'$1', '$2'}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								unmatched expression (<code>unmatched_expr</code>) gets its name from the fact that the
								two operands in a binary expression don't have to be the same type unlike
								matched expression (<code>matched_expr</code>) where both operands need to be matched
								expressions (<code>matched_expr</code>).
							</p>
							<p>
								The other important characteristic of unmatched expressions
								(<code>unmatched_expr</code>) is they can contain block expressions
								(<code>block_expr</code>).
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-block-expr">
						<h1>
							<code>block_expr</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L135-L246">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
block_expr -> parens_call call_args_parens do_block : build_identifier('$1', '$2' ++ '$3').
block_expr -> parens_call call_args_parens call_args_parens do_block : build_nested_parens('$1', '$2', '$3' ++ '$4').
block_expr -> dot_do_identifier do_block : build_identifier('$1', '$2').
block_expr -> dot_identifier call_args_no_parens_all do_block : build_identifier('$1', '$2' ++ '$3').

do_block -> do_eol 'end' : [[{do,nil}]].
do_block -> do_eol stab end_eol : [[{do, build_stab(reverse('$2'))}]].
do_block -> do_eol block_list 'end' : [[{do, nil}|'$2']].
do_block -> do_eol stab_eol block_list 'end' : [[{do, build_stab(reverse('$2'))}|'$3']].
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Block expressions (<code>block_expr</code>) are what one would expect from the previous
								part of the grammar and Elixir production code: identifiers or function calls with
								<code>do</code> block on the end.
							</p>
							<p>
								The <code>do_block</code> contains stabs, which IntelliJ Elixir could already handle, so
								the only thing new is <code>block_list</code>.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-block-list">
						<h1>
							<code>block_list</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L257-L282">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 190%; line-height: 100%">
block_eol -> block_identifier : '$1'.
block_eol -> block_identifier eol : '$1'.

block_item -> block_eol stab_eol : {?exprs('$1'), build_stab(reverse('$2'))}.
block_item -> block_eol : {?exprs('$1'), nil}.

block_list -> block_item : ['$1'].
block_list -> block_item block_list : ['$1'|'$2'].
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, a <code>block_list</code> is a list of <code>block_items</code>, which are
								block EOLs (<code>block_eol</code>), which are <code>block_identifier</code> and
								that can be followed by an optional stab.
							</p>
							<p>
								So, what's a <code>block_identifier</code>?
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-block-identifier">
						<h1>
							<code>block_identifier</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_tokenizer.erl#L814-L961">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 160%; line-height: 100%">
tokenize_kw_or_other(Rest, Kind, Line, Atom, Tokens) ->
  case check_keyword(Line, Atom, Tokens) of
    nomatch ->
      {identifier, Rest, check_call_identifier(Kind, Line, Atom, Rest)};
    {ok, [Check|T]} ->
      {keyword, Rest, Check, T};
    {error, Token} ->
      {error, {Line, "syntax error before: ", Token}, atom_to_list(Atom) ++ Rest, Tokens}
  end.

check_keyword(Line, Atom, Tokens) ->
  case keyword(Atom) of
    false    -> nomatch;
    token    -> {ok, [{Atom, Line}|Tokens]};
    block    -> {ok, [{block_identifier, Line, Atom}|Tokens]};
    unary_op -> {ok, [{unary_op, Line, Atom}|Tokens]};
    Kind     -> {ok, add_token_with_nl({Kind, Line, Atom}, Tokens)}
  end.

keyword('after')  -> block;
keyword('else')   -> block;
keyword('rescue') -> block;
keyword('catch')  -> block;
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, the block identifiers are <code>after</code>, <code>else</code>,
								<code>rescue</code>, and <code>catch</code>.  This means that those words are real
								keywords in Elixir.  Due to the power of the macro system, <code>if</code> and
								<code>unless</code> are just identifiers, but the <code>else</code> in either is a
								keyword.
							</p>
							<p>
								Using Elixir, we can't define new keywords, we can just rearrange the pre-existing ones.
								If we want other pseudo-keywords we're left with using keyword list keys.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-dangling-else-problem">
						<h1>Dangling Else Problem</h1>
						<table>
							<thead>
							<tr>
								<th></th>
								<th></th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Ambiguous code</th>
								<td>if a then if b then s else s2</td>
								<td>a b, c do s end</td>
							</tr>
							<tr>
								<th>Bind to Outermost</th>
								<td>if a then (if b then s) else s2</td>
								<td>a b, (c) do s end</td>
							</tr>
							<tr>
								<th>Bind to Closest</th>
								<td>if a then (if b then s else s2)</td>
								<td>a b, (c do s end)</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The dangling else problem is a problem with languages like C or Java that have an option
								else when nesting.
							</p>
							<p>
								The problem can be resolved by either saying the else binds to the outer most if or
								the closest if.
							</p>
							<p>
								This problem is also possible with do blocks in Elixir when resolving when function call
								a do block binds to.
							</p>
							<p>
								In actual Elixir grammar, the do block always binds to the outer-most function call,
								which turns out to be the easy choice for LALR parsers like yecc: it just works.  But,
								for LL parsers like Grammar Kit, all the text books on compiler design advise to pick
								binding to the closest because it's just not possible in simple LL(1) parsers to
								even do bind to outermost.  Thankfully, Grammar Kit is not a simple LL(1) parser, so
								I was able to find a solution.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-unmatched-expression">
						<h1>
							<code>unmatchedExpression</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.5/src/org/elixir_lang/Elixir.bnf#L100-L2274">
									<code>src/org/elixir_lang/Elixir/bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 110%; line-height: 100%">
private expression ::= emptyParentheses |
                       unmatchedExpression |
                       unqualifiedNoParenthesesManyArgumentsCall

unmatchedExpression ::= unmatchedCaptureNonNumericOperation |
                        // ...
                        unmatchedQualifiedNoParenthesesCall |
                        // ...
                        unmatchedAccessExpression

unmatchedQualifiedNoParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument doBlock?

noParenthesesOneArgument ::= // ...
                             !(DUAL_OPERATOR SIGNIFICANT_WHITE_SPACE) matchedExpression
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								When adding unmatched expressions (<code>unmatchedExpression</code>) to Elixir dot bnf
								(<code>Elixir.bnf</code>), I ended up eliminating matched expressions
								(<code>matchedExpression</code>) from the list of valid expressions
								(<code>expression</code>)
							</p>
							<p>
								This is because the important distinction between <code>matchedExpression</code> is that
								<code>unmatchedExpressions</code> can optionally have a block, but any unparenthesised
								function call inside an unmatchedExpression function call must be a matchedExpression
								because blocks always bind to the left-most function call.
							</p>
							<p>
								Both matched expressions and unmatched expressions use no parentheses one argument, but
								crucially in unmatched expressions, it switches the grammar from looking for unmatched
								expressions and do blocks to disallowing do blocks.
							</p>
							<p>
								So, while in the yecc grammar, a block expression is matched expression followed by
								do block, in the grammar kit grammar, a matched expression is an unmatched expression
								that can't have a block.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="parsing-elixir-lang-elixir">
						<h1>Parsing <code>elixir-lang/elixir</code></h1>
						<ul>
							<li>
								<a href="#/parsing-elixir-lang-elixir-function-captures">
									Function Captures
								</a>
							</li>
							<li>
								<a href="#/parsing-elixir-lang-elixir-reference-operation">
									<code>REFERENCE_OPERATION</code>
								</a>
							</li>
							<li>
								<a href="#/parsing-elixir-lang-elixir-operator-kw">
									<code>operator_kw</code>
								</a>
							</li>
							<li>
								<a href="#/parsing-elixir-lang-elixir-piping-blocks">
									Piping blocks
								</a>
							</li>
							<li>
								<a href="#/parsing-elixir-lang-elixir-unmatched-associativity">
									Unmatched Associativity
								</a>
							</li>
							<li>
								<a href="#/parsing-elixir-lang-elixir-v1.0.0">
									v1.0.0
								</a>
							</li>
						</ul>
						<aside class="notes">
							<p>
								Before releasing version one dot zero dot zero, I wanted to make sure I hadn't missed
								some syntax that was valid, but that I hadn't thought of when manually writing snippets
								of Elixir as test cases.  I couldn't use something like quick check to generate fake
								Elixir problems because if I messed up the Grammar Kit grammar I'd like mess up the
								quick check model in the same way, so instead I decided to test the IntelliJ Elixir by
								having it parse all the dot E-X files in the elixir lang elixir
								(<code>elixir-lang/elixir</code>) standard libraries.
							</p>
							<p>
								This did find bugs in my grammar, but it also found bugs in the native tokenizer and
								parser!
							</p>
						</aside>
					</section>
					<section id="parsing-elixir-lang-elixir-function-captures">
						<h1>Function Captures</h1>
						<table>
							<thead>
							<tr>
								<th>Code</th>
								<th>Quoted</th>
							</tr>
							</thead>
							<tbody style="font-size: 65%">
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 11em">
&Module.function/2
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 34em">
{
 :&,
 [line: 1],
 [
  {
   :/,
   [line: 1],
   [
    {
     {
      :.,
      [line: 1],
      [
       {:__aliases__, [counter: 0, line: 1], [:Module]},
       :function
      ]
     },
     [line: 1],
     []
    },
    2
   ]
  }
 ]
}
									</code></pre>
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 7em">
&function/2
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 19em">
{
 :&,
 [line: 1],
 [
  {
   :/,
   [line: 1],
   [
    {:function, [line: 1], nil},
    2
   ]
  }
 ]
}
									</code></pre>
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 3em">
&||/2
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 19em">
{
 :&,
 [line: 1],
 [
  {
   :/,
   [line: 1],
   [
    {:||, [line: 1], nil},
    2
   ]
  }
 ]
}
									</code></pre>
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 3em">
&or/2
									</code></pre>
								</td>
								<td>
									Error
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The function capture syntax has multiple variants: a remote function, a local function,
								a local symbolic operator, and a local non-symbolic operator.
							</p>
							<p>
								It turned out that the standard library never contained any local function references to
								the English word operators like <code>and</code> or <code>or</code>.  I only taught the
								error because I already had tests setup to test all variant of an operator of the same
								precedence, so double and triple pipe were tested the same as the word <code>or</code>.
							</p>
						</aside>
					</section>
					<section id="parsing-elixir-lang-elixir-reference-operation">
						<h1>
							<code>REFERENCE_OPERATION</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.flex#L160-L583">
									<code>src/org/elixir_lang/Elixir.flex</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim>
TWO_TOKEN_OR_OPERATOR = "or" |
                        "||"

TWO_TOKEN_OPERATOR = {TWO_TOKEN_AND_OPERATOR} |
                     {TWO_TOKEN_ARROW_OPERATOR} |
                     {TWO_TOKEN_ASSOCIATION_OPERATOR} |
                     {TWO_TOKEN_COMPARISON_OPERATOR} |
                     {TWO_TOKEN_IN_MATCH_OPERATOR} |
                     {TWO_TOKEN_OR_OPERATOR} |
                     {TWO_TOKEN_RELATIONAL_OPERATOR} |
                     {TWO_TOKEN_STAB_OPERATOR} |
                     {TWO_TOKEN_TUPLE_OPERATOR} |
                     {TWO_TOKEN_TWO_OPERATOR} |
                     {TWO_TOKEN_TYPE_OPERATOR}

REFERENCABLE_OPERATOR = {FOUR_TOKEN_OPERATOR} |
                        {THREE_TOKEN_OPERATOR} |
                        {TWO_TOKEN_OPERATOR} |
                        {ONE_TOKEN_REFERENCABLE_OPERATOR}

REFERENCE_OPERATOR = "/"
REFERENCE_INFIX_OPERATOR = ({WHITE_SPACE}|{EOL})*{REFERENCE_OPERATOR}

&lt;YYINITIAL, INTERPOLATION&gt; {
 {REFERENCABLE_OPERATOR} / {REFERENCE_INFIX_OPERATOR} { pushAndBegin(REFERENCE_OPERATION);
                                                         return ElixirTypes.IDENTIFIER; }
}

&lt;REFERENCE_OPERATION&gt; {
  {ESCAPED_EOL}|{WHITE_SPACE}+ { return TokenType.WHITE_SPACE; }
  {EOL}                        { return ElixirTypes.EOL; }
  {REFERENCE_OPERATOR}         { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                                 yybegin(stackFrame.getLastLexicalState());
                                 return ElixirTypes.MULTIPLICATION_OPERATOR; }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								While reference syntax does end up quoting as just like division, I did need to have
								special handling in the lexer for operator references because I had to lex them as
								<code>IDENTIFIER</code> tokens because I couldn't figure out how to have the parser
								distinguish incorrectly used operators otherwise.
							</p>
							<p>
								Because I can use regular expressions in JFlex, I can just have a regular expression of
								operators, including both symbolic and non-symbolic operators.
							</p>
						</aside>
					</section>
					<section id="parsing-elixir-lang-elixir-operator-kw">
						<h1>
							Issue <a href="https://github.com/elixir-lang/elixir/issues/3486">#3486</a>
							<a href="https://github.com/elixir-lang/elixir/pull/3571">fixed</a> in v1.1.0
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/jisaacstone/elixir/blob/add22f4b5b793a123cc2efd294844ef715469d04/lib/elixir/src/elixir_tokenizer.erl#L90-L984">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 150%; line-height: 100%">
-define(operator_kw(A),
  A == 'and';
  A == 'or';
  A == 'when';
  A == 'not';
  A == 'in').

check_keyword(_Line, _Column, _Length, Atom, [{capture_op, _, _}|_]) when ?operator_kw(Atom) ->
  nomatch;
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The bug was fixed by John Isaac Stone in the Elixir tokenizer by adding a clause that
								peeks at the top of the already tokenized operators and treats keyword operators as
								normal identifiers if a capture operation just happened instead of looking ahead to
								see if there is a forward slash the way I did it.
							</p>
						</aside>
					</section>
					<section id="parsing-elixir-lang-elixir-piping-blocks">
						<h1>Piping blocks</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/e02d7bf913f3e5ea8c9e49648e69324ec5c65919/lib/mix/lib/mix/tasks/deps.clean.ex#L55-L61">
									<code>lib/mix/lib/mix/tasks/deps.clean.ex</code>
								</a>
								<pre><code class="elixir stretch" data-trim>
defmodule Mix.Tasks.Deps.Clean do
  defp checked_deps(build, deps) do
    for root <- [deps, build],
        path <- Path.wildcard(Path.join(root, "*")),
        File.dir?(path) do
      Path.basename(path)
    end
    |> Enum.uniq()
    |> List.delete(to_string(Mix.Project.config[:app]))
  end
end
								</code></pre>
							</figcaption>
						</figure>
						<aside class="notes">
							<p>
								Surprisingly, there was only one place in elixir-lang/elixir where a pipeline starts
								with function with a do block: in the deps dot clean Mix taks.
							</p>
						</aside>
					</section>
					<section id="parsing-elixir-lang-elixir-unmatched-associativity">
						<h1>
							<a href="https://groups.google.com/forum/#!topic/elixir-lang-core/W0sjGdeSva0">Issue</a>
							<a href="https://github.com/elixir-lang/elixir/commit/3e52ed0fbbc09a156e6ea180baff3b89a8da183e">Fixed</a>
							in v1.1.0
						</h1>
						<table>
							<thead>
							<tr>
								<th></th>
								<th>Matched</th>
								<th>Unmatched</th>
							</tr>
							</thead>
							<tbody style="font-size: 200%; line-height: 100%">
							<tr>
								<th>Code</th>
								<td>
									<pre><code class="elixir stretch" data-trim>
one
|> two
|> three
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim>
one do end
|> two
|>
									</code></pre>
								</td>
							</tr>
							<tr>
								<th>Quoted</th>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :|>,
 [line: 3],
 [
  {
   :|>,
   [line: 2],
   [
    {:one, [line: 1], nil},
    {:two, [line: 2], nil}
   ]
  },
  {:three, [line: 3], nil}
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 20em">
{
 :|>,
 [line: 2],
 [
  {:one, [line: 1], [[do: nil]]},
   {
    :|>,
    [line: 3],
    [
     {:two, [line: 2], nil},
     {:three, [line: 3], nil}
   ]
  }
 ]
}
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The arrow operators, including the pipeline operator, are left-associative, but
								when the operand in the pipeline is an umatched expression, then the quoted
								form made it look effectively right-associative.
							</p>
							<p>
								I thought I had missed some post-processing in the Erlang code, but JosÃ© Valim confirmed
								it was a bug in the native parser due to in his word, "`bar pipe baz` ends up being
								reduced first as the current grammar rules forced so to happen".
							</p>
							<p>
								So, because I used a different class of parser that doesn't do reduce and shift operations,
								I was able to stumble upon this bug.  Having more test cases, because I didn't trust
								my own understanding of the original grammar and how to translate it to Grammar Kit
								also let me find the other bugs, so an alternative implementation is a good way to
								ensure a tokenizer and parser for a langauge has covered all the edge cases.
							</p>
						</aside>
					</section>
					<section id="parsing-elixir-lang-elixir-v1.0.0">
						<h1>v1.0.0</h1>
						<table>
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th colspan="2">Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
								<th>Name</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2015&#8209;07&#8209;27</td>
								<td>19</td>
								<td>365</td>
								<td>158</td>
								<td>1356</td>
								<td>2.44</td>
								<td>1.0.0</td>
							</tr>
							</tbody>
						</table>
						<ul style="font-size: 75%">
							<li>
								<p>Enhancements</p>
								<ul>
									<li>Update ant build on travis-ci.org to use IDEA 14.1.4 (from 14.0.2)</li>
									<li>Parser is verified to quote the same as native Elixir</li>
								</ul>
							</li>
							<li>
								<p>Bug Fixes</p>
								<ul>
									<li>Fix parsing of unary vs binary +/- with leading and trailing spaces and newlines</li>
									<li>Allow EOL between list arguments and <code>]</code></li>
									<li>
										Relative identifiers after <code>.</code> that start with <code>and</code>, <code>or</code>, and
										<code>not</code> will be lexed as a single identifier instead of <code>and</code>, <code>or</code>, or
										<code>not</code> followed by another identifier.
									</li>
									<li><code>end</code> is allowed as a relative identifier after <code>.</code></li>
									<li>Fix <code>(...)</code> as part of matched expression in no parentheses stab signature</li>
									<li>Allow multiple newlines to mark the end of an expression, but only one <code>;</code></li>
									<li>
										Allow operators in function references (<code>&lt;op&gt;/&lt;arity&gt;</code>) for function captures
										(<code>&amp;&lt;op&gt;/&lt;arity&gt;</code>)
									</li>
									<li><code>unquote_splicing</code> is properly wrapped in <code>__block__</code> when in stab bodies</li>
									<li>Check for matching terminator in heredocs when determining white space type at beginning of line</li>
									<li>Allow &lt;space&gt;+&lt;EOL&gt; to count as addition</li>
									<li>Unary expressions inside parentheses are no longer marked <code>ambiguous_op: nil</code></li>
									<li>
										Differentiate between <code>Qualifier.'relative'()</code> vs <code>Qualifier.'relative' ()</code> and
										<code>Qualifier."relative"()</code> vs <code>Qualifier."relative" ()</code>
									</li>
									<li>Fix link to Elixir website in README</li>
									<li>All tokens have human-readable names and/or expected characters for better error messages</li>
								</ul>
								<p>Incompatible Changes</p>
								<ul>
									<li>
										New Elixir File has moved to the last item in the New File menu to preserve <code>CTRL+N ENTER</code>
										keyboard shortcut for <code>New &gt; File</code>
									</li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							<p>
								One year, one thousand three hundred fifty six commits, 3 bugs in native Elixir and the
								parser was complete.  The plugin had reached my goal for version one dot zero dot zero.
							</p>
						</aside>
					</section>
				</section>
				<section id="bibliography">
                    <h1>Bibliography</h1>
					<ul>
						<li>
							<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">
								Backus-Naur Form
							</a>
						</li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">
                                Nondeterministic Finite Automaton
                            </a>
                        </li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Powerset_construction">
                                Powerset Construction
                            </a>
                        </li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">
                                Deterministic Finite Automaton
                            </a>
                        </li>
						<li>
							Automata, Computability, and Complexity: Theory and Applications by Elaine Rich
						</li>
						<li>
							<a href="https://en.wikipedia.org/wiki/Recursive_language">
								Decidable Language
							</a>
						</li>
						<li>
							<a href="http://javascript.crockford.com/tdop/tdop.html">
								Douglas Crockford's Top Down Operator Precedence
							</a>
						</li>
					</ul>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				center: true,
				controls: true,
				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				],
				height: 1280,
				history: true,
				progress: true,
				// Slide number formatting can be configured using these variables:
				//  h: current slide's horizontal index
				//  v: current slide's vertical index
				//  c: current slide index (flattened)
				//  t: total number of slides (flattened)
				slideNumber: 'c / t',
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				width: 2048
			});

		</script>

	</body>
</html>
