<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>ElixirConf 2015 - The Road to IntelliJ Elixir 1.0.0</title>

		<meta name="description" content="How I went from &quot;I wonder if there's an Rubymine plugin for Elixir?&quot; to writing one myself and eventually using it to find bugs in native Elixir.">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="stack">
					<section>
						<h1>ElixirConf 2015</h1>
						<h2>The Road to IntelliJ Elixir 1.0.0</h2>
						<p>2015-10-02 to 2015-10-03</p>
						<p>Luke Imhoff</p>
						<table>
							<tbody>
							<tr>
								<th>
									<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                                     version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px"
                                     viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                     <g>
                                        <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                        <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                        <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                        <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                     </g>
                                </svg>
								</th>
								<td>Kronic.Deth@gmail.com</td>
							</tr>
							<tr>
								<th>
									<svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg"
                                     xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16"
                                     enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                               </svg>
								</th>
								<td>
									<a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
								</td>
							</tr>
							<tr>
								<th>
									<svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
								</th>
								<td>
									<a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								I am the maintainer of intellij-elixir, the Elixir plugin for Jetbrains IDEs.  I have
								contributed to the Elixir standard library and found bugs in the native tokenizer and parser
								through my work on intellij-elixir.  I help run the Austin Elixir meetup.
							</p>
						</aside>
					</section>
					<section>
						<h1>This Presentation</h1>
						<dl>
							<dt>Slides</dt>
							<dd>
								<dl>
									<dt>Viewable</dt>
									<dd>
										<a href="https://kronicdeth.github.io/the-road-to-intellij-elixir-1.0.0">
											https://kronicdeth.github.io/the-road-to-intellij-elixir-1.0.0
										</a>
									</dd>
									<dt>Source</dt>
									<dd>
										<a href="https://github.com/KronicDeth/the-road-to-intellij-elixir-1.0.0/tree/gh-pages">
											https://github.com/KronicDeth/the-road-to-intellij-elixir-1.0.0/tree/gh-pages
										</a>
									</dd>
								</dl>
							</dd>
							<dt>Project Source</dt>
							<dd>
								<a href="https://github.com/KronicDeth/intellij-elixir/tree/v1.0.0">
									https://github.com/KronicDeth/intellij-elixir/tree/v1.0.0
								</a>
							</dd>
						</dl>
						<aside class="notes">
							<p>
								For viewers that want to follow along with their own copy of the slides or project
								source, they can be accessed at the shown addresses.
							</p>
						</aside>
					</section>
					<section>
						<h1>Outline</h1>
						<ul>
							<li>
								<a href="#/introduction">Introduction</a>
							</li>
							<li>
								<a href="#/bnf">BNF</a>
							</li>
							<li>
								<a href="#/syntax">Syntax</a>
							</li>
						</ul>
					</section>
				</section>
				<section class="stack">
					<section id="introduction">
						<h1>Introduction</h1>
						<ul>
							<li>
								<a href="#/introduction-why-an-intellij-plugin">
									Why an IntelliJ Plugin?
								</a>
							</li>
							<li>
								<a href="#/introduction-timeline">
									Timeline
								</a>
							</li>
						</ul>
					</section>
					<section id="introduction-why-an-intellij-plugin">
						<h1>Why an IntelliJ Plugin?</h1>
						<ul>
							<li>I use Rubymine for Ruby development</li>
							<li>Wanted vim key bindings</li>
							<li>Wanted Cmd+Click Go To Definition for Elixir</li>
							<li>Wanted Search Everywhere for Elixir</li>
							<li>There was a tutorial</li>
						</ul>
						<aside class="notes">
							<p>
								People may wonder why I took it upon myself to make an IDE plugin for Elixir, when I
								could have used a vim or emacs plugin.
							</p>
							<p>
								I've used both emacs and vim.  I started with emacs when I worked at Cray, only
								switching to vim when I needed something that worked over a high-latency, low-bandwidth
								CDMA modem on the high-way.
							</p>
							<p>
								I started using Rubymine when my boss at a previous job, Nicholas Cancelliere,
								introduced me to it.  I was shocked that an IDE for a dynamic language like Ruby could
								support Find Usage, Go To Definition, and Refactor.  I had been use to using ctags for
								vim.
							</p>
							<p>
								I haven't complete abandoned using vim either.  I still use syntax highlighting plugins
								for vim in iTerm when I need to edit configuration files and I use the IDEAVim plugin
								for Jetbrains IDEs like Rubymine, Webstorm, and IntelliJ.
							</p>
							<p>
								Without Rubymine I don't think I'd have been able to as quickly dive through the complex
								code-base in Metasploit and the graphical debugger allowed me to teach myself the
								internals of Rails and other DSLs.
							</p>
							<p>
								I understood that many of the features I liked about Rubymine were shared across
								JetBrains' various IDEs, so if I could write the parts of a plugin to get JetBrains APIs
								to understand Elixir syntax and semantics, the features I really wanted would just work
								without me having to understand how to write the parts that were cross-language.
							</p>
							<p>
								However, just getting syntax lexing and parsing right ended up taking a year...
							</p>
						</aside>
					</section>
					<section id="introduction-timeline">
						<h1>Timeline</h1>
						<table style="font-size: 85%">
							<thead>
							<tr>
								<th>Date</th>
								<th>Delta Days</th>
								<th>Total Days</th>
								<th>Version</th>
								<th>Features</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2014-07-27</td>
								<td>0</td>
								<td>0</td>
								<td>Initial</td>
								<td>Project Skeleton</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;02</td>
								<td>6</td>
								<td>6</td>
								<td>0.0.1</td>
								<td>Full BNF translated, Freezing IDE</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;03</td>
								<td>1</td>
								<td>7</td>
								<td>0.0.2</td>
								<td>Non&#8209;Decimal Numbers</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;08</td>
								<td>5</td>
								<td>12</td>
								<td>0.0.3</td>
								<td>CharList, String, Interpolation</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;13</td>
								<td>36</td>
								<td>48</td>
								<td>0.1.0</td>
								<td>Sigils</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;20</td>
								<td>7</td>
								<td>55</td>
								<td>0.1.1</td>
								<td>JDK 6 compatibility</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;25</td>
								<td>5</td>
								<td>60</td>
								<td>0.1.2</td>
								<td>Atoms</td>
							</tr>
							<tr>
								<td>2014&#8209;10&#8209;14</td>
								<td>19</td>
								<td>79</td>
								<td>0.1.3</td>
								<td>Blank lines and EOL bugfixes</td>
							</tr>
							<tr>
								<td>2014&#8209;11&#8209;30</td>
								<td>47</td>
								<td>126</td>
								<td>0.2.0</td>
								<td>Escape sequences, Module creation, Character Tokens, decimal numbers, identifiers, Aliases, keyword lists, matched expressions, invalid digits in numbers</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;03</td>
								<td>124</td>
								<td>250</td>
								<td>0.2.1</td>
								<td>No parentheses function calls</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;10</td>
								<td>7</td>
								<td>257</td>
								<td>0.3.0</td>
								<td>New Elixir File to directories</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;27</td>
								<td>17</td>
								<td>274</td>
								<td>0.3.1</td>
								<td>Project From Existing Sources, anonymous function calls</td>
							</tr>
							<tr>
								<td>2015&#8209;05&#8209;01</td>
								<td>4</td>
								<td>278</td>
								<td>0.3.2</td>
								<td>Fix SDK logical on unsupported systems</td>
							</tr>
							<tr>
								<td>2015&#8209;05&#8209;15</td>
								<td>14</td>
								<td>292</td>
								<td>0.3.3</td>
								<td>Remote function calls</td>
							</tr>
							<tr>
								<td>2015&#8209;06&#8209;04</td>
								<td>20</td>
								<td>312</td>
								<td>0.3.4</td>
								<td>Brackets, Parentheses, anonymous functions, maps, tuples, bit strings</td>
							</tr>
							<tr>
								<td>2015&#8209;07&#8209;08</td>
								<td>34</td>
								<td>346</td>
								<td>0.3.5</td>
								<td>Unmatched expressions</td>
							</tr>
							<tr>
								<td>2015&#8209;07&#8209;27</td>
								<td>19</td>
								<td>365</td>
								<td>1.0.0</td>
								<td>Parser verified to match native Elixir</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								I was exactly 1 year between the initial commit of the project skeleton to the v1.0.0 tag.
							</p>

						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="bnf">
						<h1>BNF</h1>
						<ul>
							<li>
								<a href="#/bnf-backus-naur-form">Backus Naur Form</a>
							</li>
							<li>
								<a href="#/bnf-yecc">YECC</a>
							</li>
							<li>
								<a href="#/bnf-grammar-kit">Grammar Kit</a>
							</li>
							<li>
								<a href="#/bnf-v0.0.1">v0.0.1</a>
							</li>
						</ul>
					</section>
					<section id="bnf-backus-naur-form">
						<h1>Backus-Naur Form</h1>
						<table>
							<thead>
							<tr>
								<th>Read as</th>
								<th>Symbol</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Metasyntactic Variable</td>
								<td>
									<pre><code class="bnf">&lt;variable&gt;</code></pre>
								</td>
							</tr>
							<tr>
								<td>is defined as</td>
								<td>
									<pre><code class="bnf">::=</code></pre>
								</td>
							</tr>
							<tr>
								<td>or</td>
								<td>
									<pre><code class="bnf">|</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<pre><code data-trim>
&lt;expr&gt; ::= &lt;integer&gt; | &lt;expr&gt; &lt;op&gt; &lt;integer&gt;
						</code></pre>
						<aside class="notes">
							<p>
								One of the standard ways of defining a syntax is in BNF, or Backus-Naur Form, which
								was first used for the Algol 60 standard.
							</p>
							<p>
								Both YECC and GrammarKit use a form of BNF, so I assumed it was just a matter of
								porting elixir dot Y-R-L to elixir dot B-N-F.
							</p>
						</aside>
					</section>
					<section id="bnf-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/12f89a30b46279398fc7143e433681c2194b03d9/lib/elixir/src/elixir_parser.yrl#L77-L82">
									lib/elixir/src/elixir_parser.yrl
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 300%; line-height: 100%">
grammar -> eoe : nil.
grammar -> expr_list : to_block('$1').
grammar -> eoe expr_list : to_block('$2').
grammar -> expr_list eoe : to_block('$1').
grammar -> eoe expr_list eoe : to_block('$2').
grammar -> '$empty' : nil.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								YECC is a parser generator written in Erlang (and part of the standard distribution)
								that is based on yacc (with an 'a' instead of an 'e'), which is a parser generator
								written in C.
							</p>
							<p>
								The YECC syntax differs from B-N-F in that it uses a skinny arrow (<code>-></code>)
								instead of colon colon equals (<code>::=</code>) and instead of using pipe
								(<code>|</code>) for OR, lines with the same rule name are repeated with alternative
								definitions. Finally, YECC supports running Erlang code on the tokens using dollar
								number (<code>$n</code>) for positional references to the matches tokens.
							</p>
							<p>
								dollar empty (<code>$empty</code>) is a special token that matches no input.  In
								formal grammars this is usually referred to as (lowercase) epsilon (<code>ɛ</code>).
							</p>
						</aside>
					</section>
					<section id="bnf-grammar-kit">
						<h1>Grammar Kit</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf">
									src/org/elixir_lang/Elixir.bnf
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 165%; line-height: 100%">
private elixirFile ::= endOfExpression? (expressionList endOfExpression?)?
private expressionList ::= expression (endOfExpression expression | adjacentExpression)*
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Grammar Kit is a parser generator written in Java and created by JetBrains.
							</p>
							<p>
								GrammarKit's B-N-F format <strong>does</strong> use colon colon equals (<code>::=</code>)
								like Backus-Naur Form, but it has some more power constructs above pipe (<code>|</code>)
								for OR.
							</p>
							<p>
								Question mark (<code>?</code>) can be used for 0 or 1, parentheses (<code>()</code>)
								can be used for grouping; and star can be used for 0 or more.  Empty can be implied
								by question mark (<code>?</code>) or star (<code>*</code>) matching nothing or there
								being nothing on the right-hand-side of the colon colon equals (<code>::=</code>).
							</p>
							<p>
								You'll also notice that there is no inline Java code after the rule definition unlike
								in YECC where there as Erlang code.  This is because GrammarKit automatically generates
								an AST, which it calls a PSI (or Program Structure Interface) Tree from the matched
								rules, so there's no need to define how to build the tree.
							</p>
							<p>
								Having GrammarKit generate the AST is both good and bad.  It's good because it removes
								a lot of redundant code, but it's bad because rules must evaluate in the correct order
								to reflect the desired nesting and associativity without any manual fixups, which are
								possible with the Erlang code in YECC.
							</p>
						</aside>
					</section>
					<section id="bnf-v0.0.1">
						<h1>v0.0.1</h1>
						<ol>
							<li>Translate from YECC to Grammar Kit</li>
							<li>Freeze IDE</li>
						</ol>
						<aside class="notes">
							<p>
								YECC and Grammar Kit both support a form of BNF and Grammar Kit seems like it would
								support even a more compact grammar because question mark (<code>?</code>), star
								(<code>star</code>), pipe (<code>|</code>) and parentheses (<code>()</code>) could
								eliminate some of the redundancy needed in the multi-clause rules in YECC.
							</p>
							<p>
								After only 6 days I had quote unquote translated the BNF from yecc to Grammar Kit and
								ended up with a parser that froze the IDE, which Julius "h4cc" Beckmann reported. That
								left the slow process of translating the grammar correctly over the next 359 days.  At
								the time of the freeze, I didn't even really understand translating the BNF didn't work,
								all I knew was I needed to go slower and build the grammar up from simpler, testable
								pieces.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="syntax">
						<h1>Syntax</h1>
						<ul>
							<li>
								<a href="#/syntax-analysis">Syntactic Analysis</a>
							</li>
							<li>
								<a href="#/syntax-lexing">Lexing/Tokenizing</a>
							</li>
                            <li>
                                <a href="#/syntax-ignored">Ignoring Characters</a>
                            </li>
                            <li>
                                <a href="#/syntax-base-integers">Base Integers</a>
                            </li>
							<li>
								<a href="#/syntax-jflex-lexer-generation">JFlex Lexer Generation</a>
							</li>
                            <li>
                                <a href="#/syntax-finite-automaton">Finite Automaton</a>
                            </li>
                            <li>
                                <a href="#/syntax-jflex-generated-lexer-packing">JFlex Generated Lexer - Packaing</a>
                            </li>
                            <li>
                                <a href="#/syntax-jflex-generated-lexer-switch">JFlex Generated Lexer - Switch</a>
                            </li>
							<li>
								<a href="#/syntax-v0.0.2">v0.0.2</a>
							</li>
						</ul>
					</section>
					<section id="syntax-analysis">
						<h1>Syntactic Analysis</h1>
						<table>
							<thead>
							<tr>
								<th>Step</th>
								<th>Elixir</th>
								<th>IntelliJ Elixir</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Lexing</th>
								<td>
									Erlang
								</td>
								<td>
									JFlex
								</td>
							</tr>
							<tr>
								<th>Parsing</th>
								<td>
									YECC
								</td>
								<td>
									GrammarKit
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								So, I went back and actually started to do the JetBrains tutorial step by step instead
								of jumping ahead and searched Wikipedia, trying to find CompSci articles that explained
								the correct way to do this.
							</p>
							<p>
								In order to support color syntax highlighting and mark syntax errors with the nice
								red squiggly under line, IntelliJ Elixir needed to be able to analyze Elixir syntax.
							</p>
							<p>
								Syntactic analysis is usually broken down into two parts: the first breaks the raw text
								into tokens and the second checks if those tokens are arranged in the correct order.
							</p>
							<p>
								In most programming languages, both lexers and parsers are built using generators that
								have an external DSL.  In Elixir, the lexer is built using Erlang directly because
								Erlang pattern matching is compact enough that a generator is unnecessary.
								Additionally, Elixir syntax contains some features that normal lexer generator aren't
								expecting.
							</p>
							<p>
								For IntelliJ Elixir, I used JFlex because it was the lexer generator recommended by
								JetBrain's plugin tutorial.
							</p>
							<p>
								For parsing Elixir does use a generator, called yecc, which generates Erlang code.
							</p>
							<p>
								For IntelliJ Elixir, I used JetBrains' GrammarKit.
							</p>
							<p>
								When I first started IntelliJ Elixir I didn't understand the important difference
								between these two stacks, but I hope to explain what I learned along the way to you.
							</p>
						</aside>
					</section>
					<section id="syntax-lexing">
						<h1>Lexing/Tokenizing</h1>
						<ol>
							<li>Match Input</li>
							<li>Emit Token</li>
						</ol>
						<aside class="notes">
							<p>
								The first step of syntactic analysis is lexing, also known as tokenizing.  Lexing
								breaks up the raw text into tokens, such as keywords, literals, operators, and
								identifiers.
							</p>
							<p>
								Input is matched using some pattern.  In native Elixir, this is pattern matching on
								Erlang string prefixes.  In IntelliJ Elixir's JFlex file, it's regular expressions.
							</p>
						</aside>
					</section>
					<section id="syntax-ignored">
						<h1>Ignoring Characters</h1>
						<table class="stretch">
							<thead>
							<tr>
								<th>Token</th>
								<th>Erlang</th>
								<th>JFlex</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Comments</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L133-L137">
										<pre><code class="erlang" data-trim style="font-size: 85%; line-height: 100%">
tokenize([$#|String], Line, Scope, Tokens) ->
  Rest = tokenize_comment(String),
  tokenize(Rest, Line, Scope, Tokens);

tokenize_comment("\r\n" ++ _ = Rest) -> Rest;
tokenize_comment("\n" ++ _ = Rest)   -> Rest;
tokenize_comment([_|Rest])           -> tokenize_comment(Rest);
tokenize_comment([])                 -> [].
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L21-L63">
										<pre><code data-trim>
COMMENT = "#" [^\r\n]* {EOL}?

&lt;YYINITIAL&gt; {
  {COMMENT} { yybegin(BODY); return ElixirTypes.COMMENT; }
}
&lt;BODY&gt; {
  {COMMENT} { return ElixirTypes.COMMENT; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							<tr>
								<td>EOL</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L320-L324">
										<pre><code class="erlang" data-trim>
tokenize("\n" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line + 1, Scope, eol(Line, newline, Tokens));

tokenize("\r\n" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line + 1, Scope, eol(Line, newline, Tokens));

eol(_Line, _Mod, [{',',_}|_] = Tokens)   -> Tokens;
eol(_Line, _Mod, [{eol,_,_}|_] = Tokens) -> Tokens;
eol(Line, Mod, Tokens) -> [{eol,Line,Mod}|Tokens].
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L18-L59">
										<pre><code data-trim style="font-size: 95%; line-height: 100%;">
EOL = \n|\r|\r\n

&lt;YYINITIAL&gt; {
  ({EOL}|{WHITE_SPACE})+      { yybegin(BODY);
                                return TokenType.WHITE_SPACE; }
}
&lt;BODY&gt; {
  {EOL}({EOL}|{WHITE_SPACE})* { return ElixirTypes.EOL; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							<tr>
								<td>Whitespace</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L478-L479">
										<pre><code class="erlang" data-trim style="font-size: 90%; line-height: 100%">
tokenize([T|Rest], Line, Scope, Tokens) when ?is_horizontal_space(T) ->
  tokenize(strip_horizontal_space(Rest), Line, Scope, Tokens);

strip_horizontal_space([H|T]) when ?is_horizontal_space(H) ->
  strip_horizontal_space(T);
strip_horizontal_space(T) ->
  T.
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L21-L63">
										<pre><code data-trim>
COMMENT = "#" [^\r\n]* {EOL}?

&lt;YYINITIAL&gt; {
  {COMMENT} { yybegin(BODY); return ElixirTypes.COMMENT; }
}
&lt;BODY&gt; {
  {COMMENT} { return ElixirTypes.COMMENT; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								In addition to turning runs of characters into single tokens, the lexer can be used
								to filter out runs that don't affect the meaning of code, such as spaces, extra new
								lines and comments.
							</p>
							<p>
								The JFlex code has two states because in v0.0.2, I used the Y-Y-INITIAL state to ignore
								newlines or whitespace at the beginning of the file.
							</p>
							<p>
								I also made the assumption that runs of EOLs could be ignored at the parser level.
							</p>
                            <p>
                                The Erlang lexer in elixir tokenizer dot erl processes the raw text as a char list.
                                Pattern matching on the head of the list and then recursively calling tokenize on the
                                rest of the raw text.  The Erlang lexer only keeps track of the effect of ignored
                                characters on the current line number, which was the only metadata in Elixir v0.14.3.
                            </p>
                            <p>
                                In contrast, the JFlex lexer processes the raw text as unicode characters.  Regular
                                expressions and references to other named regular expressions (as seen in COMMENT using
                                EOL) can be used to match text with the longest match in a given state while in the
                                Erlang Lexer, the order matches the order of the clauses.  The JFlex lexer emits a token
                                for even ignored characters because in an editor, unlike a compiler, one cares about
                                comments, whitespace and extra newlines.
                            </p>
						</aside>
					</section>
                    <section id="syntax-base-integers">
                        <h1>Base Integers</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Erlang</th>
                                <th>JFlex</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L121-L131">
                                        <pre><code data-trim style="font-size: 70%; line-height: 100%">
tokenize([$0,X,H|T], Line, Scope, Tokens) when (X == $x orelse X == $X), ?is_hex(H) ->
  {Rest, Number} = tokenize_hex([H|T], []),
  tokenize(Rest, Line, Scope, [{number, Line, Number}|Tokens]);

tokenize([$0,B,H|T], Line, Scope, Tokens) when (B == $b orelse B == $B), ?is_bin(H) ->
  {Rest, Number} = tokenize_bin([H|T], []),
  tokenize(Rest, Line, Scope, [{number, Line, Number}|Tokens]);

tokenize([$0,H|T], Line, Scope, Tokens) when ?is_octal(H) ->
  {Rest, Number} = tokenize_octal([H|T], []),
  tokenize(Rest, Line, Scope, [{number, Line, Number}|Tokens]);

tokenize_hex([H|T], Acc) when ?is_hex(H) -> tokenize_hex(T, [H|Acc]);
tokenize_hex(Rest, Acc) -> {Rest, list_to_integer(lists:reverse(Acc), 16)}.

tokenize_octal([H|T], Acc) when ?is_octal(H) -> tokenize_octal(T, [H|Acc]);
tokenize_octal(Rest, Acc) -> {Rest, list_to_integer(lists:reverse(Acc), 8)}.

tokenize_bin([H|T], Acc) when ?is_bin(H) -> tokenize_bin(T, [H|Acc]);
tokenize_bin(Rest, Acc) -> {Rest, list_to_integer(lists:reverse(Acc), 2)}.

-define(is_hex(S), ?is_digit(S) orelse (S >= $A andalso S =< $F) orelse (S >= $a andalso S =< $f)).
-define(is_bin(S), S >= $0 andalso S =< $1).
-define(is_octal(S), S >= $0 andalso S =< $7).

-define(is_digit(S), S >= $0 andalso S =< $9).
                                        </code></pre>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L27-L65">
                                        <pre><code data-trim>
BINARY_INTEGER = "0" [Bb][01]+
HEXADECIMAL_INTEGER = "0" [Xx][A-Fa-f0-9]+
OCTAL_INTEGER = "0" o?[0-7]+
INTEGER = {BINARY_INTEGER} | {HEXADECIMAL_INTEGER} | {OCTAL_INTEGER}

&lt;YYINITIAL&gt; {
  {INTEGER} { yybegin(BODY); return ElixirTypes.NUMBER; }
}
&lt;BODY&gt; {
  {INTEGER} { return ElixirTypes.NUMBER; }
}
                                        </code></pre>
                                    </a>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Base integers is the terminology elixir tokenizer dot erl uses for non-decimal integers,
                                such a binary, octal, and hexadecimal.
                            </p>
                            <p>
                                Elixir v0.14.3 is old enough that it still accepted zero-prefixed numbers as octal
                                instead of the current zero oh (<code>0o</code>).  Additionally, upper or lower case
                                B and X were allowed for binary and hexadecimal instead of just the lowercase allowed
                                now.
                            </p>
                            <p>
                                JFlex can use regular expression character classes and pipe (<code>|</code>) for 'or'
                                so it the JFlex definition can be much more compact than all the guard macros needed
                                to test the character values in Erlang.  Because all numbers will be highlighted the
                                same, I only need one <code>INTEGER</code> regular expression to match binary,
                                hexadecimal and octal numbers and use a common <code>NUMBER</code> token type.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-jflex-lexer-generation">
						<h1>JFlex Lexer Generation</h1>
						<ol class="stretch" style="font-size: 230%">
							<li>Regular Expressions</li>
							<li>
								<figure>
									<figcaption>Nondeterministic Finite Automaton</figcaption>
									<pre><code>Constructing NFA : 132 states in NFA</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>Deterministic Finite Automaton</figcaption>
									<pre><code>Converting NFA to DFA</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>Minimized Deterministic Finite Automaton</figcaption>
									<pre><code>45 states before minimization, 27 states in minimized DFA</code></pre>
								</figure>
							</li>
						</ol>
                        <aside class="notes">
                            <p>
                                The JFlex do flex file uses an external DSL, so it needs to be processed by JFlex, which
                                will go through a number of steps to combine the literal Java in braces for each
                                regular expression into a very efficient deterministinic finite automaton.
                            </p>
                            <p>
                                In the code I wrote, there are only 2 states, Y-Y-Initial (<code>YYINITIAL</code>) and
                                Body (<code>BODY</code>), which each have 4 and 5 regular expressions, respectively, so
                                JFlex is expanding those 9 state, regular expression tuples into 132 states.
                            </p>
                        </aside>
					</section>
                    <section id="syntax-finite-automaton">
                        <h1>Finite Automaton</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Non-Determininistic</th>
                                <th>Deterministic</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>Next State</th>
                                <td>Multiple</td>
                                <td>Single</td>
                            </tr>
                            <tr>
                                <th>Input</th>
                                <td>Single Character</td>
                                <td>Single Character</td>
                            </tr>
                            <tr>
                                <th>Accepts</th>
                                <td>Path exists to Accepting State</td>
                                <td>In Accepting State</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                The different steps of JFlex's lexer generation mention finite automaton, which is just
                                another name for finite state machines.
                            </p>
                            <p>
                                The lexer starts with a NFA, or Non-deterministic Finite Automaton, and converts it
                                to a DFA, or Deterministic Finite Automaton.
                            </p>
                            <p>
                                The conversion is one of those nice things in computer science that can be proven
                                possible and has various algorithms to simplify the process.  It uses a process called
                                power set construction where each state in the DFA represents a combinations of states
                                from the NFA that can be transitioned to with the same input.  This means the DFA could
                                end up with 2 to the n (<code>2<sup>n</sup></code>) states where n is the number of
                                states in the NFA.
                            </p>
                            <p>
                                Although JFlex does all this generation for one, it's important to pay attention to
                                see if the states are exploding as it can lead to slower lexing as the transition
                                table will be larger.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-jflex-generated-lexer-packing">
                        <h1>JFlex Generated Lexer - Packing</h1>
                        <pre><code class="java stretch" data-trim>
class ElixirFlexLexer implements FlexLexer {
  /** lexical states */
  public static final int YYINITIAL = 0;
  public static final int BODY = 2;

  /**
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED =
    "\11\0\1\3\1\1\1\0\1\3\1\2\22\0\1\3\2\0\1\4"+
    "\14\0\1\5\1\7\6\13\2\11\7\0\1\11\1\6\4\11\21\0"+
    "\1\10\10\0\1\11\1\6\4\11\10\0\1\12\10\0\1\10\uff87\0";

  /**
   * Translates DFA states to action switch labels.
   */
  private static final String ZZ_ACTION_PACKED_0 =
    "\2\0\1\1\1\2\1\3\1\1\1\4\1\5\1\6"+
    "\1\7\1\4\2\3\1\10\3\0\2\7\1\11\3\0"+
    "\2\10\2\11";

  /**
   * Translates a state to a row index in the transition table
   */
  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\14\0\30\0\44\0\60\0\74\0\30\0\110"+
    "\0\124\0\140\0\154\0\30\0\170\0\204\0\220\0\234"+
    "\0\204\0\30\0\250\0\264\0\300\0\314\0\264\0\220"+
    "\0\234\0\300\0\314";

  /**
   * The transition table of the DFA
   */
  private static final String ZZ_TRANS_PACKED_0 =
    "\1\3\3\4\1\5\1\6\6\3\1\7\2\10\1\11"+
    "\1\12\1\13\6\7\15\0\3\4\10\0\1\5\1\14"+
    "\1\15\11\5\5\0\1\16\1\17\1\16\1\20\1\0"+
    "\1\21\1\16\1\0\3\10\13\0\1\11\10\0\1\12"+
    "\1\22\1\23\11\12\5\0\1\24\1\25\1\24\1\26"+
    "\1\0\1\27\1\24\1\0\1\14\17\0\1\16\1\0"+
    "\1\16\3\0\1\16\5\0\1\30\1\0\1\30\11\0"+
    "\3\31\1\0\1\31\1\0\1\31\1\0\1\22\17\0"+
    "\1\24\1\0\1\24\3\0\1\24\5\0\1\32\1\0"+
    "\1\32\11\0\3\33\1\0\1\33\1\0\1\33";
}
                        </code></pre>
                        <aside class="notes">
                            <p>
                                JFlex can produce very efficient lexing code, but it comes at the cost of the code being
                                almost incomprehensible and very hard to debug.
                            </p>
                            <p>
                                For one thing, the transition tables and translates between the minimized DFA states
                                and the original states from the dot flex files are all in packed Strings.  I've never
                                tried to unpack and decipher those for errors even though looking at state transition
                                tables is a good approach for finding bugs in finite state machines in college.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-jflex-generated-lexer-switch">
                        <h1>JFlex Generated Lexer - Switch</h1>
                        <pre><code class="java stretch" data-trim>
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
  case 5:
    { return ElixirTypes.EOL;
    }
  case 10: break;
  case 2:
    { yybegin(BODY); return TokenType.WHITE_SPACE;
    }
  case 11: break;
  case 3:
    { yybegin(BODY); return ElixirTypes.COMMENT;
    }
  case 12: break;
  case 9:
    { return ElixirTypes.NUMBER;
    }
  case 13: break;
  case 1:
    { yybegin(BODY); return TokenType.BAD_CHARACTER;
    }
  case 14: break;
  case 7:
    { return ElixirTypes.COMMENT;
    }
  case 15: break;
  case 8:
    { yybegin(BODY); return ElixirTypes.NUMBER;
    }
  case 16: break;
  case 4:
    { return TokenType.BAD_CHARACTER;
    }
  case 17: break;
  case 6:
    { return TokenType.WHITE_SPACE;
    }
  case 18: break;
  default:
    if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
      zzAtEOF = true;
      zzDoEOF();
      return null;
    }
    else {
      zzScanError(ZZ_NO_MATCH);
    }
}
                        </code></pre>
                        <aside class="notes">
                            <p>
                                From the constants at the top of the class, I know <code>BODY</code> is <code>2</code>,
                                but the switch statement is on Z-Z-Action (<code>zzAction</code>), so it's not
                                necessarily even the same numbering and the Java code for Y-Y-Initial
                                (<code>YYINITIAL</code>) and BODY (<code>BODY</code>) states seems to be intermixed,
                                so the only way I've found to debug the lexer crashing or hanging is break-points in
                                braces from the Java code and test sequences.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-v0.0.2">
                        <h1>v0.0.2</h1>
                        <ul>
                            <li>
                                <p>Enhancements</p>
                                <ul>
                                    <li>Comments</li>
                                    <li>Binary numbers</li>
                                    <li>Hexadecimal numbers</li>
                                    <li>Octal numbers</li>
                                </ul>
                            </li>
                            <li>
                                <p>Bug Fixes</p>
                                <ul>
                                    <li>Parser no longer freezes</li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">
                            <p>
                                With version oh dot oh dot two (<code>v0.0.2</code>), IntelliJ Elixir no longer froze
                                the IDE, but I could only parse Comments or base integers, but I had started to under
                                how to generate a lexer properly using JFlex.
                            </p>
                        </aside>
                    </section>
				</section>
				<section id="bibliography">
                    <h1>Bibliography</h1>
					<ul>
						<li>
							<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">
								Backus-Naur Form
							</a>
						</li>
					</ul>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				center: true,
				controls: true,
				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				],
				height: 1280,
				history: true,
				progress: true,
				// Slide number formatting can be configured using these variables:
				//  h: current slide's horizontal index
				//  v: current slide's vertical index
				//  c: current slide index (flattened)
				//  t: total number of slides (flattened)
				slideNumber: 'c / t',
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				width: 2048
			});

		</script>

	</body>
</html>
