<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>ElixirConf 2015 - The Road to IntelliJ Elixir 1.0.0</title>

		<meta name="description" content="How I went from &quot;I wonder if there's an Rubymine plugin for Elixir?&quot; to writing one myself and eventually using it to find bugs in native Elixir.">
		<meta name="author" content="Luke Imhoff">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="stack">
					<section>
						<h1>ElixirConf 2015</h1>
						<h2>The Road to IntelliJ Elixir 1.0.0</h2>
						<p>2015-10-02 to 2015-10-03</p>
						<p>Luke Imhoff</p>
						<table>
							<tbody>
							<tr>
								<th>
									<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                                     version="1.1" id="Capa_1" x="0px" y="0px" width="14px" height="10px"
                                     viewBox="0 0 14 10" enable-background="new 0 0 14 10" xml:space="preserve">
                                     <g>
                                        <path d="M7,7L5.268,5.484L0.316,9.729C0.496,9.896,0.739,10,1.007,10h11.986c0.267,0,0.509-0.104,0.688-0.271L8.732,5.484L7,7z"></path>
                                        <path d="M13.684,0.271C13.504,0.103,13.262,0,12.993,0H1.007C0.74,0,0.498,0.104,0.318,0.273L7,6L13.684,0.271z"></path>
                                        <polygon points="0,0.878 0,9.186 4.833,5.079  "></polygon>
                                        <polygon points="9.167,5.079 14,9.186 14,0.875  "></polygon>
                                     </g>
                                </svg>
								</th>
								<td>Kronic.Deth@gmail.com</td>
							</tr>
							<tr>
								<th>
									<svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg"
                                     xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16"
                                     enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
                               </svg>
								</th>
								<td>
									<a href="https://github.com/KronicDeth" target="_blank">@KronicDeth</a>
								</td>
							</tr>
							<tr>
								<th>
									<svg version="1.1" class="twitter-icon-svg"
                                            xmlns="http://www.w3.org/2000/svg"
                                            xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                                            <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
                                        </svg>
								</th>
								<td>
									<a href="https://twitter.com/KronicDeth" target="_blank">@KronicDeth</a>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								I am the maintainer of intellij-elixir, the Elixir plugin for Jetbrains IDEs.  I have
								contributed to the Elixir standard library and found bugs in the native tokenizer and parser
								through my work on intellij-elixir.  I help run the Austin Elixir meetup.
							</p>
						</aside>
					</section>
					<section>
						<h1>This Presentation</h1>
						<dl>
							<dt>Slides</dt>
							<dd>
								<dl>
									<dt>Viewable</dt>
									<dd>
										<a href="https://kronicdeth.github.io/the-road-to-intellij-elixir-1.0.0">
											https://kronicdeth.github.io/the-road-to-intellij-elixir-1.0.0
										</a>
									</dd>
									<dt>Source</dt>
									<dd>
										<a href="https://github.com/KronicDeth/the-road-to-intellij-elixir-1.0.0/tree/gh-pages">
											https://github.com/KronicDeth/the-road-to-intellij-elixir-1.0.0/tree/gh-pages
										</a>
									</dd>
								</dl>
							</dd>
							<dt>Project Source</dt>
							<dd>
								<a href="https://github.com/KronicDeth/intellij-elixir/tree/v1.0.0">
									https://github.com/KronicDeth/intellij-elixir/tree/v1.0.0
								</a>
							</dd>
						</dl>
						<aside class="notes">
							<p>
								For viewers that want to follow along with their own copy of the slides or project
								source, they can be accessed at the shown addresses.
							</p>
						</aside>
					</section>
					<section>
						<h1>Outline</h1>
						<ul>
							<li>
								<a href="#/introduction">Introduction</a>
							</li>
							<li>
								<a href="#/bnf">BNF</a>
							</li>
							<li>
								<a href="#/syntax">Syntax</a>
							</li>
                            <li>
                                <a href="#/interpolation">Interpolation</a>
                            </li>
                            <li>
                                <a href="#/sigils">Sigils</a>
                            </li>
                            <li>
                                <a href="#/atoms">Atoms</a>
                            </li>
							<li>
								<a href="#/matched-expressions">Matched Expressions</a>
							</li>
							<li>
								<ul>
									<li>
										<a href="#/no-parentheses-function-calls">No Parentheses Function Calls</a>
									</li>
									<li>
										<a href="#/jinterface">JInterface</a>
									</li>
									<li>
										<a href="#/v0.2.1">v0.2.1</a>
									</li>
								</ul>
							</li>
							<li>
								<a href="#/significant-whitespace">Significant Whitespace</a>
							</li>
							<li>
								<a href="#/stab">Stab</a>
							</li>
							<li>
								<a href="#/unmatched-expressions">Unmatched Expressions</a>
							</li>
						</ul>
					</section>
				</section>
				<section class="stack">
					<section id="introduction">
						<h1>Introduction</h1>
						<ul>
							<li>
								<a href="#/introduction-why-an-intellij-plugin">
									Why an IntelliJ Plugin?
								</a>
							</li>
							<li>
								<a href="#/introduction-timeline">
									Timeline
								</a>
							</li>
						</ul>
					</section>
					<section id="introduction-why-an-intellij-plugin">
						<h1>Why an IntelliJ Plugin?</h1>
						<ul>
							<li>I use Rubymine for Ruby development</li>
							<li>Wanted vim key bindings</li>
							<li>Wanted Cmd+Click Go To Definition for Elixir</li>
							<li>Wanted Search Everywhere for Elixir</li>
							<li>There was a tutorial</li>
						</ul>
						<aside class="notes">
							<p>
								People may wonder why I took it upon myself to make an IDE plugin for Elixir, when I
								could have used a vim or emacs plugin.
							</p>
							<p>
								I've used both emacs and vim.  I started with emacs when I worked at Cray, only
								switching to vim when I needed something that worked over a high-latency, low-bandwidth
								CDMA modem on the high-way.
							</p>
							<p>
								I started using Rubymine when my boss at a previous job, Nicholas Cancelliere,
								introduced me to it.  I was shocked that an IDE for a dynamic language like Ruby could
								support Find Usage, Go To Definition, and Refactor.  I had been use to using ctags for
								vim.
							</p>
							<p>
								I haven't complete abandoned using vim either.  I still use syntax highlighting plugins
								for vim in iTerm when I need to edit configuration files and I use the IDEAVim plugin
								for Jetbrains IDEs like Rubymine, Webstorm, and IntelliJ.
							</p>
							<p>
								Without Rubymine I don't think I'd have been able to as quickly dive through the complex
								code-base in Metasploit and the graphical debugger allowed me to teach myself the
								internals of Rails and other DSLs.
							</p>
							<p>
								I understood that many of the features I liked about Rubymine were shared across
								JetBrains' various IDEs, so if I could write the parts of a plugin to get JetBrains APIs
								to understand Elixir syntax and semantics, the features I really wanted would just work
								without me having to understand how to write the parts that were cross-language.
							</p>
							<p>
								However, just getting syntax lexing and parsing right ended up taking a year...
							</p>
						</aside>
					</section>
					<section id="introduction-timeline">
						<h1>Timeline</h1>
						<table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th colspan="2">Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
								<th>Name</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2014-07-27</td>
								<td>0</td>
								<td>0</td>
								<td>1</td>
								<td>1</td>
								<td>1.00</td>
								<td>Initial</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;02</td>
								<td>6</td>
								<td>6</td>
								<td>18</td>
								<td>19</td>
								<td>3.00</td>
								<td>0.0.1</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;03</td>
								<td>1</td>
								<td>7</td>
								<td>14</td>
								<td>33</td>
								<td>14.00</td>
								<td>0.0.2</td>
							</tr>
							<tr>
								<td>2014&#8209;08&#8209;08</td>
								<td>5</td>
								<td>12</td>
								<td>10</td>
								<td>43</td>
								<td>2.00</td>
								<td>0.0.3</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;13</td>
								<td>36</td>
								<td>48</td>
								<td>64</td>
								<td>107</td>
								<td>1.78</td>
								<td>0.1.0</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;20</td>
								<td>7</td>
								<td>55</td>
								<td>4</td>
								<td>111</td>
								<td>0.57</td>
								<td>0.1.1</td>
							</tr>
							<tr>
								<td>2014&#8209;09&#8209;25</td>
								<td>5</td>
								<td>60</td>
								<td>12</td>
								<td>123</td>
								<td>2.50</td>
								<td>0.1.2</td>
							</tr>
							<tr>
								<td>2014&#8209;10&#8209;14</td>
								<td>19</td>
								<td>79</td>
								<td>23</td>
								<td>146</td>
								<td>1.21</td>
								<td>0.1.3</td>
							</tr>
							<tr>
								<td>2014&#8209;11&#8209;30</td>
								<td>47</td>
								<td>126</td>
								<td>226</td>
								<td>373</td>
								<td>4.81</td>
								<td>0.2.0</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;03</td>
								<td>124</td>
								<td>250</td>
								<td>521</td>
								<td>894</td>
								<td>4.20</td>
								<td>0.2.1</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;10</td>
								<td>7</td>
								<td>257</td>
								<td>27</td>
								<td>921</td>
								<td>3.86</td>
								<td>0.3.0</td>
							</tr>
							<tr>
								<td>2015&#8209;04&#8209;27</td>
								<td>17</td>
								<td>274</td>
								<td>66</td>
								<td>987</td>
								<td>3.88</td>
								<td>0.3.1</td>
							</tr>
							<tr>
								<td>2015&#8209;05&#8209;01</td>
								<td>4</td>
								<td>278</td>
								<td>8</td>
								<td>995</td>
								<td>2.00</td>
								<td>0.3.2</td>
							</tr>
							<tr>
								<td>2015&#8209;05&#8209;15</td>
								<td>14</td>
								<td>292</td>
								<td>34</td>
								<td>1029</td>
								<td>2.43</td>
								<td>0.3.3</td>
							</tr>
							<tr>
								<td>2015&#8209;06&#8209;04</td>
								<td>20</td>
								<td>312</td>
								<td>86</td>
								<td>1115</td>
								<td>4.30</td>
								<td>0.3.4</td>
							</tr>
							<tr>
								<td>2015&#8209;07&#8209;08</td>
								<td>34</td>
								<td>346</td>
								<td>83</td>
								<td>1198</td>
								<td>2.44</td>
								<td>0.3.5</td>
							</tr>
							<tr>
								<td>2015&#8209;07&#8209;27</td>
								<td>19</td>
								<td>365</td>
								<td>158</td>
								<td>1356</td>
								<td>2.44</td>
								<td>1.0.0</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								I was exactly 1 year between the initial commit of the project skeleton to the v1.0.0 tag.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="bnf">
						<h1>BNF</h1>
						<ul>
							<li>
								<a href="#/bnf-backus-naur-form">Backus Naur Form</a>
							</li>
							<li>
								<a href="#/bnf-yecc">YECC</a>
							</li>
							<li>
								<a href="#/bnf-grammar-kit">Grammar Kit</a>
							</li>
							<li>
								<a href="#/bnf-v0.0.1">v0.0.1</a>
							</li>
						</ul>
					</section>
					<section id="bnf-backus-naur-form">
						<h1>Backus-Naur Form</h1>
						<table>
							<thead>
							<tr>
								<th>Read as</th>
								<th>Symbol</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Metasyntactic Variable</td>
								<td>
									<pre><code class="bnf">&lt;variable&gt;</code></pre>
								</td>
							</tr>
							<tr>
								<td>is defined as</td>
								<td>
									<pre><code class="bnf">::=</code></pre>
								</td>
							</tr>
							<tr>
								<td>or</td>
								<td>
									<pre><code class="bnf">|</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<pre><code data-trim>
&lt;expr&gt; ::= &lt;integer&gt; | &lt;expr&gt; &lt;op&gt; &lt;integer&gt;
						</code></pre>
						<aside class="notes">
							<p>
								One of the standard ways of defining a syntax is in BNF, or Backus-Naur Form, which
								was first used for the Algol 60 standard.
							</p>
							<p>
								Both YECC and GrammarKit use a form of BNF, so I assumed it was just a matter of
								porting elixir dot Y-R-L to elixir dot B-N-F.
							</p>
						</aside>
					</section>
					<section id="bnf-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/12f89a30b46279398fc7143e433681c2194b03d9/lib/elixir/src/elixir_parser.yrl#L77-L82">
									lib/elixir/src/elixir_parser.yrl
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 300%; line-height: 100%">
grammar -> eoe : nil.
grammar -> expr_list : to_block('$1').
grammar -> eoe expr_list : to_block('$2').
grammar -> expr_list eoe : to_block('$1').
grammar -> eoe expr_list eoe : to_block('$2').
grammar -> '$empty' : nil.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								YECC is a parser generator written in Erlang (and part of the standard distribution)
								that is based on yacc (with an 'a' instead of an 'e'), which is a parser generator
								written in C.
							</p>
							<p>
								The YECC syntax differs from B-N-F in that it uses a skinny arrow (<code>-></code>)
								instead of colon colon equals (<code>::=</code>) and instead of using pipe
								(<code>|</code>) for OR, lines with the same rule name are repeated with alternative
								definitions. Finally, YECC supports running Erlang code on the tokens using dollar
								number (<code>$n</code>) for positional references to the matches tokens.
							</p>
							<p>
								dollar empty (<code>$empty</code>) is a special token that matches no input.  In
								formal grammars this is usually referred to as (lowercase) epsilon (<code>ɛ</code>).
							</p>
						</aside>
					</section>
					<section id="bnf-grammar-kit">
						<h1>Grammar Kit</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf">
									src/org/elixir_lang/Elixir.bnf
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 165%; line-height: 100%">
private elixirFile ::= endOfExpression? (expressionList endOfExpression?)?
private expressionList ::= expression (endOfExpression expression | adjacentExpression)*
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Grammar Kit is a parser generator written in Java and created by JetBrains.
							</p>
							<p>
								GrammarKit's B-N-F format <strong>does</strong> use colon colon equals (<code>::=</code>)
								like Backus-Naur Form, but it has some more power constructs above pipe (<code>|</code>)
								for OR.
							</p>
							<p>
								Question mark (<code>?</code>) can be used for 0 or 1, parentheses (<code>()</code>)
								can be used for grouping; and star can be used for 0 or more.  Empty can be implied
								by question mark (<code>?</code>) or star (<code>*</code>) matching nothing or there
								being nothing on the right-hand-side of the colon colon equals (<code>::=</code>).
							</p>
							<p>
								You'll also notice that there is no inline Java code after the rule definition unlike
								in YECC where there as Erlang code.  This is because GrammarKit automatically generates
								an AST, which it calls a PSI (or Program Structure Interface) Tree from the matched
								rules, so there's no need to define how to build the tree.
							</p>
							<p>
								Having GrammarKit generate the AST is both good and bad.  It's good because it removes
								a lot of redundant code, but it's bad because rules must evaluate in the correct order
								to reflect the desired nesting and associativity without any manual fixups, which are
								possible with the Erlang code in YECC.
							</p>
						</aside>
					</section>
					<section id="bnf-v0.0.1">
						<h1>v0.0.1</h1>
                        <table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th colspan="2">Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
							</thead>
							<tbody>
                            <tr>
								<td>2014&#8209;08&#8209;02</td>
								<td>6</td>
								<td>6</td>
								<td>18</td>
								<td>19</td>
								<td>3.00</td>
							</tr>
                            </tbody>
                        </table>
						<ol>
							<li>Translate from YECC to Grammar Kit</li>
							<li>Freeze IDE</li>
						</ol>
						<aside class="notes">
							<p>
								YECC and Grammar Kit both support a form of BNF and Grammar Kit seems like it would
								support even a more compact grammar because question mark (<code>?</code>), star
								(<code>star</code>), pipe (<code>|</code>) and parentheses (<code>()</code>) could
								eliminate some of the redundancy needed in the multi-clause rules in YECC.
							</p>
							<p>
								After only 6 days I had quote unquote translated the BNF from yecc to Grammar Kit and
								ended up with a parser that froze the IDE, which Julius "h4cc" Beckmann reported. That
								left the slow process of translating the grammar correctly over the next 359 days.  At
								the time of the freeze, I didn't even really understand translating the BNF didn't work,
								all I knew was I needed to go slower and build the grammar up from simpler, testable
								pieces.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="syntax">
						<h1>Syntax</h1>
						<ul>
							<li>
								<a href="#/syntax-analysis">Syntactic Analysis</a>
							</li>
							<li>
								<a href="#/syntax-lexing">Lexing/Tokenizing</a>
							</li>
                            <li>
                                <a href="#/syntax-ignored">Ignoring Characters</a>
                            </li>
                            <li>
                                <a href="#/syntax-base-integers">Base Integers</a>
                            </li>
							<li>
								<a href="#/syntax-jflex-lexer-generation">JFlex Lexer Generation</a>
							</li>
                            <li>
                                <a href="#/syntax-finite-automaton">Finite Automaton</a>
                            </li>
                            <li>
                                <a href="#/syntax-jflex-generated-lexer-packing">JFlex Generated Lexer - Packaing</a>
                            </li>
                            <li>
                                <a href="#/syntax-jflex-generated-lexer-switch">JFlex Generated Lexer - Switch</a>
                            </li>
							<li>
								<a href="#/syntax-v0.0.2">v0.0.2</a>
							</li>
						</ul>
					</section>
					<section id="syntax-analysis">
						<h1>Syntactic Analysis</h1>
						<table>
							<thead>
							<tr>
								<th>Step</th>
								<th>Elixir</th>
								<th>IntelliJ Elixir</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Lexing</th>
								<td>
									Erlang
								</td>
								<td>
									JFlex
								</td>
							</tr>
							<tr>
								<th>Parsing</th>
								<td>
									YECC
								</td>
								<td>
									GrammarKit
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								So, I went back and actually started to do the JetBrains tutorial step by step instead
								of jumping ahead and searched Wikipedia, trying to find CompSci articles that explained
								the correct way to do this.
							</p>
							<p>
								In order to support color syntax highlighting and mark syntax errors with the nice
								red squiggly under line, IntelliJ Elixir needed to be able to analyze Elixir syntax.
							</p>
							<p>
								Syntactic analysis is usually broken down into two parts: the first breaks the raw text
								into tokens and the second checks if those tokens are arranged in the correct order.
							</p>
							<p>
								In most programming languages, both lexers and parsers are built using generators that
								have an external DSL.  In Elixir, the lexer is built using Erlang directly because
								Erlang pattern matching is compact enough that a generator is unnecessary.
								Additionally, Elixir syntax contains some features that normal lexer generator aren't
								expecting.
							</p>
							<p>
								For IntelliJ Elixir, I used JFlex because it was the lexer generator recommended by
								JetBrain's plugin tutorial.
							</p>
							<p>
								For parsing Elixir does use a generator, called yecc, which generates Erlang code.
							</p>
							<p>
								For IntelliJ Elixir, I used JetBrains' GrammarKit.
							</p>
							<p>
								When I first started IntelliJ Elixir I didn't understand the important difference
								between these two stacks, but I hope to explain what I learned along the way to you.
							</p>
						</aside>
					</section>
					<section id="syntax-lexing">
						<h1>Lexing/Tokenizing</h1>
						<ol>
							<li>Match Input</li>
							<li>Emit Token</li>
						</ol>
						<aside class="notes">
							<p>
								The first step of syntactic analysis is lexing, also known as tokenizing.  Lexing
								breaks up the raw text into tokens, such as keywords, literals, operators, and
								identifiers.
							</p>
							<p>
								Input is matched using some pattern.  In native Elixir, this is pattern matching on
								Erlang string prefixes.  In IntelliJ Elixir's JFlex file, it's regular expressions.
							</p>
						</aside>
					</section>
					<section id="syntax-ignored">
						<h1>Ignoring Characters</h1>
						<table class="stretch">
							<thead>
							<tr>
								<th>Token</th>
								<th>Erlang</th>
								<th>JFlex</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Comments</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L133-L137">
										<pre><code class="erlang" data-trim style="font-size: 85%; line-height: 100%">
tokenize([$#|String], Line, Scope, Tokens) ->
  Rest = tokenize_comment(String),
  tokenize(Rest, Line, Scope, Tokens);

tokenize_comment("\r\n" ++ _ = Rest) -> Rest;
tokenize_comment("\n" ++ _ = Rest)   -> Rest;
tokenize_comment([_|Rest])           -> tokenize_comment(Rest);
tokenize_comment([])                 -> [].
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L21-L63">
										<pre><code data-trim>
COMMENT = "#" [^\r\n]* {EOL}?

&lt;YYINITIAL&gt; {
  {COMMENT} { yybegin(BODY); return ElixirTypes.COMMENT; }
}
&lt;BODY&gt; {
  {COMMENT} { return ElixirTypes.COMMENT; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							<tr>
								<td>EOL</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L320-L324">
										<pre><code class="erlang" data-trim>
tokenize("\n" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line + 1, Scope, eol(Line, newline, Tokens));

tokenize("\r\n" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line + 1, Scope, eol(Line, newline, Tokens));

eol(_Line, _Mod, [{',',_}|_] = Tokens)   -> Tokens;
eol(_Line, _Mod, [{eol,_,_}|_] = Tokens) -> Tokens;
eol(Line, Mod, Tokens) -> [{eol,Line,Mod}|Tokens].
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L18-L59">
										<pre><code data-trim style="font-size: 95%; line-height: 100%;">
EOL = \n|\r|\r\n

&lt;YYINITIAL&gt; {
  ({EOL}|{WHITE_SPACE})+      { yybegin(BODY);
                                return TokenType.WHITE_SPACE; }
}
&lt;BODY&gt; {
  {EOL}({EOL}|{WHITE_SPACE})* { return ElixirTypes.EOL; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							<tr>
								<td>Whitespace</td>
								<td>
									<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L478-L479">
										<pre><code class="erlang" data-trim style="font-size: 90%; line-height: 100%">
tokenize([T|Rest], Line, Scope, Tokens) when ?is_horizontal_space(T) ->
  tokenize(strip_horizontal_space(Rest), Line, Scope, Tokens);

strip_horizontal_space([H|T]) when ?is_horizontal_space(H) ->
  strip_horizontal_space(T);
strip_horizontal_space(T) ->
  T.
										</code></pre>
									</a>
								</td>
								<td>
									<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L21-L63">
										<pre><code data-trim>
COMMENT = "#" [^\r\n]* {EOL}?

&lt;YYINITIAL&gt; {
  {COMMENT} { yybegin(BODY); return ElixirTypes.COMMENT; }
}
&lt;BODY&gt; {
  {COMMENT} { return ElixirTypes.COMMENT; }
}
										</code></pre>
									</a>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								In addition to turning runs of characters into single tokens, the lexer can be used
								to filter out runs that don't affect the meaning of code, such as spaces, extra new
								lines and comments.
							</p>
							<p>
								The JFlex code has two states because in v0.0.2, I used the Y-Y-INITIAL state to ignore
								newlines or whitespace at the beginning of the file.
							</p>
							<p>
								I also made the assumption that runs of EOLs could be ignored at the parser level.
							</p>
                            <p>
                                The Erlang lexer in elixir tokenizer dot erl processes the raw text as a char list.
                                Pattern matching on the head of the list and then recursively calling tokenize on the
                                rest of the raw text.  The Erlang lexer only keeps track of the effect of ignored
                                characters on the current line number, which was the only metadata in Elixir v0.14.3.
                            </p>
                            <p>
                                In contrast, the JFlex lexer processes the raw text as unicode characters.  Regular
                                expressions and references to other named regular expressions (as seen in COMMENT using
                                EOL) can be used to match text with the longest match in a given state while in the
                                Erlang Lexer, the order matches the order of the clauses.  The JFlex lexer emits a token
                                for even ignored characters because in an editor, unlike a compiler, one cares about
                                comments, whitespace and extra newlines.
                            </p>
						</aside>
					</section>
                    <section id="syntax-base-integers">
                        <h1>Base Integers</h1>
                        <table class="stretch">
                            <thead>
                            <tr>
                                <th>Erlang</th>
                                <th>JFlex</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L121-L131">
                                        <pre><code data-trim style="font-size: 70%; line-height: 100%">
tokenize([$0,X,H|T], Line, Scope, Tokens) when (X == $x orelse X == $X), ?is_hex(H) ->
  {Rest, Number} = tokenize_hex([H|T], []),
  tokenize(Rest, Line, Scope, [{number, Line, Number}|Tokens]);

tokenize([$0,B,H|T], Line, Scope, Tokens) when (B == $b orelse B == $B), ?is_bin(H) ->
  {Rest, Number} = tokenize_bin([H|T], []),
  tokenize(Rest, Line, Scope, [{number, Line, Number}|Tokens]);

tokenize([$0,H|T], Line, Scope, Tokens) when ?is_octal(H) ->
  {Rest, Number} = tokenize_octal([H|T], []),
  tokenize(Rest, Line, Scope, [{number, Line, Number}|Tokens]);

tokenize_hex([H|T], Acc) when ?is_hex(H) -> tokenize_hex(T, [H|Acc]);
tokenize_hex(Rest, Acc) -> {Rest, list_to_integer(lists:reverse(Acc), 16)}.

tokenize_octal([H|T], Acc) when ?is_octal(H) -> tokenize_octal(T, [H|Acc]);
tokenize_octal(Rest, Acc) -> {Rest, list_to_integer(lists:reverse(Acc), 8)}.

tokenize_bin([H|T], Acc) when ?is_bin(H) -> tokenize_bin(T, [H|Acc]);
tokenize_bin(Rest, Acc) -> {Rest, list_to_integer(lists:reverse(Acc), 2)}.

-define(is_hex(S), ?is_digit(S) orelse (S >= $A andalso S =< $F) orelse (S >= $a andalso S =< $f)).
-define(is_bin(S), S >= $0 andalso S =< $1).
-define(is_octal(S), S >= $0 andalso S =< $7).

-define(is_digit(S), S >= $0 andalso S =< $9).
                                        </code></pre>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.2/src/org/elixir_lang/Elixir.flex#L27-L65">
                                        <pre><code data-trim>
BINARY_INTEGER = "0" [Bb][01]+
HEXADECIMAL_INTEGER = "0" [Xx][A-Fa-f0-9]+
OCTAL_INTEGER = "0" o?[0-7]+
INTEGER = {BINARY_INTEGER} | {HEXADECIMAL_INTEGER} | {OCTAL_INTEGER}

&lt;YYINITIAL&gt; {
  {INTEGER} { yybegin(BODY); return ElixirTypes.NUMBER; }
}
&lt;BODY&gt; {
  {INTEGER} { return ElixirTypes.NUMBER; }
}
                                        </code></pre>
                                    </a>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Base integers is the terminology elixir tokenizer dot erl uses for non-decimal integers,
                                such a binary, octal, and hexadecimal.
                            </p>
                            <p>
                                Elixir v0.14.3 is old enough that it still accepted zero-prefixed numbers as octal
                                instead of the current zero oh (<code>0o</code>).  Additionally, upper or lower case
                                B and X were allowed for binary and hexadecimal instead of just the lowercase allowed
                                now.
                            </p>
                            <p>
                                JFlex can use regular expression character classes and pipe (<code>|</code>) for 'or'
                                so it the JFlex definition can be much more compact than all the guard macros needed
                                to test the character values in Erlang.  Because all numbers will be highlighted the
                                same, I only need one <code>INTEGER</code> regular expression to match binary,
                                hexadecimal and octal numbers and use a common <code>NUMBER</code> token type.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-jflex-lexer-generation">
						<h1>JFlex Lexer Generation</h1>
						<ol class="stretch" style="font-size: 230%">
							<li>Regular Expressions</li>
							<li>
								<figure>
									<figcaption>Nondeterministic Finite Automaton</figcaption>
									<pre><code>Constructing NFA : 132 states in NFA</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>Deterministic Finite Automaton</figcaption>
									<pre><code>Converting NFA to DFA</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>Minimized Deterministic Finite Automaton</figcaption>
									<pre><code>45 states before minimization, 27 states in minimized DFA</code></pre>
								</figure>
							</li>
						</ol>
                        <aside class="notes">
                            <p>
                                The JFlex do flex file uses an external DSL, so it needs to be processed by JFlex, which
                                will go through a number of steps to combine the literal Java in braces for each
                                regular expression into a very efficient deterministinic finite automaton.
                            </p>
                            <p>
                                In the code I wrote, there are only 2 states, Y-Y-Initial (<code>YYINITIAL</code>) and
                                Body (<code>BODY</code>), which each have 4 and 5 regular expressions, respectively, so
                                JFlex is expanding those 9 state, regular expression tuples into 132 states.
                            </p>
                        </aside>
					</section>
                    <section id="syntax-finite-automaton">
                        <h1>Finite Automaton</h1>
                        <table>
                            <thead>
                            <tr>
                                <th></th>
                                <th>Non-Determininistic</th>
                                <th>Deterministic</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <th>Next State</th>
                                <td>Multiple</td>
                                <td>Single</td>
                            </tr>
                            <tr>
                                <th>Input</th>
                                <td>Single Character</td>
                                <td>Single Character</td>
                            </tr>
                            <tr>
                                <th>Accepts</th>
                                <td>Path exists to Accepting State</td>
                                <td>In Accepting State</td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                The different steps of JFlex's lexer generation mention finite automaton, which is just
                                another name for finite state machines.
                            </p>
                            <p>
                                The lexer starts with a NFA, or Non-deterministic Finite Automaton, and converts it
                                to a DFA, or Deterministic Finite Automaton.
                            </p>
                            <p>
                                The conversion is one of those nice things in computer science that can be proven
                                possible and has various algorithms to simplify the process.  It uses a process called
                                power set construction where each state in the DFA represents a combinations of states
                                from the NFA that can be transitioned to with the same input.  This means the DFA could
                                end up with 2 to the n (<code>2<sup>n</sup></code>) states where n is the number of
                                states in the NFA.
                            </p>
                            <p>
                                Although JFlex does all this generation for one, it's important to pay attention to
                                see if the states are exploding as it can lead to slower lexing as the transition
                                table will be larger.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-jflex-generated-lexer-packing">
                        <h1>JFlex Generated Lexer - Packing</h1>
                        <pre><code class="java stretch" data-trim>
class ElixirFlexLexer implements FlexLexer {
  /** lexical states */
  public static final int YYINITIAL = 0;
  public static final int BODY = 2;

  /**
   * Translates characters to character classes
   */
  private static final String ZZ_CMAP_PACKED =
    "\11\0\1\3\1\1\1\0\1\3\1\2\22\0\1\3\2\0\1\4"+
    "\14\0\1\5\1\7\6\13\2\11\7\0\1\11\1\6\4\11\21\0"+
    "\1\10\10\0\1\11\1\6\4\11\10\0\1\12\10\0\1\10\uff87\0";

  /**
   * Translates DFA states to action switch labels.
   */
  private static final String ZZ_ACTION_PACKED_0 =
    "\2\0\1\1\1\2\1\3\1\1\1\4\1\5\1\6"+
    "\1\7\1\4\2\3\1\10\3\0\2\7\1\11\3\0"+
    "\2\10\2\11";

  /**
   * Translates a state to a row index in the transition table
   */
  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\14\0\30\0\44\0\60\0\74\0\30\0\110"+
    "\0\124\0\140\0\154\0\30\0\170\0\204\0\220\0\234"+
    "\0\204\0\30\0\250\0\264\0\300\0\314\0\264\0\220"+
    "\0\234\0\300\0\314";

  /**
   * The transition table of the DFA
   */
  private static final String ZZ_TRANS_PACKED_0 =
    "\1\3\3\4\1\5\1\6\6\3\1\7\2\10\1\11"+
    "\1\12\1\13\6\7\15\0\3\4\10\0\1\5\1\14"+
    "\1\15\11\5\5\0\1\16\1\17\1\16\1\20\1\0"+
    "\1\21\1\16\1\0\3\10\13\0\1\11\10\0\1\12"+
    "\1\22\1\23\11\12\5\0\1\24\1\25\1\24\1\26"+
    "\1\0\1\27\1\24\1\0\1\14\17\0\1\16\1\0"+
    "\1\16\3\0\1\16\5\0\1\30\1\0\1\30\11\0"+
    "\3\31\1\0\1\31\1\0\1\31\1\0\1\22\17\0"+
    "\1\24\1\0\1\24\3\0\1\24\5\0\1\32\1\0"+
    "\1\32\11\0\3\33\1\0\1\33\1\0\1\33";
}
                        </code></pre>
                        <aside class="notes">
                            <p>
                                JFlex can produce very efficient lexing code, but it comes at the cost of the code being
                                almost incomprehensible and very hard to debug.
                            </p>
                            <p>
                                For one thing, the transition tables and translates between the minimized DFA states
                                and the original states from the dot flex files are all in packed Strings.  I've never
                                tried to unpack and decipher those for errors even though looking at state transition
                                tables is a good approach for finding bugs in finite state machines in college.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-jflex-generated-lexer-switch">
                        <h1>JFlex Generated Lexer - Switch</h1>
                        <pre><code class="java stretch" data-trim>
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
  case 5:
    { return ElixirTypes.EOL;
    }
  case 10: break;
  case 2:
    { yybegin(BODY); return TokenType.WHITE_SPACE;
    }
  case 11: break;
  case 3:
    { yybegin(BODY); return ElixirTypes.COMMENT;
    }
  case 12: break;
  case 9:
    { return ElixirTypes.NUMBER;
    }
  case 13: break;
  case 1:
    { yybegin(BODY); return TokenType.BAD_CHARACTER;
    }
  case 14: break;
  case 7:
    { return ElixirTypes.COMMENT;
    }
  case 15: break;
  case 8:
    { yybegin(BODY); return ElixirTypes.NUMBER;
    }
  case 16: break;
  case 4:
    { return TokenType.BAD_CHARACTER;
    }
  case 17: break;
  case 6:
    { return TokenType.WHITE_SPACE;
    }
  case 18: break;
  default:
    if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
      zzAtEOF = true;
      zzDoEOF();
      return null;
    }
    else {
      zzScanError(ZZ_NO_MATCH);
    }
}
                        </code></pre>
                        <aside class="notes">
                            <p>
                                From the constants at the top of the class, I know <code>BODY</code> is <code>2</code>,
                                but the switch statement is on Z-Z-Action (<code>zzAction</code>), so it's not
                                necessarily even the same numbering and the Java code for Y-Y-Initial
                                (<code>YYINITIAL</code>) and BODY (<code>BODY</code>) states seems to be intermixed,
                                so the only way I've found to debug the lexer crashing or hanging is break-points in
                                braces from the Java code and test sequences.
                            </p>
                        </aside>
                    </section>
                    <section id="syntax-v0.0.2">
                        <h1>v0.0.2</h1>
                        <table>
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
							</thead>
							<tbody>
                            <tr>
								<td>2014&#8209;08&#8209;03</td>
								<td>1</td>
								<td>7</td>
								<td>14</td>
								<td>33</td>
								<td>14.00</td>
							</tr>
                            </tbody>
                        </table>
                        <ul>
                            <li>
                                <p>Enhancements</p>
                                <ul>
                                    <li>Comments</li>
                                    <li>Binary numbers</li>
                                    <li>Hexadecimal numbers</li>
                                    <li>Octal numbers</li>
                                </ul>
                            </li>
                            <li>
                                <p>Bug Fixes</p>
                                <ul>
                                    <li>Parser no longer freezes</li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">
                            <p>
                                With version oh dot oh dot two (<code>v0.0.2</code>), IntelliJ Elixir no longer froze
                                the IDE, but I could only parse Comments or base integers, but I had started to under
                                how to generate a lexer properly using JFlex.
                            </p>
                        </aside>
                    </section>
				</section>
                <section class="stack">
                    <section id="interpolation">
                        <h1>Interpolation</h1>
                        <ul>
							<li>
								<a href="#/interpolation-interpolation">Interpolation</a>
							</li>
							<li>
								<a href="#/interpolation-computational-hierarchy">Computational Hierarchy</a>
							</li>
                            <li>
                                <a href="#/interpolation-elixir-native">Elixir Native</a>
                            </li>
                            <li>
                                <a href="#/interpolation-nesting-limit">Nesting Limit</a>
                            </li>
                            <li>
                                <a href="#/interpolation-jflex">JFlex</a>
                            </li>
                            <li>
                                <a href="#/interpolation-v0.0.3">v0.0.3</a>
                            </li>
                        </ul>
                    </section>
					<section id="interpolation-interpolation">
						<h1>Interpolation</h1>
						<pre><code class="elixir" data-trim>
iex> greeting = "Hello #{"W#{"or"}ld"}"
"Hello World"
iex> tuple = "A tuple #{inspect {"Containing an #{:interpolated} string"}}"
"A tuple {\"Containing an interpolated string\"}"
						</code></pre>
						<ul>
							<li>
								Starts with <code>#{</code> and ends with <code>}</code>
							</li>
							<li>
								Valid in Char Lists, Strings, and (interpolating) Sigils
							</li>
							<li>
								Recursive
							</li>
						</ul>
						<aside class="notes">
							<p>
								Add support for interpolation was tricky.  At first glance the hash opening curly and
								closing curly that surround interpolation should work just curly braces in a language
								like C or Java, but the braces in C or Java can just be lexed and the parser can decide
								about whether they are matched.  In languages like Ruby or Elixir that support
								interpolation, whether the you're parsing fragments for the string, char list or sigil
								or if you're in normal code needs to be tracked as fragments will be syntax highlighted
								and parsed differently than normal code.  Finally, code inside interpolation can
								itself have strings, char lists, or sigil that also contain interpolation, recursively.
							</p>
							<p>
								This recursion means that a non-deterministic finite automaton as generated by JFlex
								can no longer parser Elixir!
							</p>
						</aside>
					</section>
					<section id="interpolation-computational-hierarchy">
						<h1>Computational Heirarchy</h1>
						<table>
							<thead>
							<tr>
								<th>Language Class</th>
								<th>Computational Model</th>
								<th>Example</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>Regular</td>
								<td>Finite Automaton/State Machine</td>
								<td>Multiples of 3 in binary</td>
							</tr>
							<tr>
								<td>Context-Free</td>
								<td>Pushdown Automaton</td>
								<td>Balanced Parentheses</td>
							</tr>
							<tr>
								<td>Decidable</td>
								<td>(Always-halting) Turing machine</td>
								<td><code>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup></code></td>
							</tr>
							<tr>
								<td>Semidecidable</td>
								<td>Turing machine</td>
								<td>Halting Problem</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Finite Automatons can lex regular languages, which are languages that match formal
								regular expressions.  Formal regular expression only allow pipe (<code>|</code>) for or,
								parentheses (<code>()</code>) for grouping, and asterisk (<code>*</code>) for Kleene
								star, which means zero or more.  They also can have question mark (<code>?</code>) to
								mean zero or one, if they can't use a symbol for no input, which would be lowercase
								epsilon formally.
							</p>
							<p>
								Context-free languages are a step above regular expressions and can be lexed by pushdown
								automatons, which have a stack for keeping track of state.  A pushdown automaton can use
								the current state along with the current input to decide whether parentheses are matched
								by pushing opening parentheses onto a stack and popping on closing parentheses.  If
								you try to pop when the stack is empty, then you have an unmatched closing parenthesis
								and if the string ends with a non-empty stack then you have an unmatched opening
								parenthesis.
							</p>
							<p>
								You may be thinking, "Wait! I know I can match parentheses with a regex in Ruby or Perl!"
								Well, you can, but this is because the back references to previous groups supported
								in Ruby with slash g (<code>\g</code>) and question mark R in Perl and Perl-Compatible
								Regular Expressions (<code>?R</code>).  This feature is not actually part of formal
								regular expressions and actually promotes extend regular expressions to pushdown
								automaton.
							</p>
							<p>
								When writing compilers and IDEs, designers have to care about the computational hierarchy
								because performance guarantees get fuzzy and get more complex until you hit
								semidecidable and Turing machines, which may just spin forever on bad input.
							</p>
						</aside>
					</section>
					<section id="interpolation-elixir-native" style="font-size: 85%">
						<h1>Elixir Native Interpolation</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L234-L529">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang" data-trim>
tokenize([$"|T], Line, Scope, Tokens) ->
  handle_strings(T, Line, $", Scope, Tokens);
tokenize([$'|T], Line, Scope, Tokens) ->
  handle_strings(T, Line, $', Scope, Tokens);

handle_strings(T, Line, H, Scope, Tokens) ->
  case elixir_interpolation:extract(Line, Scope, true, T, H) of
    {error, Reason} ->
      interpolation_error(Reason, [H|T], Tokens, " (for string starting at line ~B)", [Line]);
    {NewLine, Parts, [$:|Rest]} when ?is_space(hd(Rest)) ->
      Unescaped = unescape_tokens(Parts),
      Key = case Scope#elixir_tokenizer.existing_atoms_only of
        true  -> kw_identifier_safe;
        false -> kw_identifier_unsafe
      end,
      tokenize(Rest, NewLine, Scope, [{Key, Line, Unescaped}|Tokens]);
    {NewLine, Parts, Rest} ->
      Token = {string_type(H), Line, unescape_tokens(Parts)},
      tokenize(Rest, NewLine, Scope, [Token|Tokens])
  end.
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_interpolation.erl#L39-L50">
									<code>lib/elixir/src/elixir_interpolation.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang" data-trim>
extract(Line, Scope, true, [$#, ${|Rest], Buffer, Output, Last) ->
  Output1 = build_string(Line, Buffer, Output),

  case elixir_tokenizer:tokenize(Rest, Line, Scope) of
    {error, {EndLine, _, "}"}, [$}|NewRest], Tokens} ->
      Output2 = build_interpol(Line, Tokens, Output1),
      extract(EndLine, Scope, true, NewRest, [], Output2, Last);
    {error, Reason, _, _} ->
      {error, Reason};
    {ok, _EndLine, _} ->
      {error, {string, Line, "missing interpolation terminator:}", []}}
  end;
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In native Elixir, elixir tokenizer colon tokenize slash four
								(<code>elixir_tokenizer:tokenize/4</code>) calls handle strings slash 5
								(<code>handle_strings/5</code>, which calls elixir interpolation colon
								extract, which calls elixir tokenizer colon tokenizer slash 3
								(<code>elixir_tokenizer:tokenize/3</code>), which calls slash 4, meaning the native
								lexer uses normal Erlang recursion.
							</p>
							<p>
								Note: the recursive call to tokenize is an argument to case, so
								interpolation handling is not tail-recursive so if you got cheeky you could blow the
								stack with enough levels of nested interpolation.
							</p>
						</aside>
					</section>
					<section id="interpolation-nesting-limit">
						<h1>Interpolation Nesting Limit</h1>
						<pre><code class="elixir stretch" data-trim style="font-size: 160%; line-height: 100%;">
levels = 10_000_000
open = Stream.repeatedly(fn -> ~S|" #{| end) |>
       Enum.take(levels) |>
       Enum.join; nil
close = Stream.repeatedly(fn -> ~S|} "| end) |>
        Enum.take(levels) |>
        Enum.join; nil
:ok = "#{open}#{close}" |>
      String.to_char_list |>
      :elixir_tokenizer.tokenize(0, []) |>
      elem(0)
						</code></pre>
						<aside class="notes">
							<p>
								That being said, although 10 million levels of nesting took a long time to run and ate
                                all my memory, I wasn't able to actually hit a stack limit on my Mac Book Pro.
							</p>
						</aside>
					</section>
					<section id="interpolation-jflex">
						<h1>JFlex Interpolation</h1>
						<figure>
							<figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.0.3/src/org/elixir_lang/Elixir.flex">
                                    <code>src/org/elixir_lang/Elixr.flex</code>
                                </a>
							</figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 165%; line-height: 100%;">
%{
  private java.util.Stack&lt;Integer&gt; lexicalStateStack = new java.util.Stack&lt;Integer&gt;();
%}

&lt;YYINITIAL&gt; {
  {DOUBLE_QUOTES}  { lexicalStateStack.push(BODY);
                     yybegin(DOUBLE_QUOTED_STRING);
                     return ElixirTypes.DOUBLE_QUOTES; }
}

&lt;DOUBLE_QUOTED_STRING&gt; {
  {INTERPOLATION_START} { lexicalStateStack.push(yystate());
                          yybegin(INTERPOLATION);
                          return ElixirTypes.INTERPOLATION_START; }
  {DOUBLE_QUOTES}       { int previousLexicalState = lexicalStateStack.pop();
                          yybegin(previousLexicalState);
                          return ElixirTypes.DOUBLE_QUOTES; }
}

&lt;BODY, INTERPOLATION&gt; {
  {DOUBLE_QUOTES} { lexicalStateStack.push(yystate());
                    yybegin(DOUBLE_QUOTED_STRING);
                    return ElixirTypes.DOUBLE_QUOTES; }
}

&lt;INTERPOLATION&gt; {
  {INTERPOLATION_END} { int previousLexicalState = lexicalStateStack.pop();
                        yybegin(previousLexicalState);
                        return ElixirTypes.INTERPOLATION_END; }
}
                            </code></pre>
						</figure>
						<aside class="notes">
							<p>
								JFlex's flex DSL only supports creating finite automaton, so how did I enhance the
								generated parser so it was a pushdown automaton?  I added a manually managed stack
								in the Java code that I can run on each rule match.
							</p>
                            <p>
                                The Java code at the top in percent curly braces is injected directly into the generated
                                parser.  It sets up an integer stack to track the current lexical state.
                            </p>
                            <p>
                                If the lexer hits a non-escaped double quote, it enters the
                                <code>DOUBLE_QUOTED_STRING</code> state, which treats the hash curly brace
                                (<code>#{</code>) of the interpolation start token special: it pushes the current state
                                on top the stack and begins the <code>INTERPOLATION</code> state.
                            </p>
                            <p>
                                The <code>INTERPOLATION</code> and <code>BODY</code> states are the same except
                                that <CODE>INTERPOLATION</CODE> needs to pop and restore the previous lexical state
                                if the closing curly brace (<code>}</code>) for <code>INTERPOLATION</code> is hit.
                            </p>
						</aside>
					</section>
                    <section id="interpolation-v0.0.3">
                        <h1>v0.0.3</h1>
                        <table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
							</thead>
							<tbody>
                            <tr>
								<td>2014&#8209;08&#8209;08</td>
								<td>5</td>
								<td>12</td>
								<td>10</td>
								<td>43</td>
								<td>2.00</td>
							</tr>
                            </tbody>
                        </table>
                        <ul>
                            <li>
                                <p>Enhancements</p>
                                <ul>
                                    <li>Char Lists</li>
                                    <li>
                                        <p>Strings</p>
                                        <ul>
                                            <li>Interpolation</li>
                                            <li>Escaped <code>#</code></li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">
                            <p>
                                In 5 days I was able to figure out how to convert the JFlex finite automaton
                                to a pushdown automaton by following the formal definition that pushdown automaton
                                just is a finite automaton with a stack that it can consult for transition logic.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="sigil">
                        <h1>Sigil</h1>
                        <ul>
                            <li>
                                <a href="#/sigil-elixir-native">Elixir Native</a>
                            </li>
                            <li>
                                <a href="#/sigil-highlighting-dimensions">Highlighting Dimensions</a>
                            </li>
                            <li>
                                <a href="#/sigil-tilde">Tilde</a>
                            </li>
                            <li>
                                <a href="#/sigil-name">Name</a>
                            </li>
                            <li>
                                <a href="#/sigil-promoter">Promoter</a>
                            </li>
                            <li>
                                <a href="#/sigil-terminator">Terminator</a>
                            </li>
                            <li>
                                <a href="#/sigil-modifiers">Modifiers</a>
                            </li>
                            <li>
                                <a href="#/sigil-parser">Parser</a>
                            </li>
                            <li>
                                <a href="#/sigil-v0.1.0">v0.1.0</a>
                            </li>
                        </ul>
                    </section>
                    <section id="sigil-elixir-native">
                        <h1>Native Elixir</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L141-L158">
                                    <code>lib/elixir/src/elixir_tokenizer.erl</code>
                                </a>
                                <pre><code class="erlang stretch" data-trim style="font-size: 125%; line-height: 100%">
tokenize([$~,S,H,H,H|T] = Original, Line, Scope, Tokens) when ?is_quote(H), ?is_upcase(S) orelse ?is_downcase(S) ->
  case extract_heredoc_with_interpolation(Line, Scope, ?is_downcase(S), T, H) of
    {ok, NewLine, Parts, Rest} ->
      {Final, Modifiers} = collect_modifiers(Rest, []),
      tokenize(Final, NewLine, Scope, [{sigil, Line, S, Parts, Modifiers}|Tokens]);
    {error, Reason} ->
      {error, Reason, Original, Tokens}
  end;

tokenize([$~,S,H|T] = Original, Line, Scope, Tokens) when ?is_sigil(H), ?is_upcase(S) orelse ?is_downcase(S) ->
  case elixir_interpolation:extract(Line, Scope, ?is_downcase(S), T, sigil_terminator(H)) of
    {NewLine, Parts, Rest} ->
      {Final, Modifiers} = collect_modifiers(Rest, []),
      tokenize(Final, NewLine, Scope, [{sigil, Line, S, Parts, Modifiers}|Tokens]);
    {error, Reason} ->
      Sigil = [$~,S,H],
      interpolation_error(Reason, Original, Tokens, " (for sigil ~ts starting at line ~B)", [Sigil, Line])
  end;
                                </code></pre>
                            </figcaption>
                        </figure>
                        <aside class="notes">
                            <p>
                                Native Elixir only cares whether the sigil is a heredoc (in the top clause) or a line
                                (in the bottom clause).
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-highlighting-dimensions">
                        <h1>Highlighting Dimensions</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>Dimension</th>
                                <th>Values</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Name</td>
                                <td>
                                    <ul>
                                        <li>CharListSigil</li>
                                        <li>Regex</li>
                                        <li>Sigil</li>
                                        <li>StringSigil</li>
                                        <li>Words</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Interpolation</td>
                                <td>
                                    <ul>
                                        <li>Interpolated</li>
                                        <li>Literal</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>Lines</td>
                                <td>
                                    <ul>
                                        <li>Heredoc</li>
                                        <li>Lined</li>
                                    </ul>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                For an IDE, it's not enough to detect that the syntax is correct for the sigils, ideally
                                we'd want each sigil to highlight in a different color and the highlighting needs to
                                be different for each literal vs interpolated so that users can spot if an escape
                                escape or interpolation is used in a non-interpolating literal.
                            </p>
                            <p>
                                These considerations mean I needed the tokenizer to produce different tokens for each
                                combination of sigil name and interpolated vs literal.  There is a 3rd dimension of
                                whether the sigil is a line or herdoc, which is important since leading spaces
                                are significant and can't be treated as simple, ignored, whitespace in heredocs.
                            </p>
                            <p>
                                The Sigil name is used for any generic sigil that may be in a user library that uses a
                                character for a name not used by the Kernel.
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-tilde">
                        <h1>Tilde</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/71c39c30850b54574f0762cc80af3355bc9ef8c9/src/org/elixir_lang/Elixir.flex#L296-L297">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 395%; line-height: 100%">
&lt;BODY, INTERPOLATION&gt; {
  {TILDE} { pushAndBegin(SIGIL);
            return ElixirTypes.TILDE; }
}
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The flex rule starts the same as tokenize's pattern match with tilde (<code>~</code>),
                                but since JFlex only allow tokens that use the entire text of the match, I need to match
                                the leading tilde and then jump to another state so I can match the sigil name as a
                                separate token.
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-name">
                        <h1>Name</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/71c39c30850b54574f0762cc80af3355bc9ef8c9/src/org/elixir_lang/Elixir.flex#L397-L401">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 350%; line-height: 100%">
SIGIL_NAME = [A-Za-z]

&lt;SIGIL&gt; {
  {SIGIL_NAME} { nameSigil(yytext());
                 yybegin(NAMED_SIGIL);
                 return sigilNameType(); }
}
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The sigil state only accepts single alphabetical characters and then jumps to the next
                                state so that the single name can be a separate token.
                            </p>
                            <p>
                                nameSigil adds the character to the stack state and then sigilNameType pulls the token
                                type for that character back out.  This helps unify the API for the pre-defined sigil
                                names and the catchall for user defined sigils.
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-promoter">
                        <h1>Promoter</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/71c39c30850b54574f0762cc80af3355bc9ef8c9/src/org/elixir_lang/Elixir.flex#L183-L395">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                                <pre><code class="stretch" data-trim style="font-size: 190%; line-height: 100%">
SIGIL_BRACES_PROMOTER = "{"
SIGIL_BRACKETS_PROMOTER = "["
SIGIL_CHEVRONS_PROMOTER = "<"
SIGIL_DOUBLE_QUOTES_PROMOTER = "\""
SIGIL_FORWARD_SLASH_PROMOTER = "/"
SIGIL_PARENTHESES_PROMOTER = "("
SIGIL_PIPE_PROMOTER = "|"
SIGIL_SINGLE_QUOTES_PROMOTER = "'"

SIGIL_PROMOTER = {SIGIL_BRACES_PROMOTER} |
                 {SIGIL_BRACKETS_PROMOTER} |
                 {SIGIL_CHEVRONS_PROMOTER} |
                 {SIGIL_DOUBLE_QUOTES_PROMOTER} |
                 {SIGIL_FORWARD_SLASH_PROMOTER} |
                 {SIGIL_PARENTHESES_PROMOTER} |
                 {SIGIL_PIPE_PROMOTER} |
                 {SIGIL_SINGLE_QUOTES_PROMOTER}

&lt;NAMED_SIGIL&gt; {
  {SIGIL_HEREDOC_PROMOTER} { setPromoter(yytext());
                             yybegin(GROUP_HEREDOC_START);
                             return promoterType(); }
  {SIGIL_PROMOTER}         { setPromoter(yytext());
                             yybegin(GROUP);
                             return promoterType(); }
}
                                </code></pre>
                            </figcaption>
                        </figure>
                        <aside class="notes">
                            <p>
                                Unlike Strings, which only use double quotes or Char List that only use single quotes,
                                any sigil name can use any promoter, which is why the NAME_SIGIL state differs from
                                the normal quote and start quote rule.
                            </p>
                            <p>
                                If anyone has better terminology for this let me know.  I picked promoter because
                                terminator was used in the native implementation and the oppose of a terminator in a DNA
                                sequence is a promoter.
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-terminator">
                        <h1>Terminator</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/71c39c30850b54574f0762cc80af3355bc9ef8c9/src/org/elixir_lang/Elixir.flex#L326-L355">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                                <pre><code class="stretch" data-trim style="font-size: 165%; line-height: 100%">
&lt;GROUP&gt; {
  {GROUP_TERMINATOR} {
                       if (isTerminator(yytext())) {
                         org.elixir_lang.lexer.StackFrame stackFrame = pop();
                         yybegin(stackFrame.getLastLexicalState());
                         return stackFrame.terminatorType();
                       } else {
                         return fragmentType();
                       }
                     }
  {EOL}|.            { return fragmentType(); }

}

&lt;GROUP_HEREDOC_END&gt; {
  {GROUP_HEREDOC_TERMINATOR} {
                               if (isTerminator(yytext())) {
                                 if (isSigil()) {
                                   yybegin(SIGIL_MODIFIERS);
                                   return terminatorType();
                                 } else {
                                   org.elixir_lang.lexer.StackFrame stackFrame = pop();
                                   yybegin(stackFrame.getLastLexicalState());
                                   return stackFrame.terminatorType();
                                 }
                               } else {
                                 handleInState(GROUP_HEREDOC_LINE_BODY);
                               }
                             }
}
                                </code></pre>
                            </figcaption>
                        </figure>
                        <aside class="notes">
                            <p>
                                The regular expression to end a group or heredoc unfortunately has to contain all
                                <em>potential</em> terminators, not just the correct one that matches the active
                                promoter because the regular expression can't be dynamic based on the stack since
                                I added the stack to JFlex.
                            </p>
                            <p>
                                So, when a potential terminator is matched, is terminator (<code>isTerminator</code>)
                                checks that the text matches the promoter on the stack.  If it does match, then
                                the group or heredoc ends, but if it doesn't match then the potential terminator is
                                just treated as non-special text for the sigil, string, or char list.
                            </p>
                            <p>
                                When the terminator matches the promoter, there also needs to be check if this is a
                                sigil because unlike Char Lists or Strings, sigils can have characters after the
                                terminator to modify the sigil behavior
                            </p>
                        </aside>
                    </section>

                    <section id="sigil-modifiers">
                        <h1>Modifiers</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/71c39c30850b54574f0762cc80af3355bc9ef8c9/src/org/elixir_lang/Elixir.flex#L39-L407">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 200%; line-height: 100%">
%{
  private void handleInState(int nextLexicalState) {
    yypushback(yylength());
    yybegin(nextLexicalState);
  }
}

SIGIL_MODIFIER = [a-z]

&lt;SIGIL_MODIFIERS&gt; {
  {SIGIL_MODIFIER} { return ElixirTypes.SIGIL_MODIFIER; }
  {EOL}|.          { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                     handleInState(stackFrame.getLastLexicalState()); }
}
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The sigil modifiers (<code>SIGIL_MODIFIERS</code>) state uses an idiom that would
                                become common in elixir dot flex (<code>Elixir.flex</code>): the last rule in a
                                state matches either E-O-L or any character so that it can be handled in another
                                state.  Using this idiom, I was able to avoid duplicating rules in descendant state
                                and instead just poping the stack and going back to <code>BODY</code> or
                                <code>INTERPOLATION</code>.
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-parser">
                        <h1>Parser</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/71c39c30850b54574f0762cc80af3355bc9ef8c9/src/org/elixir_lang/Elixir.bnf#L24-L102">
                                    <code>src/org/elixir_lang/Elixir.bnf</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 90%; line-height: 100%">
private interpolatedCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListBody CHAR_LIST_SIGIL_TERMINATOR
private interpolatedCharListBody ::= (interpolation | CHAR_LIST_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedHeredocCharListSigil ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                             interpolatedCharListBody
                                             CHAR_LIST_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                     interpolatedRegexBody
                                     REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedHeredocSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedSigilBody
                                     SIGIL_HEREDOC_PROMOTER SIGIL_MODIFIER*
private interpolatedHeredocStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                           interpolatedStringBody
                                           STRING_SIGIL_HEREDOC_TERMINATOR
private interpolatedHeredocWords ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                     interpolatedWordsBody
                                     WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegex ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private interpolatedRegexBody ::= (interpolation | REGEX_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedSigil ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private interpolatedSigilBody ::= (interpolation | SIGIL_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedStringSigil ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringBody STRING_SIGIL_TERMINATOR
private interpolatedStringBody ::=  (interpolation | STRING_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private interpolatedWordsBody ::= (interpolation | WORDS_FRAGMENT | VALID_ESCAPE_SEQUENCE)*
private literalCharListBody ::= CHAR_LIST_FRAGMENT*
private literalCharListSigil ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListBody CHAR_LIST_SIGIL_TERMINATOR
private literalHeredocRegex ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                                literalRegexBody
                                REGEX_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                                literalSigilBody
                                SIGIL_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalHeredocStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                      literalStringBody
                                      STRING_SIGIL_HEREDOC_TERMINATOR
private literalHeredocWords ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                                literalWordsBody
                                WORDS_HEREDOC_TERMINATOR SIGIL_MODIFIER*
private literalRegex ::= TILDE LITERAL_SIGIL_NAME REGEX_PROMOTER literalRegexBody REGEX_TERMINATOR SIGIL_MODIFIER*
private literalRegexBody ::= REGEX_FRAGMENT*
private literalSigil ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilBody SIGIL_TERMINATOR SIGIL_MODIFIER*
private literalSigilBody ::= SIGIL_FRAGMENT*
private literalStringBody ::= STRING_FRAGMENT*
private literalStringSigil ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringBody STRING_SIGIL_TERMINATOR
private literalWords ::=  TILDE LITERAL_SIGIL_NAME WORDS_PROMOTER literal WORDS_TERMINATOR SIGIL_MODIFIER*
private literalWordsBody ::= WORDS_FRAGMENT*
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                I was able to eliminate redundant code in the lexer by moving it to Java, but I couldn't
                                figure out how to do the same for the BNF for the parser, so there had to be separate
                                rule for each of the 20 combinations.
                            </p>
                            <p>
                                Keep all the rule pattern for heredocs and lines in sync would prove difficult and lead
                                to a few missed-update bugs.
                            </p>
                        </aside>
                    </section>
                    <section id="sigil-v0.1.0">
                        <h1>v0.1.0</h1>
                        <table>
                            <thead>
                            <tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>2014&#8209;09&#8209;13</td>
								<td>36</td>
								<td>48</td>
								<td>64</td>
								<td>107</td>
								<td>1.78</td>
                            </tr>
                            </tbody>
                        </table>
                        <ul>
                            <li>
                                <p>Enhancements</p>
                                <ul>
                                    <li>
                                        Literal and interpolated sigils with highlighting
                                        <ul>
                                            <li>Char List Sigils (<code>~c</code> and <code>~C</code>) highlighted as 'Char List' in Settings.</li>
                                            <li>
                                                Regex Sigils (<code>~r</code> and <code>~R</code>) highlighted as 'Sigil' in Settings.
                                                <strong>NOTE: RegExp syntax is not internally highlighted yet</strong>
                                            </li>
                                            <li>String Sigils (<code>~s</code> and <code>~S</code> highlighted as 'String' in Settings.</li>
                                            <li>Word Sigils (<code>~w</code> and <code>~W</code> highlighted as 'Sigil' in Settings.</li>
                                            <li>Custom Sigils highlighted as 'Sigil' in Settings.</li>
                                            <li>Modifiers are highlighted on Regex, Word, and Custom while modifiers aren't allowed on CharList and String Sigils.</li>
                                        </ul>
                                </ul>
                                <p>Bug Fixes</p>
                                <ul>
                                    <li>Single-quoted strings are correctly referred to as 'Character List' now instead of 'String' in Settings.</li>
                                    <li>Double-quoted strings are correctly referred to as 'String' now instead of 'Interpolated String' in Settings.</li>
                                    <li>Non-Heredoc CharLists and Strings can be multiline.</li>
                                    <li>CharLists and Strings support interpolation and escape sequences.</li>
                                </ul>
                            </li>
                        </ul>
                        <aside class="notes">
                            <p>
                                v0.1.0 also included some bug fixes where my Ruby brain had leaked into what was allowed
                                in single and double quotes in Elixir.
                            </p>
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section id="atoms">
                        <h1>Atoms</h1>
                        <ul>
							<li>
								<p>Elixir Native</p>
								<ul>
									<li>
										<a href="#/atoms-elixir-native-literal">Literal</a>
									</li>
									<li>
										<a href="#/atoms-elixir-native-fragments">Fragments</a>
									</li>
								</ul>
							</li>
							<li>
								<a href="#/atoms-colon">Colon</a>
							</li>
							<li>
								<a href="#/atoms-start">Start</a>
							</li>
							<li>
								<p>Elixir Native</p>
								<ul>
									<li>
										<a href="#/atoms-elixir-native-quoted">Quoted</a>
									</li>
									<li>
										<a href="#/atoms-elixir-native-operators">Operators</a>
									</li>
								</ul>
							</li>
							<li>
								<a href="#/atoms-parser">Parser</a>
							</li>
							<li>
                                <a href="#/atoms-v0.1.2">
                                    v0.1.2
                                </a>
                            </li>
                        </ul>
                    </section>
                    <section id="atoms-elixir-native-literal">
                        <h1>Elixir Native</h1>
						<h2>Literal</h2>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L254-L771">
                                    <code>lib/elixir/src/elixir_tokenizer.erl</code>
                                </a>
                            </figcaption>
                            <pre><code class="erlang stretch" data-trim style="font-size: 180%; line-height: 100%">
tokenize([$:,T|String] = Original, Line, Scope, Tokens) when ?is_atom_start(T) ->
  {Rest, Part} = tokenize_atom([T|String], []),
  case unsafe_to_atom(Part, Line, Scope) of
    {ok, Atom} ->
      tokenize(Rest, Line, Scope, [{atom, Line, Atom}|Tokens]);
    {error, Reason} ->
      {error, Reason, Original, Tokens}
  end;

tokenize_atom([H|T], Acc) when ?is_atom(H) ->
  tokenize_atom(T, [H|Acc]);

tokenize_atom([H|T], Acc) when H == $?; H == $! ->
  {T, lists:reverse([H|Acc])};

tokenize_atom(Rest, Acc) ->
  {Rest, lists:reverse(Acc)}.
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                A literal atom is built up as a list of characters that start with colon <code>:</code>.
                            </p>
                            <p>
                                The guards hint that that atom format is not uniform.
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-elixir-native-fragments">
                        <h1>Elixir Native</h1>
						<h2>Fragments</h2>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/include/elixir.hrl#L50-L58">
                                    <code>lib/elixir/include/elixir.hrl</code>
                                </a>
                            </figcaption>
                            <pre><code class="erlang stretch" data-trim style="font-size: 145%; line-height: 100%">
-define(is_digit(S), S >= $0 andalso S =< $9).
-define(is_upcase(S), S >= $A andalso S =< $Z).
-define(is_downcase(S), S >= $a andalso S =< $z).

%% Atoms
-define(is_atom_start(S), ?is_quote(S) orelse ?is_upcase(S) orelse ?is_downcase(S) orelse (S == $_)).
-define(is_atom(S), ?is_identifier(S) orelse (S == $@)).

-define(is_identifier(S), ?is_digit(S) orelse ?is_upcase(S) orelse ?is_downcase(S) orelse (S == $_)).
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                As you can see, atoms need to start with quotes, an underscore or a letter, but
                                the body of can also includes digits and at (<code>@</code>), which is important
                                for node names.  Finally, an atom can optionally end with an exclamation point
                                (<code>!</code>) or question mark (<code>?</code>) to support functions with that name
                                format.
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-colon">
                        <h1>Colon</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/2ce264275c4b307ef21f6e7efa764d69751e1a9a/src/org/elixir_lang/Elixir.flex#L177-L394">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                            </figcaption>
                            <pre><code data-trim>
COLON = :

&lt;BODY, INTERPOLATION&gt; {
  {COLON} { pushAndBegin(ATOM_START);
            return ElixirTypes.COLON; }
}
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                For <code>tokenize</code>, the colon (<code>:</code>) prefixing the atom value is thrown
                                away, but in an IDE, characters must be tokenized since they are editable and take up
                                space, so after tokenizing the colon, elixir dot flex (<code>Elixir.flex</code>) needs
                                to jump to a new state, atom start (<code>ATOM_START</code>)
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-start">
                        <h1>Atom Start</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/2ce264275c4b307ef21f6e7efa764d69751e1a9a/src/org/elixir_lang/Elixir.flex#L113-L375">
                                    <code>src/org/elixir_lang/Elixir.flex</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 120%; line-height: 100%">
ATOM_START = [a-zA-Z_]

&lt;ATOM_START&gt; {
  {ATOM_START}     { yybegin(ATOM_BODY);
                     return ElixirTypes.ATOM_FRAGMENT; }
  {QUOTE_PROMOTER} { /* At the end of the quote, return the state (BODY or INTERPOLATION) before ATOM_START as anything
                        after the closing quote should be handle by the state prior to ATOM_START.  Without this,
                        EOL and WHITESPACE won't be handled correctly */
                     org.elixir_lang.lexer.StackFrame stackFrame = pop();
                     yybegin(stackFrame.getLastLexicalState());
                     startQuote(yytext());
                     return promoterType(); }
  {OPERATOR}       { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                     yybegin(stackFrame.getLastLexicalState());
                     return ElixirTypes.ATOM_FRAGMENT; }
  {EOL}            { return TokenType.BAD_CHARACTER; }
}
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The atom start state (<code>ATOM_START</code>) has rules for literal atoms starting
                                with atom start rule (<code>ATOM_START</code>), quote promoter
                                (<code>QUOTE_PROMOTER</code>) for quoted atoms and <code>OPERATOR</code> for operators
                                as atoms, since they don't follow the normal naming rules for atoms.
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-elixir-native-quoted">
                        <h1>Elixir Native</h1>
						<h2>Quoted</h2>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L241-L252">
                                    <code>lib/elixir/src/elixir_tokenizer.erl</code>
                                </a>
                            </figcaption>
                            <pre><code class="erlang stretch" data-trim style="font-size: 150%; line-height: 100%">
tokenize([$:,H|T] = Original, Line, Scope, Tokens) when ?is_quote(H) ->
  case elixir_interpolation:extract(Line, Scope, true, T, H) of
    {NewLine, Parts, Rest} ->
      Unescaped = unescape_tokens(Parts),
      Key = case Scope#elixir_tokenizer.existing_atoms_only of
        true  -> atom_safe;
        false -> atom_unsafe
      end,
      tokenize(Rest, NewLine, Scope, [{Key, Line, Unescaped}|Tokens]);
    {error, Reason} ->
      interpolation_error(Reason, Original, Tokens, " (for atom starting at line ~B)", [Line])
  end;
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                Similar to how the quote promoter rule jumps to the normal quoting state, tokenize
                                calls elixir interpolation colon extract (<code>elixir_interpolation:extract</code>) to
                                handle the normal quote parsing and then treats it as an atom.
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-elixir-native-operators">
                        <h1>Elixir Native</h1>
						<h2>Operators</h2>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L265-L304">
                                    <code>lib/elixir/src/elixir_tokenizer.erl</code>
                                </a>
                            </figcaption>
                            <pre><code class="erlang stretch" data-trim style="font-size: 155%; line-height: 100%">
tokenize(":..." ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line, Scope, [{atom, Line, '...'}|Tokens]);
tokenize(":<<>>" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line, Scope, [{atom, Line, '<<>>'}|Tokens]);
tokenize(":%{}" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line, Scope, [{atom, Line, '%{}'}|Tokens]);
tokenize(":%" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line, Scope, [{atom, Line, '%'}|Tokens]);
tokenize(":{}" ++ Rest, Line, Scope, Tokens) ->
  tokenize(Rest, Line, Scope, [{atom, Line, '{}'}|Tokens]);

% ## Three Token Operators
tokenize([$:,T1,T2,T3|Rest], Line, Scope, Tokens) when
    ?unary_op3(T1, T2, T3); ?comp_op3(T1, T2, T3); ?and_op3(T1, T2, T3); ?or_op3(T1, T2, T3);
    ?arrow_op3(T1, T2, T3); ?hat_op3(T1, T2, T3) ->
  tokenize(Rest, Line, Scope, [{atom, Line, list_to_atom([T1,T2,T3])}|Tokens]);

% ## Two Token Operators
tokenize([$:,T1,T2|Rest], Line, Scope, Tokens) when
    ?comp_op2(T1, T2); ?rel_op2(T1, T2); ?and_op(T1, T2); ?or_op(T1, T2);
    ?arrow_op(T1, T2); ?in_match_op(T1, T2); ?two_op(T1, T2); ?stab_op(T1, T2);
    ?type_op(T1, T2) ->
  tokenize(Rest, Line, Scope, [{atom, Line, list_to_atom([T1,T2])}|Tokens]);

% ## Single Token Operators
tokenize([$:,T|Rest], Line, Scope, Tokens) when
    ?at_op(T); ?unary_op(T); ?capture_op(T); ?dual_op(T); ?mult_op(T);
    ?rel_op(T); ?match_op(T); ?pipe_op(T); T == $. ->
  tokenize(Rest, Line, Scope, [{atom, Line, list_to_atom([T])}|Tokens]);
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                elixir tokenizer (<code>elixir_tokenizer</code>) is more verbose because it can at best
                                combine patterns of the same
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-parser">
                        <h1>Parser</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L26-L30">
                                    <code>lib/elixir/src/elixir_parser.yrl</code>
                                </a>
                            </figcaption>
                            <pre><code data-trim style="font-size: 185%; line-height: 100%">
Terminals
  number signed_number atom atom_safe atom_unsafe bin_string list_string sigil
                            </code></pre>
                        </figure>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/KronicDeth/intellij-elixir/blob/2ce264275c4b307ef21f6e7efa764d69751e1a9a/src/org/elixir_lang/Elixir.bnf#L24">
                                    <code>src/org/elixir_lang/Elixir.bnf</code>
                                </a>
                            </figcaption>
                            <pre><code data-trim style="font-size: 185%; line-height: 100%">
atom ::= COLON (ATOM_FRAGMENT | quote)
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                In the YECC grammar, atoms can be treated as terminals, meaning they are a single token
                                from the tokenizer because the interpolation for quoted atoms is wrapped in the
                                tokenize for atom.
                            </p>
                            <p>
                                For the Grammar Kit BNF, atoms have to be a composite because the JFlex lexer doesn't
                                backtrack, so any quoted atom just shows up as a quote with a COLON in front.
                            </p>
                        </aside>
                    </section>
                    <section id="atoms-v0.1.2">
                        <h1>v0.1.2</h1>
                        <table>
                            <thead>
                            <tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>2014&#8209;09&#8209;13</td>
								<td>5</td>
								<td>60</td>
								<td>12</td>
								<td>123</td>
								<td>2.50</td>
                            </tr>
                            </tbody>
                        </table>
                        <ul>
                            <li>
                                <p>Enhancements</p>
                                <ul>
                                    <li>
                                        <p>Atoms with highlighting</p>
                                        <ul>
                                            <li>
                                                Atom with double or single quotes to allow interpolation.  Double quotes are highlighted as 'String'
                                                while single quotes are highlighted as 'Char List'.  This may be changed in the future.
                                            </li>
                                            <li>Literal atoms highlighted as 'Atom'.</li>
                                            <li>Operator atoms highlighted as 'Atom'.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                </section>
                <section class="stack">
                    <section id="matched-expressions">
                        <h1>Matched Expressions</h1>
                        <ul>
                            <li>
                                <a href="#/matched-expressions-call-syntaxes">Call Syntaxes</a>
                            </li>
                            <li>
                                <a href="#/matched-expressions-yecc-associativity-and-precedence">YECC Associativity and Precedence</a>
                            </li>
                            <li>
                                <a href="#/matched-expressions-grammar-kit-precedence">Grammar Kit Precedence</a>
                            </li>
                            <li>
								<a href="#/matched-expressions-grammar-kit-associativity">Grammar Kit Associativity</a>
                            </li>
							<li>
								<a href="#/matched-expressions-grammars">Grammars</a>
							</li>
							<li>
								<a href="#/matched-expressions-parsing-direction">Parsing Direction</a>
							</li>
							<li>
								<a href="#/matched-expressions-yecc-vs-grammar-kit-generated-code">YECC vs Grammar Kit Generated Code</a>
							</li>
							<li>
								<p>Pratt Parsing</p>
								<ul>
									<li>
										<a href="#/matched-expressions-pratt-parsing-head">Head</a>
									</li>
									<li>
										<a href="#/matched-expressions-pratt-parsing-tail">Tail</a>
									</li>
								</ul>
							</li>
							<li>
								<a href="#/matched-expressions-associativity">Associativity</a>
							</li>
							<li>
								<a href="#/matched-expressions-v0.2.0">v0.2.0</a>
							</li>
                        </ul>
                    </section>
                    <section id="matched-expressions-call-syntaxes">
                        <h1>Call Syntaxes</h1>
                        <table>
                            <thead>
                            <tr>
                                <th>
                                    <code>elixir_parser.yrl</code>
                                </th>
                                <th>
                                    <code>Elixir.bnf</code>
                                </th>
                                <th>Description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L113-L122">
                                        <code>matched_expr</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/0f8e974c4ec965c2f06653c8bddce7ddd3e80335/src/org/elixir_lang/Elixir.bnf#L191-L211">
                                        <code>matchedExpression</code>
                                    </a>
                                </td>
                                <td>
                                    With Parentheses*
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L124-L125">
                                        <code>no_parens_expr</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf#L248-L259">
                                        <code>unqualifiedNoParenthesesManyArgumentsCall</code>
                                    </a>
                                </td>
                                <td>
                                    Without Parentheses
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L127-L133">
                                        <code>unmatched_expr</code>
                                    </a>
                                </td>
                                <td>
                                    <a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf#L2335-L2370">
                                        <code>unmatchedExpression</code>
                                    </a>
                                </td>
                                <td>
                                    With Do Block
                                </td>
                            </tr>
                            </tbody>
                        </table>
                        <aside class="notes">
                            <p>
                                Elixir parser dot yurl (<code>elixir_parser.yrl</code>) explains that there are 3 call
                                syntaxes in Elixir: matched, no parentheses, and unmatched.
                            </p>
                            <p>
                                Matched also implies parentheses, except for one argument no parentheses calls because
                                they can be chained together, which looks a lot like Haskell.
                            </p>
                        </aside>
                    </section>
                    <section id="matched-expressions-yecc-associativity-and-precedence">
                        <h1>YECC associativity and precedence</h1>
                        <figure>
                            <figcaption>
                                <a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L44-L71">
                                    <code>lib/elixir/src/elixir_parser.yrl</code>
                                </a>
                            </figcaption>
                            <pre><code class="stretch" data-trim style="font-size: 175%; line-height: 100%">
%% Changes in ops and precedence should be reflected on lib/elixir/lib/macro.ex
%% Note though the operator => in practice has lower precedence than all others,
%% its entry in the table is only to support the %{user | foo => bar} syntax.
Left       5 do.
Right     10 stab_op_eol.     %% ->
Left      20 ','.
Nonassoc  30 capture_op_eol.  %% &
Left      40 in_match_op_eol. %% <-, \\ (allowed in matches along =)
Right     50 when_op_eol.     %% when
Right     60 type_op_eol.     %% ::
Right     70 pipe_op_eol.     %% |
Right     80 assoc_op_eol.    %% =>
Right     90 match_op_eol.    %% =
Left     130 or_op_eol.       %% ||, |||, or, xor
Left     140 and_op_eol.      %% &&, &&&, and
Left     150 comp_op_eol.     %% ==, !=, =~, ===, !==
Left     160 rel_op_eol.      %% <, >, <=, >=
Left     170 arrow_op_eol.    %% < (op), (op) > (e.g |>, <<<, >>>)
Left     180 in_op_eol.       %% in
Right    200 two_op_eol.      %% ++, --, .., <>
Left     210 add_op_eol.      %% + (op), - (op)
Left     220 mult_op_eol.     %% * (op), / (op)
Left     250 hat_op_eol.      %% ^ (op) (e.g ^^^)
Nonassoc 300 unary_op_eol.    %% +, -, !, ^, not, ~~~
Left     310 dot_call_op.
Left     310 dot_op.          %% .
Nonassoc 320 at_op_eol.       %% @
Nonassoc 330 dot_identifier.
                            </code></pre>
                        </figure>
                        <aside class="notes">
                            <p>
                                The YECC format has a section for declaring both the associativity and precedence of
                                operators.  The operator table doesn't completely reflect the precedence of all operator
                                combinations because there are some precedence swaps, such as for `not in`.
                            </p>
							<p>
								<code>Nonassoc</code> is used for non-binary, prefix operators that don't have
								associativity rules.
							</p>
							<p>
								Higher precedence operators (with greater numbers) in the table can act as arguments
								to the lower precedence operators, so and operators like double ampersand
								(<code>&&</code>) take comparison operation using comparison operators like double
								equals (<code>==</code>) at arguments.
							</p>
                        </aside>
                    </section>
                    <section id="matched-expressions-grammar-kit-precedence">
						<h1>Grammar Kit Precedence</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/src/org/elixir_lang/Elixir.bnf#L191-L211">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 230%; line-height: 100%">
matchedExpression ::= matchedExpressionCaptureOperation |
                      matchedExpressionInMatchOperation |
                      matchedExpressionWhenOperation |
                      matchedExpressionTypeOperation |
                      matchedExpressionPipeOperation |
                      matchedExpressionMatchOperation |
                      matchedExpressionOrOperation |
                      matchedExpressionAndOperation |
                      matchedExpressionComparisonOperation |
                      matchedExpressionRelationalOperation |
                      matchedExpressionArrowOperation |
                      matchedExpressionInOperation |
                      matchedExpressionTwoOperation |
                      matchedExpressionAdditionOperation |
                      matchedExpressionMultiplicationOperation |
                      matchedExpressionHatOperation |
                      matchedExpressionUnaryOperation |
                      matchedExpressionDotOperation |
                      matchedExpressionAtOperation |
                      identifierExpression |
                      accessExpression
							</code></pre>
						</figure>
                        <aside class="notes">
                            <p>
                                There isn't a unified associativity and precedence table for Grammar Kit's BNF.
                                Instead, the precedence is order of choice in parent expression, which is also the
								argument expression.
                            </p>
							<p>
								Instead of stating the precedence of the operators as is done in YECC, the precedence
								of operations using those operator is done in Grammar Kit.
							</p>
                        </aside>
                    </section>
					<section id="matched-expressions-grammar-kit-associativity">
						<h1>Grammar Kit Associativity</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/src/org/elixir_lang/Elixir.bnf#L214-L232">
									<code>src/org/elixir/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 115%; line-height: 100%">
matchedExpressionAdditionOperation ::= matchedExpression DUAL_OPERATOR EOL* matchedExpression
matchedExpressionAndOperation ::= matchedExpression EOL* AND_OPERATOR EOL* matchedExpression
matchedExpressionArrowOperation ::= matchedExpression EOL* ARROW_OPERATOR EOL* matchedExpression
matchedExpressionAtOperation ::= AT_OPERATOR EOL* matchedExpression
matchedExpressionCaptureOperation ::= CAPTURE_OPERATOR EOL* matchedExpression
matchedExpressionComparisonOperation ::= matchedExpression EOL* COMPARISON_OPERATOR EOL* matchedExpression
matchedExpressionDotOperation ::= matchedExpression EOL* DOT_OPERATOR EOL* matchedExpression
matchedExpressionHatOperation ::= matchedExpression EOL* HAT_OPERATOR EOL* matchedExpression
matchedExpressionInMatchOperation ::= matchedExpression EOL* IN_MATCH_OPERATOR EOL* matchedExpression
matchedExpressionInOperation ::= matchedExpression EOL* IN_OPERATOR EOL* matchedExpression
matchedExpressionMatchOperation ::= matchedExpression EOL* MATCH_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionMultiplicationOperation ::= matchedExpression EOL* MULTIPLICATION_OPERATOR EOL* matchedExpression
matchedExpressionOrOperation ::= matchedExpression EOL* OR_OPERATOR EOL* matchedExpression
matchedExpressionPipeOperation ::= matchedExpression EOL* PIPE_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionRelationalOperation ::= matchedExpression EOL* RELATIONAL_OPERATOR EOL* matchedExpression
matchedExpressionTwoOperation ::= matchedExpression EOL* TWO_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionTypeOperation ::= matchedExpression EOL* TYPE_OPERATOR EOL* matchedExpression { rightAssociative = true }
matchedExpressionUnaryOperation ::= (DUAL_OPERATOR | UNARY_OPERATOR) EOL* matchedExpression
matchedExpressionWhenOperation ::= matchedExpression EOL* WHEN_OPERATOR EOL* matchedExpression { rightAssociative = true }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, the pattern for binary operations are matched expression
								(<code>matchedExpression</code>) on either side of the actual operator token with
								optional newlines around the operator.
							</p>
							<p>
								Left associativity is assumed by default, so right associativity is indicated with
								right associative equals true (<code>rightAssociative = true</code>) in the braces after
								the rule.
							</p>
							<p>
								You may have noticed that these rules appear to be recursive: on the previous slide,
								matched expression (<code>matchedExpression</code>) was defined as the ordered choice
								of all the operations on this on this slide, but all the operations use matched
								expression (<code>matchedExpression</code>) as both the left and right argument, so
								why doesn't parser go into an infinite loop on the first binary rule, matched
								expression in match operation (<code>matchedExpressionInMatchOperation</code>)?
							</p>
							<p>
								There is no loop because Grammar Kit has some extensions that allow it to detect this
								pattern of rules.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-grammars">
						<h1>Grammars</h1>
						<table>
							<thead>
							<tr>
								<th></th>
								<th>Look-ahead, Left-to-Right, Rightmost deriviation (LALR)</th>
								<th>Parsing Expression Grammar</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Inventor</th>
								<td>Frank DeRemer</td>
								<td>Bryan Ford</td>
							</tr>
							<tr>
								<th>Invented</th>
								<td>1969</td>
								<td>2004</td>
							</tr>
							<tr>
								<th>Terminal symbols</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Nonterminal rules</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Empty string</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Sequence</th>
								<td>&#10003;</td>
								<td>&#10003;</td>
							</tr>
							<tr>
								<th>Choice</th>
								<td>Ambiguous</td>
								<td>Ordered</td>
							</tr>
							<tr>
								<th>Zero-or-more</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>*</code>
								</td>
							</tr>
							<tr>
								<th>One-or-more</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>+</code>
								</td>
							</tr>
							<tr>
								<th>Optional</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>?</code>
								</td>
							</tr>
							<tr>
								<th>Positive Look-ahead</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>&</code>
								</td>
							</tr>
							<tr>
								<th>Negative Look-ahead</th>
								<td>
									<span style="color: red">&#10060;</span>
								</td>
								<td>
									<code>!</code>
								</td>
							</tr>
							<tr>
								<th>Derivation</th>
								<td>Rightmost</td>
								<td>Leftmost</td>
							</tr>
							<tr>
								<th>Left-Recursion</th>
								<td>Favored</td>
								<td>Infinite Loop</td>
							</tr>
							<tr>
								<th>Right-Recursion</th>
								<td>Unfavored</td>
								<td>Favored</td>
							</tr>
							<tr>
								<th>Direction</th>
								<td>Bottom-up</td>
								<td>Top-down</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								YECC is a LALR, or look-ahead, left-to-right, rightmost derivation parser generator.
								Grammar Kit is a Parsing Expression Grammar parser generator.
							</p>
							<p>
								LALR parsers were invented back in 1969, but Parsing Expression Grammar weren't invented
								until 2004, so they may have come out after some of us were in college.
							</p>
							<p>
								LALR grammars don't have syntax for zero-or-more, one-or-more, or optional, instead they
								have to be constructed with recursive rules or rule clauses involving empty strings,
								so the grammar has to be more verbose.
							</p>
							<p>
								LALR has look-ahead in its name, but the grammar itself has no control of how far to
								look-ahead.  Instead, it's hard-coded to be one token.  In parsing expression grammars
								any rule can be put after ampersand (<code>&</code>) to do a positive look-ahead or
								after exclamation point (<code>!</code>) to do negative look-ahead.
							</p>
							<p>
								This look-ahead being rule based instead of token based means it is potentially
								infinite, but that also means that performance in both memory and speed can be worse
								if the look-ahead is chosen poorly.  For LALR, the look-ahead is automatically one
								token and the best rule can be chosen as the match, but the rule order and look-ahead
								is under control of the grammar for Parsing Expression Grammars.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-parsing-direction">
						<h1>Parsing Direction</h1>
						<table>
							<thead>
							<tr>
								<th></th>
								<th>
									Top-Down / Leftmost Derivation
								</th>
								<th>
									Bottom-Up / Rightmost Derivation
								</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>First Symbol</th>
								<td>Root</td>
								<td>Tokens</td>
							</tr>
							<tr>
								<th>Building</th>
								<th>Choses children for current rule</th>
								<td>Combines tokens/rules</td>
							</tr>
							<tr>
								<th>Last Symbol</th>
								<th>Tokens</th>
								<th>Root</th>
							</tr>
							<tr>
								<th>Strength</th>
								<td>Easier to write</td>
								<td>Faster to run</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Top-down parsing can be thought of using functions to try to match the beginning of the
								input.  Inside each function, the child rules are called to see if they match.  If
								all the child rules matches recursively, then top-down finds a match.
							</p>
							<p>
								Bottom-up parsing starts with the leaf tokens and tries to reduce the right-most branches
								into parent, and then ancestor nodes until getting to a root node that matches the
								top-down parsing's entry point.
							</p>
							<p>
								Bottom-up parser have the benefit of usually having linear bound on their parsing time
								relative to the input size while top-down parsing can involve a lot of backtrack, but
								the generated code is more human readable and debuggable.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-yecc-vs-grammar-kit-generated-code">
						<h1>YECC vs Grammar Kit Generated Code</h1>
						<table class="stretch">
							<thead>
							<tr>
								<th>YECC</th>
								<th>Grammar Kit</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<figure>
										<figcaption>
											<code>lib/elixir/src/elixir_parser.erl</code>
										</figcaption>
										<pre><code class="erlang stretch" data-trim>
yeccpars2_6(S, '(', Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 40, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, ')', Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 288, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, ';', Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 289, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, '[', Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 43, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, kw_identifier, Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 87, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, kw_identifier_safe, Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 88, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, kw_identifier_unsafe, Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 89, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, number, Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 60, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, stab_op, Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 290, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, '{', Ss, Stack, T, Ts, Tzr) ->
 yeccpars1(S, 66, Ss, Stack, T, Ts, Tzr);
yeccpars2_6(S, Cat, Ss, Stack, T, Ts, Tzr) ->
 yeccpars2_cont_2(S, Cat, Ss, Stack, T, Ts, Tzr).
										</code></pre>
									</figure>
								</td>
								<td>
									<figure>
										<figcaption>
											<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/gen/org/elixir_lang/parser/ElixirParser.java#L214-L235">
												<code>gen/org/elixir_lang/parser/ElixirParser.java</code>
											</a>
										</figcaption>
										<pre><code class="java stretch" data-trim style="font-size: 140%; line-height: 100%">
public class ElixirParser implements PsiParser {
  // COLON (ATOM_FRAGMENT | quote)
  public static boolean atom(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "atom")) return false;
    if (!nextTokenIs(b, COLON)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, COLON);
    r = r && atom_1(b, l + 1);
    exit_section_(b, m, ATOM, r);
    return r;
  }

  // ATOM_FRAGMENT | quote
  private static boolean atom_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "atom_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ATOM_FRAGMENT);
    if (!r) r = quote(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }
}
										</code></pre>
									</figure>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								YECC's generated code is very well optimized, handling individual characters or
								atoms as tokens, while Grammar Kit's code is less optimized and more like if you
								as a developer wrote the match functions.  Grammar Kit's methods match the rule
								names while the yecc parse functions use number offsets.
							</p>
							<p>
								This made debugging the generate parsers very easy, except that just like YECC's code,
								you can't ask for the in progress AST.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-pratt-parsing-head">
						<h1>Pratt Parsing</h1>
						<h2>Head</h2>
						<figure>
							<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/gen/org/elixir_lang/parser/ElixirParser.java#L1804-L1842">
								<code>gen/org/elixir_lang/parser/ElixirParser.java</code>
							</a>
							<pre><code class="java stretch" data-trim style="font-size: 110%; line-height: 100%">
public class ElixirParser implements PsiParser {
  /* ********************************************************** */
  // Expression root: matchedExpression
  // Operator priority table:
  // 0: PREFIX(matchedExpressionCaptureOperation)
  // 1: BINARY(matchedExpressionInMatchOperation)
  // 2: BINARY(matchedExpressionWhenOperation)
  // 3: BINARY(matchedExpressionTypeOperation)
  // 4: BINARY(matchedExpressionPipeOperation)
  // 5: BINARY(matchedExpressionMatchOperation)
  // 6: BINARY(matchedExpressionOrOperation)
  // 7: BINARY(matchedExpressionAndOperation)
  // 8: BINARY(matchedExpressionComparisonOperation)
  // 9: BINARY(matchedExpressionRelationalOperation)
  // 10: BINARY(matchedExpressionArrowOperation)
  // 11: BINARY(matchedExpressionInOperation)
  // 12: BINARY(matchedExpressionTwoOperation)
  // 13: BINARY(matchedExpressionAdditionOperation)
  // 14: BINARY(matchedExpressionMultiplicationOperation)
  // 15: BINARY(matchedExpressionHatOperation)
  // 16: PREFIX(matchedExpressionUnaryOperation)
  // 17: BINARY(matchedExpressionDotOperation)
  // 18: PREFIX(matchedExpressionAtOperation)
  // 19: ATOM(identifierExpression)
  // 20: ATOM(accessExpression)
  public static boolean matchedExpression(PsiBuilder b, int l, int g) {
    if (!recursion_guard_(b, l, "matchedExpression")) return false;
    addVariant(b, "&lt;matched expression&gt;");
    boolean r, p;
    Marker m = enter_section_(b, l, _NONE_, "&lt;matched expression&gt;");
    r = matchedExpressionCaptureOperation(b, l + 1);
    if (!r) r = matchedExpressionUnaryOperation(b, l + 1);
    if (!r) r = matchedExpressionAtOperation(b, l + 1);
    if (!r) r = identifierExpression(b, l + 1);
    if (!r) r = accessExpression(b, l + 1);
    p = r;
    r = r && matchedExpression_0(b, l + 1, g);
    exit_section_(b, l, m, null, r, p, null);
    return r || p;
  }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The generated code I showed and the rules for parsing expression grammars say that left
								recursion is impossible, so how am I allowed to have matched expression
								(<code>matchedExpression</code>) as the left-most rule in a rule that's part of matched
								expression (<code>matchedExpression</code>) itself?
							</p>
							<p>
								Pratt parsing is an extension to recursive-descent parsers, which include parsing
								expression grammars, that allows for optimization for parsing operators by noticing
								patterns in how humans write binary operators to eliminate left-recursion.
							</p>
							<p>
								The optimization involves noticing that eventually all operation rules get to
								rules that aren't left-recursive or that are tokens, so the parser generator itself
								can do the left-recursion elimination by looking for those non-left-recursive rules
								first, then try to consume an operator, then do it all over again, but keep track
								of the precedence of the operator.
							</p>
							<p>
								Here, you can see that the prefix operations, matched expression unary operation
								(<code>matchedExpressionUnaryOperation</code>) and matched expression at operation
								(<code>matchedexpressionAtOperation</code>), can be checked for because they consume
								an operator token first and so aren't left-recursive.
							</p>
							<p>
								Likewise, identifier expression (<code>identifierExpression</code>) and access
								expression (<code>accessExpression</code>) are atoms, so they don't include
								matched expression (<code>matchedExpression</code>) at all and so can be used to
								consume input immediately.
							</p>
							<p>
								Once some input is consumed, matched expression (<code>matchedExpression</code>)
								goes into matched expression underscore 0 (<code>matchedExpression_0</code>).  For
								user written rules the underscore number system is unused for anonymous groups in
								parentheses, but here's it's meant to indicate that the parser is checking the tail
								of all the matched expression (<code>matchedExpression</code>) rules.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-pratt-parsing-tail">
						<h1>Pratt Parsing</h1>
						<h2>Tail</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.0/gen/org/elixir_lang/parser/ElixirParser.java#L1844-L1919">
									<code>gen/org/elixir_lang/parser/ElixirParser.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 120%; line-height: 100%">
public class ElixirParser implements PsiParser {
 public static boolean matchedExpression_0(PsiBuilder b, int l, int g) {
    if (!recursion_guard_(b, l, "matchedExpression_0")) return false;
    boolean r = true;
    while (true) {
      Marker m = enter_section_(b, l, _LEFT_, null);
      if (g &lt; 1 && matchedExpressionInMatchOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 1);
        exit_section_(b, l, m, MATCHED_EXPRESSION_IN_MATCH_OPERATION, r, true, null);
      }
      else if (g &lt; 2 && matchedExpressionWhenOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 1);
        exit_section_(b, l, m, MATCHED_EXPRESSION_WHEN_OPERATION, r, true, null);
      }
      else if (g &lt; 3 && matchedExpressionTypeOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 2);
        exit_section_(b, l, m, MATCHED_EXPRESSION_TYPE_OPERATION, r, true, null);
      }
      else if (g &lt; 4 && matchedExpressionPipeOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 3);
        exit_section_(b, l, m, MATCHED_EXPRESSION_PIPE_OPERATION, r, true, null);
      }
      else if (g &lt; 5 && matchedExpressionMatchOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 4);
        exit_section_(b, l, m, MATCHED_EXPRESSION_MATCH_OPERATION, r, true, null);
      }
      else if (g < 6 && matchedExpressionOrOperation_0(b, l + 1)) {
        r = matchedExpression(b, l, 6);
        exit_section_(b, l, m, MATCHED_EXPRESSION_OR_OPERATION, r, true, null);
      }
      // ...
      else {
        exit_section_(b, l, m, null, false, false, null);
        break;
      }
    }
    return r;
  }								
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The pattern used in matched expression (<code>matchedExpression</code>) and matced
								expression zero (<code>matchedExpression_0</code>) is based on Douglas Crockford's
								Top Down Operator Precedence implementation in Javascript.
							</p>
							<p>
								<code>g</code> is the right-binding power of the currently matched operator.  Only
								operators with a stronger binding power (because they are higher precedence) can
								be matched when recursing, but if no stronger rule is matched on the recursive
								call to matched expression (<code>matchedExpression</code>), then the while loop
								allows for matching operators of equal right-binding power.
							</p>
							<p>
								The left-associative, in match at the beginning and or at the end of the excerpt all
								follow the pattern of recursive call to matched expression
								(<code>matchedExpression</code>) with <code>g</code> one greater than the max for the
								current operator (so g less than 1 and 1 is passed; g less than 6 and 6 is passed).
								This ensures that adjacent left operators at the same level are matched by the while
								loop, which are then properly left-nested by the underscore left
								underscore (<code>_LEFT_</code>) directive in the <code>m</code> marker at the top of
								while loop.
							</p>
							<p>
								The underscore left underscore (<code>_LEFT_</code>) directive is similar how the
								pipelines are rearranged in Elixir.
							</p>
							<p>
								For right-associative operators, like when, type, pipe, and match, the if clauses
								recursively calls matched expression (<code>matchedExpression</code> with
								<code>g</code> that can match the current operator, which means adjacent
								right-associative operators or any higher precedence operator is properly nested at a
								lower level.  Since the parser is left-most derivation, any nesting occurs on the
								right-end, so nesting gets the proper right-associative behavior.
							</p>
						</aside>
					</section>
					<section id="matched-expressions-associativity">
						<h1>Associativity</h1>
						<table>
							<thead>
							<tr>
								<th>Associativity</th>
								<th>Left</th>
								<th>Right</th>
							</tr>
							<tr>
								<th>Code</th>
								<td>
									<code>a or b || c</code>
								</td>
								<td>
									<code>a ++ b <> c</code>
								</td>
							</tr>
							<tr>
								<th>Nesting</th>
								<td>
									<ul>
										<li>
											<code>||</code>
											<ul>
												<li>
													<code>or</code>
													<ul>
														<li>
															<code>a</code>
														</li>
														<li>
															<code>b</code>
														</li>
													</ul>
												</li>
												<li>
													<code>c</code>
												</li>
											</ul>
										</li>
									</ul>
								</td>
								<td>
									<ul>
										<li>
											<code>++</code>
											<ul>
												<li>
													<code>a</code>
												</li>
												<li>
													<code>&lt;&gt;</code>
													<ul>
														<li>
															<code>b</code>
														</li>
														<li>
															<code>c</code>
														</li>
													</ul>
												</li>
											</ul>
										</li>
									</ul>
								</td>
							</tr>
							<tr>
								<th>Effective Parentheses</th>
								<td>
									<code>(a or b) || c</code>
								</td>
								<td>
									<code>a ++ (b <> c)</code>
								</td>
							</tr>
							<tr>
								<th>Execution Pipeline</th>
								<td>
									a |> Kernel.or(b) |> Kernel.||(c)
								</td>
								<td>
									a |> Kernel.++(b |> Kernel.<>(c))
								</td>
							</tr>
							</thead>
						</table>
						<aside class="notes">
							<p>
								Instead of having to visual that in your head, let's see a nested example for
								left- and right-associative operators.
							</p>
							<p>
								I'm using the or operators, the word <code>or</code> and double pipes (<code>||</code>)
								for the left-associative operator because they're easy to distingish.  Similarly,
								I'm using the two operators, double plus (<code>++</code>) and diamond
								(<code>&lt;&gt;</code>), for the right-associative operator.  Remember, the two
								operators in each example are of the same precedence, so it's just the associativity
								controlling the nesting.
							</p>
							<p>
								For left-associative, the left-most operator becomes the root of the tree with
								the right operand executing first, so it looks like the operators are in the wrong
								order, but if you rearrange the nesting to pipeline order it makes sense.
							</p>
							<p>
								For right-associative, reading the tree in order, it looks like it matches, the order
								of the code, but when you change it to pipeline order you can see the the second
								operation must actually complete at the same time as the first argument.
							</p>
						</aside>
					</section>
                    <section id="matched-expressions-v0.2.0">
                        <h1>v0.1.3 and v0.2.0</h1>
                        <table>
                            <thead>
                            <tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>2014&#8209;11&#8209;30</td>
								<td>66</td>
								<td>126</td>
								<td>250</td>
								<td>373</td>
								<td>3.79</td>
                            </tr>
                            </tbody>
                        </table>
                        <ul style="font-size: 35%">
                            <li>
                                <p>Enhancements</p>
                                <ul>
                                    <li>All valid escape sequences (<code>\&lt;character&gt;</code>, <code>\x&lt;hexadecimal&gt;</code>, <code>\x{&lt;hexadecimal&gt;}</code>,) are recognized.</li>
                                    <li>Support for creation of Elixir modules</li>
                                    <li>Use pygments' elixir_example.ex supplied by Alexei Sholik for Color Settings Page.<li>
                                    <li><code>?</code> before any character or valid escape sequence will be recognized as a character token.</li>
                                    <li><code>;</code> is recognized as EOL. <code>\r\n</code> and <code>\n</code> style EOL can be escaped with <code>\</code> and will be treated as whitespace.</li>
                                    <li>Operator arity, associativity, and precedence</li>
                                    <li>Decimal integers and floats</li>
                                    <li>Identifiers (variable, function, and macro names)</li>
                                    <li><code>...</code> identifier</li>
                                    <li>Aliases (module names)</li>
                                    <li>Keyword Identifiers</li>
                                    <li>Empty Parentheses</li>
                                    <li>In Operator</li>
                                    <li>Dot Operator</li>
                                    <li>Keyword Lists</li>
                                    <li>Matched Expressions</li>
                                    <li>Regular Keywords (<code>end</code>, <code>false</code>, <code>fn</code>, <code>nil</code>, and <code>true</code>)
                                    <li>
                                        <p>New attributes for parts of numbers on Color Settings Page</p>
                                        <ul>
                                            <li>Binary, Decimal, Hexadecimal, and Octal Digits</li>
                                            <li>Decimal Exponent, Mark, and Separator</li>
                                            <li>
                                                <p>Invalid Binary, Decimal, Hexadecimal, and Octal Digits</p>
                                                <ul>
                                                    <li>2-9, A-Z, and a-z will be parsed as invalid binary digits</li>
                                                    <li>8-9, A-Z, and a-z will be parsed as invalid octal digits</li>
                                                    <li>G-Z and g-z will be parsed as invalid hexadecimal digits</li>
                                                </ul>
                                            </li>
                                            <li>
                                                <p>Non-Decimal Base Prefix</p>
                                                <ul>
                                                    <li>Any letter other than b, o, or x, in either case, will be recognized as an invalid whole number base</li>
                                                </ul>
                                            </li>
                                            <li>Obsolete Non-Decimal Base Prefix (<code>B</code> for binary and <code>X</code> for hexadecimal)</li>
                                        </ul>
                                    </li>
                                    <li>Any digit, 0-9, A-Z, or a-z will be parsed as invalid for invalid whole number based numbers</li>
                                    <li>Recovery for non-decimal whole numbers if the prefix is given, but no digits are given</li>

                                </ul>
                            </li>
                            <li>
                                <p>Bug Fixes</p>
                                <ul>
									<li>Blank lines are properly parsed as whitespace instead of bad characters.</li>
									<li>EOL is parsed as bad character in sigil name (after `~`) instead of causing the lexer to fail to match, which raised exceptions in Event Log.</li>
                                    <li>Sigil terminator escapes are recognized, so that sigils are no longer prematurely terminated.</li>
                                    <li>Comments do not consume EOL, so trailing comments don't cause error parsing expression on following line.</li>
                                    <li>Sigil modifiers now work on groups in addition to heredocs.</li>
                                    <li><code>;</code> is separate from <code>EOL</code> and either or both can separate expressions, but only <code>EOL</code> can separate operators and operands for operations</li>
                                </ul>
                            </li>
                            <li>
                                <p>Incompatible Changes</p>
                                <ul>
                                    <li>Recovery for non-decimal whole numbers if the prefix is given, but no digits are given</li>
                                </ul>
                            </li>
                            <aside class="notes">
                                <p>
                                    Version zero dot one dot four (v0.1.4) wasn't released, so the next release, zero
                                    dot two dot zero (v0.2.0) didn't come until one third of the way through the first
                                    year of the project, on day 126.
                                </p>
                                <p>
                                    It contained a plethora of changes and was the first time useful code, such as
                                    mathematical operations could be recognized by the parser.
                                </p>
								<p>
									But, as you can gather from the previous slides a lot of that time was me learning
									the difference between YECC's LALR and Grammar Kit's Parsing Expression Grammar
									with Pratt Parsing.
								</p>
                            </aside>
                        </ul>
                    </section>
                </section>
				<section class="stack">
					<section id="no-parentheses-function-calls">
						<h1>No Parentheses Function Calls</h1>
						<ul>
							<li>
								<a href="#/no-parentheses-function-calls-yecc">YECC</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-conversion">Conversion</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-maybe-qualified">Maybe Qualified</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-unqualified">Unqualified</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-qualified">Qualified</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-arguments">Arguments</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-no-parentheses-strict">No Parentheses Strict</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-many-arguments">Many Arguments</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-expression">No Parentheses Expression</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-matched-expression-vs-keyword-key">MatchedExpression vs KeywordKey</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-matched-expression">In Matched Expression</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-call-matched-call-operation">
									<code>matchedCallOperation</code>
								</a>
							</li>
							<li>
								<a href="#/no-parentheses-function-calls-qualified-matched-call-operation">
									Qualified <code>matchedCallOperation</code>
								</a>
							</li>
						</ul>
					</section>
					<section id="no-parentheses-function-calls-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L88-L421">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim>
expr -&gt; no_parens_expr : '$1'.

no_parens_expr -&gt; dot_op_identifier call_args_no_parens_many_strict : build_identifier('$1', '$2').
no_parens_expr -&gt; dot_identifier call_args_no_parens_many_strict : build_identifier('$1', '$2').

dot_identifier -&gt; identifier : '$1'.
dot_identifier -&gt; matched_expr dot_op identifier : build_dot('$2', '$1', '$3').

dot_op_identifier -&gt; op_identifier : '$1'.
dot_op_identifier -&gt; matched_expr dot_op op_identifier : build_dot('$2', '$1', '$3').

call_args_no_parens_comma_expr -&gt; matched_expr ',' call_args_no_parens_expr : ['$3', '$1'].
call_args_no_parens_comma_expr -&gt; call_args_no_parens_comma_expr ',' call_args_no_parens_expr : ['$3'|'$1'].

call_args_no_parens_many -&gt; matched_expr ',' call_args_no_parens_kw : ['$1', '$3'].
call_args_no_parens_many -&gt; call_args_no_parens_comma_expr : reverse('$1').
call_args_no_parens_many -&gt; call_args_no_parens_comma_expr ',' call_args_no_parens_kw : reverse(['$3'|'$1']).

call_args_no_parens_many_strict -&gt; call_args_no_parens_many : '$1'.
call_args_no_parens_many_strict -&gt; empty_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -&gt; open_paren call_args_no_parens_kw close_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -&gt; open_paren call_args_no_parens_many close_paren : throw_no_parens_strict('$1').
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								No parentheses function calls were the first function calls to be implemented because
								no parens expr (<code>no_parens_expr</code>) is a direct child of the root
								<code>expr</code> rule in elixir parser dot yerl (<code>elixir_parser.yrl</code>.
							</p>
							<p>
								I knew from using Elixir that these rules had to match parentheses-less calls I was
								used to writing, so either qualified calls with an identifier on the end for
								dot identifier's (<code>dot_identifier</code>) second clause or an unqualified clause
								for the first clause.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-conversion">
						<h1>Conversion</h1>
						<ol>
							<li>
								<figure>
									<figcaption>
										Original
									</figcaption>
									<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%">
no_parens_expr -&gt; dot_identifier call_args_no_parens_many_strict

dot_identifier -&gt; identifier
dot_identifier -&gt; matched_expr dot_op identifier
									</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>
										Compact <code>dot_identifier</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%">
no_parens_expr -&gt; dot_identifier call_args_no_parens_many_strict

dot_identifier ::= (matched_expr dot_op)? identifier
									</code></pre>
								</figure>
							</li>
							<li>
								<figure>
									<figcaption>
										Inline <code>dot_identifer</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%; width: 51em">
no_parens_expr ::= (matched_expr dot_op)? identifier call_args_no_parens_many_strict
									</code></pre>
								</figure>
							</li>
						</ol>
						<aside class="notes">
							<p>
								When converting the YECC BNF to Grammar Kit BNF, I need to combine clauses using the
								extra features available in Parsing Expression Grammars.  This also helps me reason
								about the rule as Parsing Expression Grammars have more regular expression like
								syntax. I can evaluate those in my mind easier as they eliminate redundancies in the
								grammar and make the branch points more obvious to me.
							</p>
							<p>
								That first anonymous group was a problem: the pratt parser generator for Grammar Kit
								only works if a rule is used as a direct operand and matched expression
								(<code>matched_expr</code>) needs to be indirect to allow both qualified and
								unqualified no parentheses calls.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-maybe-qualified">
						<h1>Maybe Qualified</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/834aad640ccf80573ce5aab6964dedd97de804b7/src/org/elixir_lang/Elixir.bnf#L110-L296">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 120%; line-height: 100%">
/* Cannot use `(matchedExpressionDotIdentifier | identifierExpression)` as matchedExpression will be used in place of
   matchedExpressionDotIdentifier in generated parser. I'm not sure, but it may be due to matchedExpression being the
   expression root of matchedExpressionDotIdentifier */
/* Cannot use `(matchedExpression EOL* DOT_OPERATOR EOL*)? IDENTIFIER` because unlike in matchedExpression, this pattern
   from matchedExpressionDotIdentifier will have the first matchedExpression parse as a matchedExpressionDotIdentifier
   because calling into matchedExpression does not handle the precedence starting point correctly. */
/* no EOL* before callArgumentsNoParenthesesManyStrict as first argument must be on same line so that function isn't
   interpreted as taking no arguments. */
noParenthesesExpression ::= noParenthesesMaybeQualifiedIdentifier callArgumentsNoParenthesesManyStrict

noParenthesesMaybeQualifiedIdentifier ::= noParenthesesQualifier* IDENTIFIER
noParenthesesQualifier ::= noParenthesesQualifierHead noParenthesesQualifierTail*
private noParenthesesQualifierHead ::= (
                                noParenthesesQualifierAtOperation |
                                noParenthesesQualifierNumberCaptureOperation |
                                noParenthesesQualifierNumberUnaryOperation |
                                noParenthesesQualifierNumberAtOperation |
                                OPENING_PARENTHESIS EOL* SEMICOLON EOL* CLOSING_PARENTHESIS |
                                CHAR_TOKEN |
                                number |
                                list |
                                binaryString |
                                listString |
                                sigil |
                                FALSE |
                                NIL |
                                TRUE |
                                atom |
                                ALIAS |
                                IDENTIFER
                               ) EOL* DOT_OPERATOR EOL* &(noParenthesesQualifierTail | IDENTIFIER)
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Comments are a message to myself to prevent me from thinking I can simplify the grammar
								by combining rules, because it's not possible to hold the whole grammar and its
								recursive implications in your head, but like all comments their truthfulness is
								immediate and fleeting.  For example, the first comments, I can actually explain
								better now, but that only came after debugging more difficult problems with do block
								parsing.
							</p>
							<p>
								All this looks like a bunch of copying all the prefix operators and all the tokens
								I could think of as valid qualifiers for calls, but this approach is wrong.  I was
								missing that the recursive nature of matched expression (<code>matchedExpression</code>)
								would automatically produce qualified no parentheses function calls if I allowed
								no parentheses function calls into matched expressions in general.
							</p>
							<p>
								This wouldn't be the only time where implementing the grammar piece-meal would actually
								make it harder to get correct behavior.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-unqualified">
						<h1>Unqualified</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L82-L162">
									<code>src/org/elixir_lang/Elixir.bnf#</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 105%; line-height: 100%">
private expression ::= emptyParentheses |
                       unqualifiedNoParenthesesManyArgumentsCall |
                       matchedExpression

noParenthesesManyArgumentsUnqualifiedIdentifier ::= IDENTIFIER
                                                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
unqualifiedNoParenthesesManyArgumentsCall ::= noParenthesesManyArgumentsUnqualifiedIdentifier
                                              noParenthesesManyArgumentsStrict
                                              {
                                                implements = "org.elixir_lang.psi.Call"
                                                methods = [
                                                  getArguments
                                                  getIdentifier
                                                  quote
                                                ]
                                              }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Now, the only duplication is having a special rule for the IDENTIFIER token quoting.
							</p>
							<p>
								So, an unqualified no parentheses many arguments call
								(<code>unqualfifiedNoParenthesesManyArgumentsCall</code>) is exactly what it sounds
								like: unqualified because it's only an identifier, no parentheses, and has many
								arguments, which I'll get to in a bit.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-qualified">
						<h1>Qualified</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L190-L1338">
									<code>src/org/elixir_lang/Elixir.bnf#</code>
								</a>
							</figcaption>
							<pre><code data-trim style="font-size: 120%; line-height: 100%">
noParenthesesNoArgumentsUnqualifiedCallOrVariable ::= IDENTIFIER
                                                      { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

matchedExpression ::= matchedCaptureNonNumericOperation |
                      // ...
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                      accessExpression

matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
                         {
                           implements = "org.elixir_lang.psi.Call"
                           methods = [
                             getArguments
                             getIdentifier
                             quote
                           ]
                         }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So's there's another rule just for quoting the <code>IDENTIFIER</code> token, but
								they need to be separate because no parentheses no arguments qualified call or variable
								(<code>noParenthesesNoArgumentsUnqualifiedCallOrVariable</code>) extends matched
								expression (<code>matchedExpession</code>) for the Pratt Parser, so using it directly
								is the same as using matched expression (<code>matchedExpression</code>) directly.  That
								was a fun bug to figure out!
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-arguments">
						<h1>Arguments</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L418-L421">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
call_args_no_parens_many_strict -> call_args_no_parens_many : '$1'.
call_args_no_parens_many_strict -> empty_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -> open_paren call_args_no_parens_kw close_paren : throw_no_parens_strict('$1').
call_args_no_parens_many_strict -> open_paren call_args_no_parens_many close_paren : throw_no_parens_strict('$1').
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L122-L147">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 135%; line-height: 100%">
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS
                        { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Instead of having all 4 clauses from call args no parens many strict
								(<code>call_args_no_parens_many_strict</code>) directly under no parentheses many
								arguments strict (<code>noParenthesesManyArgumentStrict</code>) because it allowed
								me to use a single node, no parentheses strict (<code>noParenthesesStrict</code>),
								which was helpful for the first Intent.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-no-parentheses-strict">
						<h1>No Parentheses Strict</h1>
						<figure>
							<figcaption>
								Test Code
							</figcaption>
							<pre><code class="elixir stretch" data-trim>
function (first_positional, second_positional, key: value)
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<code>Code.string_to_quoted</code>
							</figcaption>
							<pre><code class="elixir stretch" data-trim style="font-size: 85%; line-height: 100%">
{:error,
 {1,
  "unexpected parenthesis. If you are making a function call, do not insert spaces in between the function name and the opening parentheses. Syntax error before: ",
  "'('"}}
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								Error highlighting and Quick Fix
							</figcaption>
							<img class="stretch" src="images/Remove%20Spaces%20Before%20Ambiguous%20Parentheses.gif" style="height: auto; width: 100%"/>
						</figure>
						<aside class="notes">
							<p>
								The Elixir parser throws errors immediately, but this stops the user from being able to
								correct later errors.  This can be a wise choice if anyone has ever seen the noise that
								a single error in C or C++ can make later in the file.
							</p>
							<p>
								For an IDE however, it would be annoying if syntax and error highlighting stopped at the
								first error, so invalid syntax, such as ambiguous parentheses are allowed in IntelliJ
								Elixir's parser and only marked as errors using an Inspection, which then allows the user
								to Quick Fix the error with Alt Enter (<code>ALT+Enter</code>) when the cursor is hovering
								over it.
							</p>
							<p>
								Being able to correct errors is one of the reasons that an IDEs grammar can be more
								permissive than the compiler's grammar: permissiveness in parser allows for more robust
								heuristics to mark the errors later.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-many-arguments">
						<h1>Many Arguments</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L400-L416">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 130%; line-height: 100%">
call_args_no_parens_expr -> matched_expr : '$1'.
call_args_no_parens_expr -> empty_paren : nil.
call_args_no_parens_expr -> no_parens_expr : throw_no_parens_many_strict('$1').

call_args_no_parens_comma_expr -> matched_expr ',' call_args_no_parens_expr : ['$3', '$1'].
call_args_no_parens_comma_expr -> call_args_no_parens_comma_expr ',' call_args_no_parens_expr : ['$3'|'$1'].

call_args_no_parens_many -> matched_expr ',' call_args_no_parens_kw : ['$1', '$3'].
call_args_no_parens_many -> call_args_no_parens_comma_expr : reverse('$1').
call_args_no_parens_many -> call_args_no_parens_comma_expr ',' call_args_no_parens_kw : reverse(['$3'|'$1']).
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L105-L138">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim>
private noParenthesesCommaExpression ::= matchedExpression (infixComma noParenthesesExpression)+
noParenthesesFirstPositional ::= matchedExpression
                                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
noParenthesesOnePositionalAndKeywordsArguments ::= noParenthesesFirstPositional infixComma noParenthesesKeywords
                                                   { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
noParenthesesManyPositionalAndMaybeKeywordsArguments ::= noParenthesesCommaExpression (infixComma noParenthesesKeywords)?
                                                         { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								calls args no parens comma expr many (<code>call_args_no_parens_many</code>) 3 clauses
								are just a way of saying there needs to be at least 2 arguments and keywords can only
								appear at the end.  This can be expressed slightly more compactly in Grammar Kit,
								but there still needs to be 2 rules to ensure that if there is only one positional
								argument there are also keyword arguments.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-expression">
						<h1>No Parentheses Expression</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L400-L402">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
								<pre><code class="stretch" data-trim style="font-size: 185%; line-height: 100%">
call_args_no_parens_expr -> matched_expr : '$1'.
call_args_no_parens_expr -> empty_paren : nil.
call_args_no_parens_expr -> no_parens_expr : throw_no_parens_many_strict('$1').
								</code></pre>
							</figcaption>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v1.0.0/src/org/elixir_lang/Elixir.bnf#L201-L211">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
noParenthesesExpression ::= emptyParentheses |
                            /* Must be before matchedExpression because noParenthesesExpression is
                               `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is longer
                               than `matchedExpressionDotIdentifier` in matchedExpression. */
                            /* This will be marked as an error by
                               {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                            noParenthesesManyStrictNoParenthesesExpression |
                            matchedExpression !KEYWORD_PAIR_COLON
                            { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								As I already mentioned: more comments means I had more problems getting the grammar
								right.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-matched-expression-vs-keyword-key">
						<h1>MatchedExpression vs KeywordKey</h1>
						<ol>
							<li>
								<code>matchedExpression</code>
							</li>
							<li class="fragment">
								<code>matchedExpression ::= accessExpression</code>
							</li>
							<li class="fragment">
								<code>accessionExpression ::= stringLine</code>
							</li>
							<li class="fragment">
								<code>quote ::= stringLine</code>
							</li>
							<li class="fragment">
								<code>keywordKey ::= quote</code>
							</li>
							<li class="fragment">
								<code>private keywordKeyColonEOL ::= keywordKey KEYWORD_PAIR_COLON EOL*</code>
								<br/>
								<code>noParenthesesKeywordPair ::= keywordKeyColonEOL noParenthesesExpression</code>
							</li>
							<li class="fragment">
								<code>noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*</code>
							</li>
							<li class="fragment">
								<code>noParenthesesOnePositionalAndKeywordsArguments ::= noParenthesesFirstPositional infixComma noParenthesesKeywords</code>
								<br/>
								<code>noParenthesesManyPositionalAndMaybeKeywordsArguments ::= noParenthesesCommaExpression (infixComma noParenthesesKeywords)?</code>
							</li>
						</ol>
						<aside class="notes">
							<p>
								Having to put not keyword pair colon (<code>!KEYWORD_PAIR_COLON</code>) after
								matchedExpression is one of the places where one has to think recursively through the
								rules: matched expression (<code>matchedExpression</code>) contains access expession
								(<code>accessExpression</code>). [Hit Enter]  Access expression contains string line
								(<code>stringLine</code>) [Hit Enter], but a string (or char list) is contained in
								quoted [Hit Enter], which is contained in keyword key (<code>keywordKey</code>)
								[Hit Enter], which is contained in no parentheses keyword pair
								(<code>noParenthesesKeywordPair</code> [Hit Enter], which is contained in no parentheses
								keywords (<code>noParenthesesKeywords</code>) [Hit Enter], which is the tail of
								no parentheses function calls. [Hit Enter]
							</p>
							<p>
								The native parser does not have this problem because it tokenizes quoted keyword key
								atoms as just keyword identifiers, which it can do since it can hold as much text
								as it wants in a buffer to represent a token.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-matched-expression">
						<h1>In Matched Expression</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L113-L169">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 145%; line-height: 100%">
matched_expr -> matched_expr no_parens_op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
matched_expr -> unary_op_eol no_parens_expr : build_unary_op('$1', '$2').
matched_expr -> at_op_eol no_parens_expr : build_unary_op('$1', '$2').
matched_expr -> capture_op_eol no_parens_expr : build_unary_op('$1', '$2').

no_parens_op_expr -> match_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> add_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> mult_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> hat_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> two_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> and_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> or_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> in_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> in_match_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> type_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> pipe_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> comp_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> rel_op_eol no_parens_expr : {'$1', '$2'}.
no_parens_op_expr -> arrow_op_eol no_parens_expr : {'$1', '$2'}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Adding no parentheses function calls on their own was simple enough, but getting no
								parentheses function calls as the right-most operand (and only the right-most operand)
								in a matched expression took up the majority of the version zero dot two dot one
								(<code>v0.2.1</code>): 454 of 521 commits in
								<a href="https://github.com/KronicDeth/intellij-elixir/pull/105">pull request 105</a>.
								It involved abandonning the succinct Pratt Parser for the majority of the time because
								I couldn't figure out how to get
							</p>
							<p>
								For a very long time I was stuck on how to ensure that a <code>no_parens_expr</code>
								could only appear on the right hand-side of a matched expression and knowing that
								it had to be the the end of the matched expression because otherwise two
								no parentheses calls could be next to each other.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-call-matched-call-operation">
						<h1>Matched Call Operation</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/2c9892cacd00a8bb6d0d456ebf0e3899219b89ef/src/org/elixir_lang/Elixir.bnf#L908-L1338">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
matchedExpression ::= matchedCaptureNonNumericOperation |
                      matchedInMatchOperation |
                      /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                      matchedWhenNoParenthesesKeywordsOperation |
                      matchedWhenOperation |
                      matchedTypeOperation |
                      matchedPipeOperation |
                      matchedMatchOperation |
                      matchedOrOperation |
                      matchedAndOperation |
                      matchedComparisonOperation |
                      matchedRelationalOperation |
                      matchedArrowOperation |
                      matchedInOperation |
                      matchedTwoOperation |
                      matchedAdditionOperation |
                      matchedMultiplicationOperation |
                      matchedHatOperation |
                      matchedUnaryNonNumericOperation |
                      matchedDotOperation |
                      matchedAtNonNumericOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                      accessExpression

matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
                         {
                           implements = "org.elixir_lang.psi.Call"
                           methods = [
                             getArguments
                             getIdentifier
                             quote
                           ]
                         }
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								What finally cracked the problem was when I realized that the no parentheses calls
								by their very nature would consume function calls to the right of the first
								no parentheses call as either a positional argument to the right call, which the
								inspections could pick up as an error or as a keyword value, which is actually legal.
							</p>
							<p>
								Because the way the Pratt Parser works, matchedCallOperation can either be the only
								element of an expression or the right-most expression.
							</p>
						</aside>
					</section>
					<section id="no-parentheses-function-calls-qualified-matched-call-operation">
						<h1>Qualified Matched Call Operation</h1>
						<ol>
							<li>
								<figure>
									<figcaption>
										Rule Subset
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
                      accessExpression
matchedDotOperation ::= matchedExpression dotInfixOperator matchedExpression
matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
accessExpression ::= alias
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Inline <code>alias</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable
matchedDotOperation ::= alias dotInfixOperator matchedExpression
matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Inline <code>matchedCallOperation</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      matchedCallOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable |
matchedDotOperation ::= alias dotInfixOperator matchedCallOperation
matchedCallOperation ::= matchedExpression noParenthesesManyArgumentsStrict
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Expand <code>matchedCallOperation</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedExpression ::= matchedDotOperation |
                      noParenthesesNoArgumentsUnqualifiedCallOrVariable
matchedDotOperation ::= alias dotInfixOperator matchedExpression noParenthesesManyArgumentsStrict
									</code></pre>
								</figure>
							</li>
							<li class="fragment">
								<figure>
									<figcaption>
										Inline <code>noParenthesesNoArgumentsUnqualifiedCallOrVariable</code>
									</figcaption>
									<pre><code class="stretch" data-trim style="width: 78em">
matchedDotOperation ::= alias dotInfixOperator noParenthesesNoArgumentsUnqualifiedCallOrVariable noParenthesesManyArgumentsStrict
									</code></pre>
									<pre class="fragment"><code class="stretch" style="width: 78em">
                        Kernel .               inspect                                           0..1, structs: false
									</code></pre>
								</figure>
							</li>
						</ol>
						<aside class="notes">
							<p>
								Using the precedence rules for Pratt Parsers, any early choice can chose a later choice
								as a substitution for the base rule, <code>matchedExpression</code>.
							</p>
							<p>
								Starting with a subset of the rules including dot and alias, [Hit Enter]
								the alias is substituted into the lower precedence dot operation because lower
								precedence operations wrap higher precedence operators, think additions taking
								multiplications as arguments.
							</p>
							<p>
								[Hit Enter] On the right-hand operand, <code>matchedCallOperation</code>, is
								substituted, which [Hit Enter] can be expanded to another <code>matchedExpression</code>,
								[Hit Enter] which will be an identifer, which [Hit Enter] matches a remote no
								parentheses call.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="jinterface">
						<h1>JInterface</h1>
						<ul>
							<li>
								<a href="#/jinterface-quoted-vs-psi">Quoted vs PSI</a>
							</li>
							<li>
								<a href="#/jinterface-node">Node</a>
							</li>
							<li>
								<a href="#/jinterface-mailbox">Mailbox</a>
							</li>
							<li>
								<a href="#/jinterface-message">Message</a>
							</li>
							<li>
								<p>Quoted</p>
								<ul>
									<li>
										<a href="#/jinterface-quoted-expected">Expected</a>
									</li>
									<li>
										<p>Pattern</p>
										<ul>
											<li>
												<a href="#/jinterface-quoted-pattern-yecc">YECC</a>
											</li>
											<li>
												<a href="#/jinterface-quoted-pattern-intellij-elixir">IntelliJ Elixir</a>
											</li>
										</ul>
									</li>
									<li>
										<a href="#/jinterface-quoted-actual">Actual</a>
									</li>
									<li>
										<a href="#/jinterface-quoted-block">Block</a>
									</li>
									<li>
										<a href="#/jinterface-quoted-comparison">Comparison</a>
									</li>
								</ul>
							</li>
							<li>
								<a href="#/jinterface-char-list">Char List</a>
							</li>
							<li>
								<a href="#/jinterface-protocol">Protocol</a>
							</li>
							</li>
						</ul>
					</section>
					<section id="jinterface-quoted-vs-psi">
						<h1>Quoted vs PSI</h1>
						<table>
							<caption>
								<code>1 + 2 = 3 + 4</code>
							</caption>
							<thead>
							<tr>
								<th>
									<code>Code.string_to_quoted!</code>
								</th>
								<th>
									<code>psiToString</code>
								</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<pre><code class="elixir fade-out fragment stretch" data-fragment-index="1" data-trim style="width: 40em">
{:=, [line: 1], [{:+, [line: 1], [1, 2]}, {:+, [line: 1], [3, 4]}]}
									</code></pre>
									<pre><code class="elixir fragment stretch" data-fragment-index="1" data-trim>
{
 :=,
 [line: 1],
 [
  {
   :+,
   [line: 1],
   [
    1,
    2
   ]
  },
  {
   :+,
   [line: 1],
   [
    3,
    4
   ]
  }
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="stretch" data-trim style="width: 43em">
Elixir File(0,13)
  ElixirMatchedMatchOperationImpl(MATCHED_MATCH_OPERATION)(0,13)
    ElixirMatchedAdditionOperationImpl(MATCHED_ADDITION_OPERATION)(0,5)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(0,1)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(0,1)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(0,1)
            PsiElement(VALID_DECIMAL_DIGITS)('1')(0,1)
      PsiWhiteSpace(' ')(1,2)
      ElixirAdditionInfixOperatorImpl(ADDITION_INFIX_OPERATOR)(2,3)
        PsiElement(DUAL_OPERATOR)('+')(2,3)
      PsiWhiteSpace(' ')(3,4)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(4,5)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(4,5)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(4,5)
            PsiElement(VALID_DECIMAL_DIGITS)('2')(4,5)
    PsiWhiteSpace(' ')(5,6)
    ElixirMatchInfixOperatorImpl(MATCH_INFIX_OPERATOR)(6,7)
      PsiElement(MATCH_OPERATOR)('=')(6,7)
    PsiWhiteSpace(' ')(7,8)
    ElixirMatchedAdditionOperationImpl(MATCHED_ADDITION_OPERATION)(8,13)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(8,9)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(8,9)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(8,9)
            PsiElement(VALID_DECIMAL_DIGITS)('3')(8,9)
      PsiWhiteSpace(' ')(9,10)
      ElixirAdditionInfixOperatorImpl(ADDITION_INFIX_OPERATOR)(10,11)
        PsiElement(DUAL_OPERATOR)('+')(10,11)
      PsiWhiteSpace(' ')(11,12)
      ElixirAccessExpressionImpl(ACCESS_EXPRESSION)(12,13)
        ElixirDecimalWholeNumberImpl(DECIMAL_WHOLE_NUMBER)(12,13)
          ElixirDecimalDigitsImpl(DECIMAL_DIGITS)(12,13)
            PsiElement(VALID_DECIMAL_DIGITS)('4')(12,13)
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Through part of version zero dot two dot one (<code>v0.2.1</code>), I had to manually
								compare the PSI format output by the test cases for IntelliJ Elixir and the output of
								code dot string to quoted (<code>Code.string_to_quoted</code>) in I-E-X
								(<code>iex</code>).
							</p>
							<p>
								It's not easy to compare quoted form to the PSI tree as shown. [hit twice enter]  So,
								I normally would have to indent the quoted form to match the PSI tree.
							</p>
							<p>
								So, I'd read this as there's an equals at the top level and that matches the elixir
								matched match operation implementation (<code>ElixirMatchedMatchOperationImpl</code>).
								Then, there's two additions operation siblings, which matches the elixir matched
								addition operation implementations (<code>ElixirMatchedAdditionOperationImpl</code>)
								siblings, but I have to know to ignore the PSIWhitespace and the elixir match infix
								operator implementation (<code>ElixirMatchInfixOperatorImpl</code>) that's between
								the two addition operations.  Finally, as I need to check that the operand order: one
								two three four (<code>1 2 3 4</code>) matches.
							</p>
							<p>
								I'd have to do this any time I changed the nesting of the grammar such as when
								introducing new error handling or making some nodes private so they don't appear in the
								output PSI.
							</p>
						</aside>
					</section>
					<section id="jinterface-node">
						<h1>Node</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/IntellijElixir.java">
									<code>src/org/elixir_lang/IntellijElixir.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 170%; line-height: 100%">
package org.elixir_lang;

import com.ericsson.otp.erlang.OtpNode;

import java.io.IOException;

public class IntellijElixir {
    private static OtpNode localNode = null;
    public static final String REMOTE_NODE = "intellij_elixir@127.0.0.1";

    public static OtpNode getLocalNode() throws IOException {
        if (localNode == null) {
            localNode = new OtpNode("intellij-elixir@127.0.0.1", "intellij_elixir");
        }

        return localNode;
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								IntelliJ's SDK is written in Java and I knew one could use Java to talk to Erlang
								through JInterface, so I decided just have JInterface tell me if I got the PSI correct
								by using nodes respond to <code>quote</code>, which would spit out JInterface objects
								that matched the output from code dot string to quoted
								(<code>Code.string_to_quoted</code>).
							</p>
							<p>
								The first step in using JInterface is creating a Java node using O-T-P Node
								(<code>OtpNode</code>).  The first argument is the node name.  I use a full name
								instead of a short name so I can ensure that it binds to the IPv4 loop-back address,
								127 dot 0 dot 0 dot 1 (<code>127.0.0.1</code>) so it doesn't randomly bind to the
								IPv6 address or to 0 dot 0 dot 0 dot 0 (<code>0.0.0.0</code>), which would allow the
								entire network to talk to the node.
							</p>
							<p>
								The local and remote names are very close: the Java node uses a dash between intellij
								and elixir while the Elixir node uses an underscore.
							</p>
						</aside>
					</section>
					<section id="jinterface-mailbox">
						<h1>Mailbox</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/intellij_elixir/Quoter.java#L222-L230">
									<code>src/org/elixir_lang/intellij_elixir/Quoter.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 120%; line-height: 100%">
package org.elixir_lang.intellij_elixir;

public class Quoter {
    public static OtpErlangTuple quote(@NotNull String code) throws IOException, OtpErlangExit, OtpErlangDecodeException {
        final OtpNode otpNode = IntellijElixir.getLocalNode();
        final OtpMbox otpMbox = otpNode.createMbox();

        OtpErlangObject quoteMessage = Quoter.quoteMessage(code, otpMbox.self());
        otpMbox.send(REMOTE_NAME, IntellijElixir.REMOTE_NODE, quoteMessage);

        return (OtpErlangTuple) otpMbox.receive(TIMEOUT_IN_MILLISECONDS);
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Once we have a node, we need a pid send so the Elixir code can talk back to Java.  Java
								doesn't have processes, so instead of getting a process from the node and then getting its
								pid, one instead creates a mailbox, which has a pid.
							</p>
							<p>
								Java has no pattern matching, so <code>receive</code> just grabs the next message that is
								available.  It's up to the Java code to maintain unmatched messages, but that wasn't
								necessary here.
							</p>
						</aside>
					</section>
					<section id="jinterface-message">
						<h1>Message</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/intellij_elixir/Quoter.java#L237-L248">
									<code>src/org/elixir_lang/intellij_elixir/Quoter.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 155%; line-height: 100%">
package org.elixir_lang.intellij_elixir;

public class Quoter {
    public static OtpErlangObject quoteMessage(final String text, final OtpErlangPid self) {
        final OtpErlangAtom[] messageKeys = new OtpErlangAtom[]{
                new OtpErlangAtom("quote"),
                new OtpErlangAtom("for")
        };
        final OtpErlangObject[] messageValues = new OtpErlangObject[]{
                elixirString(text),
                self
        };

        return new OtpErlangMap(messageKeys, messageValues);
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								A the time, I hadn't see Joe Devivo's code for gen_java, so I wasn't sure how to fake
								a gen server call format message, so I just used a map.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-expected">
						<h1>Quoted</h1>
						<h2>Expected</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij_elixir/blob/25d5ea28ed0d92aaf9bc7cdfcbeb3f8e019ad4e3/lib/intellij_elixir/supervisor.ex">
									<code>lib/intellij_elixir/supervisor.ex</code>
								</a>
							</figcaption>
							<pre><code class="elixir stretch" data-trim style="font-size: 130%; line-height: 100%">
defmodule IntellijElixir.Supervisor do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, :ok)
  end

  @quoter_module IntellijElixir.Quoter

  def init(:ok) do
    children = [
      worker(@quoter_module, [[], [name: @quoter_module]])
    ]

    supervise(children, strategy: :one_for_one)
  end
end
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij_elixir/blob/25d5ea28ed0d92aaf9bc7cdfcbeb3f8e019ad4e3/lib/intellij_elixir/quoter.ex">
									<code>lib/intellij_elixir/quoter.ex</code>
								</a>
							</figcaption>
							<pre><code class="elixir stretch" data-trim style="font-size: 130%; line-height: 100%">
defmodule IntellijElixir.Quoter do
  use GenServer

  def start_link(args, opts \\ []) do
    GenServer.start_link(__MODULE__, args, opts)
  end

  def handle_info(%{quote: code, for: pid}, state) do
    {status, quoted} = Code.string_to_quoted(code)
    send pid, {status, %{code: code, quoted: quoted}}

    {:noreply, state}
  end
end
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								intellij underscore elixir (<code>intellij_elixir</code> is very simple:  it is
								supervised gen server (<code>GenServer</code>) that takes the quote-for
								(<code>%{quote:, for:}</code>) messages, runs code dot string to quoted
								(<code>Code.string_to_quoted</code>) on the code and sends back the status and quoted
								form.
							</p>
							<p>
								Originally, I thought the supervisor was overkill, but it turned out very useful when
								starting to test when the IntelliJ Elixir could parse around errors (as most IDEs do):
								code dot string to quoted (<code>Code.string_to_quoted</code>), in addition to returning
								tuples with ok (<code>:ok</code>) or error (<code>:error</code>) for the status can
								also raise an exception, so with the supervisor, the quoter would restart for the next
								test case and I got a nice exit message in Java.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-pattern-yecc">
						<h1>Quoted</h1>
						<h2>Pattern</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L113-L189">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 145%; line-height: 100%">
matched_expr -> matched_expr matched_op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
matched_expr -> matched_expr no_parens_op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).

matched_op_expr -> match_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> add_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> mult_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> hat_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> two_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> and_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> or_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> in_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> in_match_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> type_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> when_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> pipe_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> comp_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> rel_op_eol matched_expr : {'$1', '$2'}.
matched_op_expr -> arrow_op_eol matched_expr : {'$1', '$2'}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In YECC, I have to repeat the pattern for quoting the tail of infix operations for each
								tail.  The pattern is short, so it's not a big deal, but it's not easy to know that this
								two tuple pattern is unrelated to the two tuple pattern used for keyword pairs.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-pattern-intellij-elixir">
						<h1>Quoted</h1>
						<h2>Pattern</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/Elixir.bnf#L1048-L1067">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim>
matchedMatchOperation ::= matchedExpression matchInfixOperator matchedExpression
                          { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] rightAssociative = true }

matchedOrOperation ::= matchedExpression orInfixOperator matchedExpression
                       { implements = "org.elixir_lang.psi.InfixOperation" methods = [quote] }
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#L525-L549">
									<code>src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim>
public class ElixirPsiImplUtil {
    @Contract(pure = true)
    @NotNull
    public static OtpErlangObject quote(@NotNull final InfixOperation infixOperation) {
        PsiElement[] children = infixOperation.getChildren();

        if (children.length != 3) {
            throw new NotImplementedException("BinaryOperation expected to have 3 children (left operand, operator, right operand");
        }

        Quotable leftOperand = (Quotable) children[0];
        OtpErlangObject quotedLeftOperand = leftOperand.quote();

        Quotable operator = (Quotable) children[1];
        OtpErlangObject quotedOperator = operator.quote();

        Quotable rightOperand = (Quotable) children[2];
        OtpErlangObject quotedRightOperand = rightOperand.quote();

        return quotedFunctionCall(
                quotedOperator,
                metadata(operator),
                quotedLeftOperand,
                quotedRightOperand
        );
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In Grammar Kit, I can have nodes implement interfaces, and then have methods defined
								for those interfaces, so I can more explicitly indicate that the quoting pattern is
								the same for match and or operation.
							</p>
							<p>
								Of course, this being Java, it is much more verbose than the Erlang in YECC.
							</p>
							<p>
								The error handle on children length is there because I wanted to make sure the
								parser couldn't have silent errors where it ignores input if I ended up having to
								make a systemic change the rules.  It also can prevent the IDE freezing that
								version zero dot zero dot one (<code>v0.0.1</code>) exhibited.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-actual">
						<h1>Quoted</h1>
						<h2>Actual</h2>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#L1075-L1099">
									<code>src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 145%; line-height: 100%">
package org.elixir_lang.psi.impl;

public class ElixirPsiImplUtil {
    public static OtpErlangObject quote(ElixirFile file) {
        final Deque&lt;OtpErlangObject&gt; quotedChildren = new LinkedList&lt;OtpErlangObject&gt;();

        file.acceptChildren(
                new PsiElementVisitor() {
                    @Override
                    public void visitElement(PsiElement element) {
                        if (element instanceof Quotable) {
                            visitQuotable((Quotable) element);
                        } else if (!isUnquoted(element)) {
                            throw new NotImplementedException("Don't know how to visit " + element);
                        }

                        super.visitElement(element);
                    }

                    public void visitQuotable(@NotNull Quotable child) {
                        final OtpErlangObject quotedChild = child.quote();
                        quotedChildren.add(quotedChild);
                    }
                }
        );

        return block(quotedChildren);
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								P-S-I element (<code>PSIElement</code>) has an accept children
								(<code>acceptChildren</code>) method that allows the code to quote a file by just
								quoting the top-level elements and then turning it into a block.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-block">
						<h1>Quoted</h1>
						<h2>Block</h2>
						<table>
							<thead>
							<tr>
								<th>Erlang</th>
								<th>Java</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<figure>
										<figcaption>
											<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_parser.yrl#L717-L718">
												<code>lib/elixir/src/elixir_parser.yrl</code>
											</a>
										</figcaption>
										<pre><code class="erlang stretch" data-trim style="width: 32em">
to_block([One]) -> One;
to_block(Other) -> {'__block__', [], reverse(Other)}.
										</code></pre>
									</figure>
								</td>
								<td>
									<figure>
										<figcaption>
											<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java#L118-L140">
												<code>src/org/elixir_lang/psi/impl/ElixirPsiImplUtil.java</code>
											</a>
											<pre><code class="java stretch" data-trim style="width: 57em">
package org.elixir_lang.psi.impl;

public class ElixirPsiImplUtil {
    @Contract(pure = true)
    @NotNull
    public static OtpErlangObject block(@NotNull final Deque&lt;OtpErlangObject&gt; quotedChildren) {
        OtpErlangObject asBlock;
        final int size = quotedChildren.size();

        if (size == 0) {
            asBlock = NIL;
        } else if (size == 1) {
            asBlock = quotedChildren.getFirst();
        } else {
            OtpErlangObject[] quotedArray = new OtpErlangObject[size];
            OtpErlangList blockMetadata = new OtpErlangList();

            asBlock = quotedFunctionCall(
                    BLOCK,
                    blockMetadata,
                    quotedChildren.toArray(quotedArray)
            );
        }

        return asBlock;
    }
}
											</code></pre>
										</figcaption>
									</figure>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								to block (<code>to_block</code>) in Erlang and block (<code>block</code>) in Java are
								similar, but of course, the Java code is way more verbose to make a tuple.
							</p>
						</aside>
					</section>
					<section id="jinterface-quoted-comparison">
						<h1>Quoted</h1>
						<h1>Comparison</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.2.1/src/org/elixir_lang/intellij_elixir/Quoter.java#L62-L103">
									<code>src/org/elixir_lang/intellij_elixir/Quoter.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 95%; line-height: 100%">
package org.elixir_lang.intellij_elixir;

public class Quoter {
    public static void assertQuotedCorrectly(PsiFile file) {
        final String text = file.getText();

        try {
            OtpErlangTuple quotedMessage = Quoter.quote(text);
            Quoter.assertMessageReceived(quotedMessage);

            OtpErlangAtom status = (OtpErlangAtom) quotedMessage.elementAt(0);
            String statusString = status.atomValue();
            OtpErlangMap map = (OtpErlangMap) quotedMessage.elementAt(1);
            assertCodeEquals(text, map);
            OtpErlangObject expectedQuoted = quoted(map);

            if (statusString.equals("ok")) {
                OtpErlangObject actualQuoted = ElixirPsiImplUtil.quote(file);
                assertEquals(expectedQuoted, actualQuoted);
            } else if (statusString.equals("error")) {
                OtpErlangTuple error = (OtpErlangTuple) expectedQuoted;

                OtpErlangLong line = (OtpErlangLong) error.elementAt(0);

                OtpErlangBinary messageBinary = (OtpErlangBinary) error.elementAt(1);
                String message = javaString(messageBinary);

                OtpErlangBinary tokenBinary = (OtpErlangBinary) error.elementAt(2);
                String token = javaString(tokenBinary);

                throw new AssertionError(
                        "intellij_elixir returned \"" + message + "\" on line " + line + " due to " + token  +
                                ", use assertQuotesAroundError if error is expect in Elixir natively, " +
                                "but not in intellij-elixir plugin"
                );
            }
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        } catch (OtpErlangDecodeException e) {
            throw new RuntimeException(e);
        } catch (OtpErlangExit e) {
            throw new RuntimeException(e);
        }
    }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The actual comparison comes down to just equals call between the actual quoted form
								from the Elixir File and the expected quoted from code dot strin to quoted
								(<code>Code.string_to_quoted</code>)
							</p>
						</aside>
					</section>
					<section id="jinterface-char-list">
						<h1>Char List</h1>
						<table>
							<thead>
							<tr>
								<th colspan="2">Range</th>
								<th rowspan="2">Java Class</th>
							</tr>
							<tr>
								<th>Start</th>
								<th>End</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>0</td>
								<td>255</td>
								<td>
									<code>OtpErlangString</code>
								</td>
							</tr>
							<tr>
								<td>256</td>
								<td>N/A</td>
								<td>
									<code>OtpErlangList</code>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								From the Basic Types of the Getting Started guide for Elixir or just messing around
								in I-E-X (<code>iex</code>), we know that sometimes lists of numbers will render as
								a single-quoted char list.  From this, we have a mental model that a char list is
								just formatting decision: a list of whole numbers is rendered as a char list if all the
								numbers are printable ASCII.
							</p>
							<p>
								But, the name char list is much more precise: O-T-P erlang string
								(<code>OtpErlangString</code>) is only returned from receive if all the numbers fit in
								an unsigned char C type, i.e. 0 to 255.
							</p>

						</aside>
					</section>
					<section id="jinterface-protocol">
						<h1>Protocol</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/jinterface/java_src/com/ericsson/otp/erlang/OtpInputStream.java#L1214-L1227">
									<code>lib/jinterface/java_src/com/ericsson/otp/erlang/OtpInputStream.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 165%; line-height: 100%">
package com.ericsson.otp.erlang;

public class OtpInputStream extends ByteArrayInputStream {
    public OtpErlangObject read_any() throws OtpErlangDecodeException {
        // ...
        switch(tag) {
        // ...
        case OtpExternal.stringTag:
            return new OtpErlangString(this);

        case OtpExternal.listTag:
            return new OtpErlangList(this);
        // ...
        }
    }
}
							</code></pre>
						</figure>
						<figure>
							<figcaption>
								<a href="https://github.com/erlang/otp/blob/1523be48ab4071b158412f4b06fe9c8d6ba3e73c/lib/jinterface/java_src/com/ericsson/otp/erlang/OtpExternal.java#L59-L66">
									<code>lib/jinterface/java_src/com/ericsson/otp/erlang/OtpExternal.java</code>
								</a>
							</figcaption>
							<pre><code class="java stretch" data-trim style="font-size: 165%; line-height: 100%">
package com.ericsson.otp.erlang;

public class OtpExternal {
    /** The tag used for empty lists */
    public static final int nilTag = 106;

    /** The tag used for strings and lists of small integers */
    public static final int stringTag = 107;

    /** The tag used for non-empty lists */
    public static final int listTag = 108;
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								This isn't just an artifact of JInterface, the actual Erlang wire protocol uses a
								different tag for Erlang Strings (in other words Elixir Char Lists) vs
								generic strings.  It even goes so far to reserve a special tag for empty lists because
								they are so common.
							</p>
						</aside>
					</section>
				</section>
				<section id="v0.2.1">
					<h1>v0.2.1</h1>
					<table>
						<thead>
						<tr>
							<th rowspan="2">Date</th>
							<th colspan="2">Days</th>
							<th colspan="2">Commits</th>
							<th>Version</th>
						</tr>
						<tr>
							<th>Delta</th>
							<th>Total</th>
							<th>Delta</th>
							<th>Total</th>
							<th>Commits/Day</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>2015&#8209;04&#8209;03</td>
							<td>124</td>
							<td>250</td>
							<td>521</td>
							<td>894</td>
							<td>4.20</td>
						</tr>
						</tbody>
					</table>
					<ul>
						<li>
							<p>Enhancements</p>
							<ul>
								<li>
									No parentheses function calls can occur as the right operand in binary infix operations or the sole
									operand of unary prefix operation.
								</li>
								<li>
									Function calls with neither parentheses nor <code>do</code> blocks that have at least 2 arguments: a
									positional argument and keyword arguments or 2 or more positional argument(s) followed by optional keyword
									arguments.
								</li>
								<li>Inspection that marks errors for ambiguous commas</li>
								<li>Inspection that marks errors for ambiguous parentheses</li>
								<li>Quick Fix for the ambiguous parentheses to remove the space between the function name and the opening parentheses.</li>
								<li>Inspection that marks errors for missing end-of-expressions (`;` and newlines) between expressions.</li>
								<li>Quick Fix to insert `;` for missing end-of-expression.</li>
								<li>Quick Fix to insert newline for missing end-of-expression.</li>
							</ul>
						</li>
						<li>
							<p>Bug Fixes</p>
							<ul>
								<li>Right hand-side of dot_alias and dot_identifier was translated incorrectly. Only Aliases and Identifiers are allowed now.</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						<p>
							The gap between version zero dot two dot zero (<code>v0.2.0</code>) and version zero
							dot two dot one (<code>v0.2.1</code>) was 124 days, but involved 521 commits.  The release
							included not only no parentheses function calls, but also a better way to automate testing
							using JInterface.
						</p>
					</aside>
				</section>
				<section class="stack">
					<section id="significant-whitespace">
						<h1>Significant Whitespace</h1>
						<ul>
							<li>
								<a href="#/significant-whitespace-comment-after-dot">
									Comment After Dot
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-dot-operation">
									<code>DOT_OPERATION</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-strip-dot-space">
									<code>strip_dot_space</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-arguments-vs-calls">
									Arguments vs Calls
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-bracket-identifier-and-paren-identifier">
									<code>bracket_identifier</code> and <code>paren_identifier</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-zero-width-call">
									<code>CALL</code>
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-operations">
									Operations
								</a>
							</li>
							<li>
								<a href="#/significant-whitespace-v0.3.3">
									v0.3.3
								</a>
							</li>
						</ul>
					</section>
					<section id="significant-whitespace-comment-after-dot">
						<h1>Comment after Dot</h1>
						<table style="font-size: 90%">
							<caption>
								Issue
								<a href="https://github.com/elixir-lang/elixir/issues/3316">
									#3316
								</a>
								<a href="https://github.com/elixir-lang/elixir/commit/970f84382bdcdb4621d62bb765f94f280d313c99">Fixed</a>
								in Elixir v1.1.0
							</caption>
							<thread>
								<tr>
									<th colspan="2">Uncommented</th>
									<th colspan="2">Commented</th>
								</tr>
								<tr>
									<th>Code</th>
									<th>Quoted</th>
									<th>Code</th>
									<th>Quoted</th>
								</tr>
							</thread>
							<tbody>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module.
identifier
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :ok,
 {
  {
   :.,
   [line: 1],
   [
    {
     :__aliases__,
     [counter: 0, line: 1],
     [:Module]
    },
    :function
   ]
  },
  [line: 1],
  []
 }
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module. # a comment
identifier
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :ok,
 {
  {
   :.,
   [line: 1],
   [
    {
     :__aliases__,
     [counter: 0, line: 1],
     [:Module]
    },
    :function
   ]
  },
  [line: 1],
  []
 }
}
									</code></pre>
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module.
|>
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :ok,
 {
  {
   :.,
   [line: 1],
   [
    {
     :__aliases__,
     [counter: 0, line: 1],
     [:Module]
    },
    :|>
   ]
  },
  [line: 1],
  []
 }
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 12em">
Module. # a comment
|>
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="width: 16em">
{
 :error,
 {
  2,
  "syntax error before: ",
  "'|>'"
  }
}
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The first bug I discovered in the native tokenizer involved how it handled dots and
								comments: the fact that a dot preceded a token, and so the token should act as an
								identifier wasn't tracked.  It just happened to work for identifiers because they're
								always identifiers, but operators are only identifiers if only whitespace separates
								the dot and the operator.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-dot-operation">
						<h1>Dot Operation</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/22d358b28516aa2448d0cd032742d4a48fc61292/src/org/elixir_lang/Elixir.flex#L585-L828">
									<code>src/org/elixir_lang/Elixir.flex</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 170%; line-height: 100%">
&lt;YYINITIAL, INTERPOLATION&gt; {
  {DOT_OPERATOR} { pushAndBegin(DOT_OPERATION);
                   return ElixirTypes.DOT_OPERATOR; }
}

&lt;DOT_OPERATION&gt; {
  {AND_OPERATOR} { yybegin(CALL_MAYBE);
                   return ElixirTypes.AND_OPERATOR; }

  /*
   * Emulates strip_space in elixir_tokenizer.erl
   */

  {ESCAPED_EOL}|{WHITE_SPACE}+ { return TokenType.WHITE_SPACE; }
  {EOL}                        { return ElixirTypes.EOL; }

  {COMMENT}                    { return ElixirTypes.COMMENT; }

  .                            { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                                 handleInState(stackFrame.getLastLexicalState()); }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								In order to handle operators as identifiers, but only after dot, I had to add a dot
								operation (<code>DOT_OPERATION</code>) state to elixir dot flex
								(<code>Elixir.flex</code>).
							</p>
							<p>
								Ensuring a operator works as an identifier was just a matter of adding the comment
								(<code>{COMMENT}</code>) rule to the state so a comment would state in dot operation
								(<code>DOT_OPERATION</code>), just like white space and E-O-L instead of using the catch
								all rule that pops the stack.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-strip-dot-space">
						<h1>
							<a href="https://github.com/elixir-lang/elixir/commit/970f84382bdcdb4621d62bb765f94f280d313c99">
								<code>strip_dot_space</code>
							</a>
						</h1>
						<table>
							<thead>
							<tr>
								<th>Before</th>
								<th>Affer</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<pre><code class="erlang stretch" data-trim style="width: 45em">
tokenize([$.|T], Line, Column, Scope, Tokens) ->
  {Rest, Counter, Offset} = strip_space(T, 0, Column + 1),
  handle_dot([$.|Rest], Line + Counter, Offset - 1, Column, Scope, Tokens);

strip_space(T, Counter, Column) ->
  case strip_horizontal_space(T) of
    {"\r\n" ++ Rest, _} -> strip_space(Rest, Counter + 1, 1);
    {"\n" ++ Rest, _}   -> strip_space(Rest, Counter + 1, 1);
    {Rest, Length}      -> {Rest, Counter, Column + Length}
  end.
									</code></pre>
								</td>
								<td>
									<pre><code class="erlang stretch" data-trim style="width: 48em">
tokenize([$.|T], Line, Column, Scope, Tokens) ->
  {Rest, Counter, Offset} = strip_dot_space(T, 0, Column + 1),
  handle_dot([$.|Rest], Line + Counter, Offset - 1, Column, Scope, Tokens);

strip_dot_space(T, Counter, Column) ->
  case strip_horizontal_space(T) of
    {"#" ++ Rest, _}    -> strip_dot_space(tokenize_comment(Rest), Counter, 1);
    {"\r\n" ++ Rest, _} -> strip_dot_space(Rest, Counter + 1, 1);
    {"\n" ++ Rest, _}   -> strip_dot_space(Rest, Counter + 1, 1);
    {Rest, Length}      -> {Rest, Counter, Column + Length}
  end.
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								José's fix in Elixir itself follows a similar pattern of not just stripping spaces, but
								also comments after dot.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-arguments-vs-calls">
						<h1>Arguments vs Calls</h1>
						<table>
							<thead>
							<tr>
								<th rowspan="2"></th>
								<th colspan="2">No Space</th>
								<th colspan="2">Space</th>
							</tr>
							<tr>
								<th>Code</th>
								<th>Quoted</th>
								<th>Code</th>
								<th>Quoted</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Parentheses</th>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 12em">
function(positional)
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 19em">
{
 :function,
 [line: 1],
 [
  {:positional, [line: 1], nil}
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 11em">
function (grouped)
									</code></pre>
								</td>
								<td>
									Error
								</td>
							</tr>
							<tr>
								<th>Brackets</th>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 6em">
dict[key]
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stetch" data-trim style="font-size: 135%; line-height: 100%; width: 16em">
{
 {
  :.,
  [line: 1],
  [Access, :get]
 },
 [line: 1],
 [
  {:dict, [line: 1], nil},
  {:key, [line: 1], nil}
 ]
}
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 11em">
function [element]
									</code></pre>
								</td>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 135%; line-height: 100%; width: 18em">
{
 :function,
 [line: 1],
 [
  [
   {:element, [line: 1], nil}
  ]
 ]
}
									</code></pre>
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The only thing that separates an ambiguous parentheses and a parenthetical function
								call is the space between the identifier and the opening parentheses.
							</p>
							<p>
								Worse, a space or no space between an identifier and an opening square bracket is both
								valid: no space and it's a bracket operation, which used the access protocol; a
								space and it's a list as a argument to a no parentheses call.
							</p>
							<p>
								So, in order to support no parentheses function calls, parentheses function calls, and
								brackets, the space or lack thereof, becomes significant.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-bracket-identifier-and-paren-identifier">
						<h1>Bracket and Paren Identifier</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.14.3/lib/elixir/src/elixir_tokenizer.erl#L454-L822">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 130%; line-height: 100%">
tokenize([H|_] = String, Line, Scope, Tokens) when ?is_downcase(H); H == $_ ->
  case tokenize_any_identifier(String, Line, Scope, Tokens) of
    {keyword, Rest, Check, T} ->
      handle_terminator(Rest, Line, Scope, Check, T);
    {identifier, Rest, Token} ->
      tokenize(Rest, Line, Scope, [Token|Tokens]);
    {error, _, _, _} = Error ->
      Error
  end;

tokenize_any_identifier(Original, Line, Scope, Tokens) ->
  {Rest, Identifier} = tokenize_identifier(Original, []),

  {AllIdentifier, AllRest} =
    case Rest of
      [H|T] when H == $?; H == $! -> {Identifier ++ [H], T};
      _ -> {Identifier, Rest}
    end,

  case unsafe_to_atom(AllIdentifier, Line, Scope) of
    {ok, Atom} ->
      tokenize_kw_or_other(AllRest, identifier, Line, Atom, Tokens);
    {error, Reason} ->
      {error, Reason, Original, Tokens}
  end.

tokenize_kw_or_other(Rest, Kind, Line, Atom, Tokens) ->
  case check_keyword(Line, Atom, Tokens) of
    nomatch ->
      {identifier, Rest, check_call_identifier(Kind, Line, Atom, Rest)};
    {ok, [Check|T]} ->
      {keyword, Rest, Check, T};
    {error, Token} ->
      {error, {Line, "syntax error before: ", Token}, atom_to_list(Atom) ++ Rest, Tokens}
  end.

check_call_identifier(_Kind, Line, Atom, [$(|_]) -> {paren_identifier, Line, Atom};
check_call_identifier(_Kind, Line, Atom, [$[|_]) -> {bracket_identifier, Line, Atom};
check_call_identifier(Kind, Line, Atom, _Rest)   -> {Kind, Line, Atom}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								The Elixir tokenizer handles the no space and space situation by using separate tokens
								for identifier if there is no space: bracket identifier
								(<code>bracket_identifier</code>) when before an opening square bracket and paren
								identifier (<code>paren_identifier</code>) when before an opening parenthesis.
							</p>
							<p>
								How it gets to that point is somewhat long, from tokenizing an underscore or a lower
								case letter, it has to decide whether the identifier is a keyword or not.  While
								deciding if it's a keyword, it checks if it's a call identifier or a normal identifier.
								If it's a call identifier then it's broken down into a bracket identifier, paren
								identifier or normal identifier.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-zero-width-call">
						<h1>Zero-Width Call</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.3/src/org/elixir_lang/Elixir.flex#L616-L810">
									<code>src/org/elixir_lang/Elixir.flex</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 150%; line-height: 100%">
&lt;YYINITIAL, INTERPOLATION&gt; {
  {IDENTIFIER} { pushAndBegin(CALL_OR_KEYWORD_PAIR_MAYBE);
                 return ElixirTypes.IDENTIFIER; }
}

&lt;CALL_MAYBE, CALL_OR_KEYWORD_PAIR_MAYBE&gt; {
  {OPENING_BRACKET}|{OPENING_PARENTHESIS} { org.elixir_lang.lexer.StackFrame stackFrame = pop();
                                            handleInState(stackFrame.getLastLexicalState());
                                            // zero-width token
                                            return ElixirTypes.CALL; }
}

&lt;DOT_OPERATION&gt; {
  {AND_OPERATOR} { yybegin(CALL_MAYBE);
                   return ElixirTypes.AND_OPERATOR; }
}
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Because tokens are tided to highlighting in the JetBrains API, I didn't want to have
								to have separate bracket and parentheses identifier.  It would also be more complicated
								for me because operators and quoted need to be bracket and parentheses identifier, but
								I can't tokenize them that way with JFlex.
							</p>
							<p>
								So, instead of changing the identifier token type, I added a zero-width
								<code>CALL</code> token for when something that could act as an identifer is immediately
								followed by an opening bracket or a parentheses.
							</p>
							<p>
								I needed a token for when there WASN'T a space instead of when there is a space because
								whitepace tokens are stripped when going from the tokenizer to the parser and I'd have
								had to change more rules to have significant white space instead of significant
								non-space.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-operations">
						<h1>Operations</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.3/src/org/elixir_lang/Elixir.bnf#L932-L1493">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 120%; line-height: 100%">
matchedExpression ::= matchedBracketOperation |
                      matchedQualifiedBracketOperation |
                      matchedQualifiedParenthesesCall |
                      matchedQualifiedNoArgumentsCall |
                      matchedUnqualifiedParenthesesCall |
                      matchedUnqualifiedBracketOperation |
                      variable |
                      accessExpression

matchedParenthesesArguments ::= CALL parenthesesArguments parenthesesArguments?

matchedBracketOperation ::= matchedExpression bracketArguments
matchedQualifiedBracketOperation ::= matchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments
matchedQualifiedParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments
matchedQualifiedNoArgumentsCall ::= matchedExpression dotInfixOperator relativeIdentifier !CALL
matchedUnqualifiedParenthesesCall ::= IDENTIFIER matchedParenthesesArguments
matchedUnqualifiedBracketOperation ::= IDENTIFIER CALL bracketArguments
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								With the zero-width <code>CALL</code> token, all the calls that allow parentheses can
								use the matched parentheses arguments (<code>matchedParenthesesArguments</code>) rule,
								which ensures there is no whitespace.
							</p>
							<p>
								matched qualified no arguments call (<code>matchedQualifiedNoArgumentsCall</code>) needs
								to do a negative look-ahead for <code>CALL</code> because it can be a right-operand
								of a further qualifiers or it will quote incorrectly.
							</p>
						</aside>
					</section>
					<section id="significant-whitespace-v0.3.3">
						<h1>v0.3.0 through v0.3.3</h1>
						<table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2015&#8209;05&#8209;15</td>
								<td>42</td>
								<td>292</td>
								<td>135</td>
								<td>1029</td>
								<td>3.21</td>
							</tr>
							</tbody>
						</table>
						<ul style="font-size: 55%">
							<li>
								<p>Enhancements</p>
								<ul>
									<li>
										<code>\x</code> is marked an error in CharLists, CharList Heredocs, Strings, and String Heredocs, but not
										in any sigils.
									</li>
									<li>
										New Elixir File will automatically underscore the camel case module name when creating the file name and
										will convert qualifying aliases before the last <code>.</code> to directories.
									</li>
									<li>
										File &gt; New &gt; Project From Existing Sources can be used in IntelliJ to setup the excludes, sources, tests,
										SDK and libraries for an Elixir project that has already been created with <code>mix new</code>.
									</li>
									<li>
										Operators can be qualified function names.
									</li>
									<li>
										Anonymous function calls (<code>.(...)</code>)
									</li>
									<li>
										Inspection that marks errors when keywords aren't at end of list.
									</li>
									<li>
										<p>Remote function calls (<code>Alias.function</code>, <code>:atom.function</code>, etc) and local function calls (<code>function</code>) with...</p>
										<ul>
											<li>
												<p>No Parentheses with...</p>
												<ul>
													<li>No Arguments (<code>Alias.function</code>)</li>
													<li>Keywords (<code>Alias.function key: value</code>)</li>
													<li>
														Nested No Parentheses Call (<code>Alias.function Inner.function positional, key: value</code>)
													</li>
													<li>Positional and Keyword arguments (<code>Alias.function positional, key: value</code>)</li>
													<li>Matched Expression (<code>Alias.function 1 + 2</code>)</li>
												</ul>
											</li>
											<li>
												<p>Parentheses with...</p>
												<ul>
													<li>No arguments (<code>Alias.function()</code>)</li>
													<li>No Parentheses Call (<code>Alias.function(Inner.function positional, key: value</code>)</li>
													<li>Keywords (<code>Alias.function(key: value)</code>)</li>
													<li>Positional and Keyword arguments (<code>Alias.function(positional, key: value)</code>)</li>
													<li>Trailing parentheses for quoting (<code>def unquote(variable)(positional)</code>)</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>Bracket expressions (<code>foo[key]</code>)</li>
								</ul>
							</li>
							<li>
								<p>Bug Fixes</p>
								<ul>
									<li>
										Fix
										<code>
											NoSuchElementException
										</code>
										when no suggested SDK home paths are available.  Thanks to
										<a href="https://github.com/zyuyou">
											zyuyou
										</a>
										for
										<a href="https://github.com/KronicDeth/intellij-elixir/issues/120">
											reporting
										</a>
									</li>
								</ul>
							</li>
							<li>
								<p>Incompatible Changes</p>
								<ul>
									<li>
										New Elixir File validates that the name is a valid Alias, so each `.` separated part must start with a
										capital letter.  Previous New Elixir File validated that the name was a valid path, and so forced the name
										to be lowercase.
									</li>
								</ul>
							</li>
						</ul>
					</section>
				</section>
				<section class="stack">
					<section id="stab">
						<h1>Stab</h1>
						<ul>
							<li>
								<a href="#/stab-usage">
									Usage
								</a>
							</li>
							<li>
								<a href="#/stab-yecc">
									YECC
								</a>
							</li>
							<li>
								<a href="#/stab-merging">
									Merging expressions into clauses
								</a>
							</li>
							<li>
								<a href="#/stab-grammar-kit">
									Grammar Kit
								</a>
							</li>
							<li>
								<a href="#/stab-v0.3.4">
									v0.3.4
								</a>
							</li>
						</ul>
					</section>
					<section id="stab-usage">
						<h1>Usage</h1>
						<table>
							<thead>
							<tr>
								<th>Code</th>
								<th>Description</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%; width: 11em">
fn x -> x + 1 end
									</code></pre>
								</td>
								<td>Anonymous function clause</td>
							</tr>
							<tr>
								<td style="padding-right: 63px">
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%; width: 20em">
receive do
  {:ping, pid} -> send pid, :pong
after
  10 -> :timeout
end
									</code></pre>
								</td>
								<td>
									Do block clauses
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%">
try do
  raise "oops"
rescue
  e in Runtimeerror -> e
end
									</code></pre>
								</td>
								<td>
									Do block start
								</td>
							</tr>
							<tr>
								<td>
									<pre><code class="elixir stretch" data-trim style="font-size: 300%; line-height: 100%; width: 5em">
(1 + 2)
									</code></pre>
								</td>
								<td>
									Parenthetical groups
								</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								Stabs are the hyphen greater than symbol used to map anonymous function arguments to
								the function clauses.  They are also used in pattern matching in do blocks, but
								from the parser's perspective, stabs don't actually need the stab operator.  They
								can just contain an expression, such as the first part of a try block or even
								any parenthetical group.  That was weird when I figured that out.
							</p>
						</aside>
					</section>
					<section id="stab-yecc">
						<h1>YECC</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L205-L276">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 160%; line-height: 100%">
access_expr -> fn_eol stab end_eol : build_fn('$1', build_stab(reverse('$2'))).
access_expr -> open_paren stab close_paren : build_stab(reverse('$2')).

stab -> stab_expr : ['$1'].
stab -> stab eol stab_expr : ['$3'|'$1'].

stab_eol -> stab : '$1'.
stab_eol -> stab eol : '$1'.

stab_expr -> expr : '$1'.
stab_expr -> stab_op_eol stab_maybe_expr : build_op('$1', [], '$2').
stab_expr -> call_args_no_parens_all stab_op_eol stab_maybe_expr :
               build_op('$2', unwrap_when(unwrap_splice('$1')), '$3').
stab_expr -> stab_parens_many stab_op_eol stab_maybe_expr :
               build_op('$2', unwrap_splice('$1'), '$3').
stab_expr -> stab_parens_many when_op expr stab_op_eol stab_maybe_expr :
               build_op('$4', [{'when', meta('$2'), unwrap_splice('$1') ++ ['$3']}], '$5').

stab_maybe_expr -> 'expr' : '$1'.
stab_maybe_expr -> '$empty' : nil.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								To get a plain parenthetical group, like addition in parentheses, you start with
								<code>access_expr</code>, then get an open parenthesis.  Dive into stab, then
								<code>stab_expr</code>.  <code>stab_expr</code> can just be an expression, such
								as adding <code>1 + 2</code>, so you climb back up to the close parenthesis and
								you have <code>1 + 2</code> in parentheses and not actual stab operator.
							</p>
							<p>
								The other part of stabs that I couldn't figure out at first was how any anonymous
								function clause could have more than one line of code in it because expression
								(<code>expr</code>) and an expression list (<code>expr_list</code>), but there is
								a pseudo-expression list because the second rule for stab says a stab is stab followed
								by an E-O-L and a stab_expr, so that can just recursively add more eol expressions
								on the right.
							</p>
							<p>
								But, that still leaves the problem that all the expressions in a row aren't actually
								associated with the pattern or argument names before the stab operator.
							</p>
						</aside>
					</section>
					<section id="stab-merging">
						<h1>Merging expressions into clauses</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L679-L694">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 210%; line-height: 100%">
build_stab([{'->', Meta, [Left, Right]}|T]) ->
  build_stab(Meta, T, Left, [Right], []);

build_stab(Else) ->
  build_block(Else).

build_stab(Old, [{'->', New, [Left, Right]}|T], Marker, Temp, Acc) ->
  H = {'->', Old, [Marker, build_block(reverse(Temp))]},
  build_stab(New, T, Left, [Right], [H|Acc]);

build_stab(Meta, [H|T], Marker, Temp, Acc) ->
  build_stab(Meta, T, Marker, [H|Temp], Acc);

build_stab(Meta, [], Marker, Temp, Acc) ->
  H = {'->', Meta, [Marker, build_block(reverse(Temp))]},
  reverse([H|Acc]).
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, this is where the YECC grammar is a little sneaky: it doesn't actually build up
								the parse tree a function clause at a time, instead the stab operation and plain
								expressions are all siblings and instead the Erlang <code>build_stab</code> function
								called in access expression (<code>access_expr</code>) actually merges all adjacent
								expressions into children of the prior stab operation until the next stab operation is
								hit.
							</p>
						</aside>
					</section>
					<section id="stab-grammar-kit">
						<h1>Grammar Kit</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.4/src/org/elixir_lang/Elixir.bnf#L1648-L1770">
									<code>src/org/elixir_lang/Elixir.bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 175%; line-height: 100%">
stabNoParenthesesSignature ::= noParenthesesArguments

stabParenthesesSignature ::= parenthesesArguments (whenInfixOperator expression)?
stabSignature ::= (stabParenthesesSignature |
                   stabNoParenthesesSignature)?

stabInfixOperator ::= EOL* STAB_OPERATOR EOL*

private stabOperationPrefix ::= stabSignature stabInfixOperator
private stabBodyExpression ::= !stabOperationPrefix expression
stabBody ::= stabBodyExpression (endOfExpression+ stabBodyExpression)*

stabOperation ::= stabOperationPrefix stabBody?
                  { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

stab ::= stabOperation (endOfExpression stabOperation)* |
         stabBody

anonymousFunction ::= FN endOfExpression?
                      stab
                      endOfExpression* END

parentheticalStab ::= OPENING_PARENTHESIS EOL*
                      (infixSemicolon? stab infixSemicolon? | infixSemicolon)
                      EOL* CLOSING_PARENTHESIS

accessExpression ::= anonymousFunction |
                     parentheticalStab
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Like, I said, I thought that was a dirty trick to not have the grammar actually represent
								the AST directly, so I made IntellIJ Elixir's stab definition match the clauses directly
								and not do merge in Java.
							</p>
							<p>
								The key to making this work is the negative look-ahead in stab body expression
								(<code>stabBodyExpression</code>), which prevent the start of a new stab clause from
								being included in the body of the previous stab.
							</p>
							<p>
								This look-ahead is more expensive in terms of parse time because the look-ahead includes
								stab signature (<code>stabSignature</code>), which can be any matched expression, which
								can be quite large, but in real world Elixir code, the function clause arguments
								and bodies should be small enough that this backtracking isn't an issue.
							</p>
						</aside>
					</section>
					<section id="stab-v0.3.4">
						<h1>v0.3.4</h1>
						<table>
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th>Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2015&#8209;06&#8209;04</td>
								<td>20</td>
								<td>312</td>
								<td>86</td>
								<td>1115</td>
								<td>4.30</td>
							</tr>
							</tbody>
						</table>
						<ul>
							<li>
								<p>Enhancements</p>
								<ul>
									<li>Bracket at expression (<code>@foo[key]</code>)</li>
									<li>Anonymous functions (<code>fn end</code>), stab clauses (<code>-&gt;</code>), and parentheticals (<code>1 + 2</code>)</li>
									<li>Maps (<code>%{}</code>) and structs (<code>%User{}</code>)</li>
									<li>Tuples (<code>{}</code>)</li>
									<li>Bit Strings (<code>&lt;&lt;&gt;&gt;</code>)</li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							<p>
								In addition to the anonymous functions, stab clauses, and parentheticals enabled by stabs,
								version zero dot three dot four (<code>v0.3.4</code>) also included support for
								the map, struct, tuples and bit string container types.
							</p>
						</aside>
					</section>
				</section>
				<section class="stack">
					<section id="unmatched-expressions">
						<h1>Unmatched Expressions</h1>
						<ul>
							<li>
								<a href="#/unmatched-expressions-unmatched-expr">
									<code>unmatched_expr</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-block-expr">
									<code>block_expr</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-block-list">
									<code>block_list</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-block-identifier">
									<code>block_identifier</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-dangling-else-problem">
									Dangling Else Problem
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-unmatched-expression">
									<code>unmatchedExpression</code>
								</a>
							</li>
							<li>
								<a href="#/unmatched-expressions-v0.3.5">
									v0.3.5
								</a>
							</li>
						</ul>
					</section>
					<section id="unmatched-expressions-unmatched-expr">
						<h1>
							<code>unmatched_expr</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L89-L154">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 155%; line-height: 100%">
expr -> unmatched_expr : '$1'.

unmatched_expr -> empty_paren op_expr : build_op(element(1, '$2'), nil, element(2, '$2')).
unmatched_expr -> matched_expr op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
unmatched_expr -> unmatched_expr op_expr : build_op(element(1, '$2'), '$1', element(2, '$2')).
unmatched_expr -> unary_op_eol expr : build_unary_op('$1', '$2').
unmatched_expr -> at_op_eol expr : build_unary_op('$1', '$2').
unmatched_expr -> capture_op_eol expr : build_unary_op('$1', '$2').
unmatched_expr -> block_expr : '$1'.

op_expr -> match_op_eol expr : {'$1', '$2'}.
op_expr -> add_op_eol expr : {'$1', '$2'}.
op_expr -> mult_op_eol expr : {'$1', '$2'}.
op_expr -> hat_op_eol expr : {'$1', '$2'}.
op_expr -> two_op_eol expr : {'$1', '$2'}.
op_expr -> and_op_eol expr : {'$1', '$2'}.
op_expr -> or_op_eol expr : {'$1', '$2'}.
op_expr -> in_op_eol expr : {'$1', '$2'}.
op_expr -> in_match_op_eol expr : {'$1', '$2'}.
op_expr -> type_op_eol expr : {'$1', '$2'}.
op_expr -> when_op_eol expr : {'$1', '$2'}.
op_expr -> pipe_op_eol expr : {'$1', '$2'}.
op_expr -> comp_op_eol expr : {'$1', '$2'}.
op_expr -> rel_op_eol expr : {'$1', '$2'}.
op_expr -> arrow_op_eol expr : {'$1', '$2'}.
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								unmatched expression (<code>unmatched_expr</code>) gets its name from the fact that the
								two operands in a binary expression don't have to be the same type unlike
								matched expression (<code>matched_expr</code>) where both operands need to be matched
								expressions (<code>matched_expr</code>).
							</p>
							<p>
								The other important characteristic of unmatched expressions
								(<code>unmatched_expr</code>) is they can contain block expressions
								(<code>block_expr</code>).
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-block-expr">
						<h1>
							<code>block_expr</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L135-L246">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 125%; line-height: 100%">
block_expr -> parens_call call_args_parens do_block : build_identifier('$1', '$2' ++ '$3').
block_expr -> parens_call call_args_parens call_args_parens do_block : build_nested_parens('$1', '$2', '$3' ++ '$4').
block_expr -> dot_do_identifier do_block : build_identifier('$1', '$2').
block_expr -> dot_identifier call_args_no_parens_all do_block : build_identifier('$1', '$2' ++ '$3').

do_block -> do_eol 'end' : [[{do,nil}]].
do_block -> do_eol stab end_eol : [[{do, build_stab(reverse('$2'))}]].
do_block -> do_eol block_list 'end' : [[{do, nil}|'$2']].
do_block -> do_eol stab_eol block_list 'end' : [[{do, build_stab(reverse('$2'))}|'$3']].
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								Block expressions (<code>block_expr</code>) are what one would expect from the previous
								part of the grammar and Elixir production code: identifiers or function calls with
								<code>do</code> block on the end.
							</p>
							<p>
								The <code>do_block</code> contains stabs, which IntelliJ Elixir could already handle, so
								the only thing new is <code>block_list</code>.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-block-list">
						<h1>
							<code>block_list</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_parser.yrl#L257-L282">
									<code>lib/elixir/src/elixir_parser.yrl</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 190%; line-height: 100%">
block_eol -> block_identifier : '$1'.
block_eol -> block_identifier eol : '$1'.

block_item -> block_eol stab_eol : {?exprs('$1'), build_stab(reverse('$2'))}.
block_item -> block_eol : {?exprs('$1'), nil}.

block_list -> block_item : ['$1'].
block_list -> block_item block_list : ['$1'|'$2'].
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, a <code>block_list</code> is a list of <code>block_items</code>, which are
								block EOLs (<code>block_eol</code>), which are <code>block_identifier</code> and
								that can be followed by an optional stab.
							</p>
							<p>
								So, what's a <code>block_identifier</code>?
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-block-identifier">
						<h1>
							<code>block_identifier</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/elixir-lang/elixir/blob/v0.15.1/lib/elixir/src/elixir_tokenizer.erl#L814-L961">
									<code>lib/elixir/src/elixir_tokenizer.erl</code>
								</a>
							</figcaption>
							<pre><code class="erlang stretch" data-trim style="font-size: 160%; line-height: 100%">
tokenize_kw_or_other(Rest, Kind, Line, Atom, Tokens) ->
  case check_keyword(Line, Atom, Tokens) of
    nomatch ->
      {identifier, Rest, check_call_identifier(Kind, Line, Atom, Rest)};
    {ok, [Check|T]} ->
      {keyword, Rest, Check, T};
    {error, Token} ->
      {error, {Line, "syntax error before: ", Token}, atom_to_list(Atom) ++ Rest, Tokens}
  end.

check_keyword(Line, Atom, Tokens) ->
  case keyword(Atom) of
    false    -> nomatch;
    token    -> {ok, [{Atom, Line}|Tokens]};
    block    -> {ok, [{block_identifier, Line, Atom}|Tokens]};
    unary_op -> {ok, [{unary_op, Line, Atom}|Tokens]};
    Kind     -> {ok, add_token_with_nl({Kind, Line, Atom}, Tokens)}
  end.

keyword('after')  -> block;
keyword('else')   -> block;
keyword('rescue') -> block;
keyword('catch')  -> block;
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								So, the block identifiers are <code>after</code>, <code>else</code>,
								<code>rescue</code>, and <code>catch</code>.  This means that those words are real
								keywords in Elixir.  Due to the power of the macro system, <code>if</code> and
								<code>unless</code> are just identifiers, but the <code>else</code> in either is a
								keyword.
							</p>
							<p>
								Using Elixir, we can't define new keywords, we can just rearrange the pre-existing ones.
								If we want other pseudo-keywords we're left with using keyword list keys.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-dangling-else-problem">
						<h1>Dangling Else Problem</h1>
						<table>
							<thead>
							<tr>
								<th></th>
								<th></th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Ambiguous code</th>
								<td>if a then if b then s else s2</td>
								<td>a b, c do s end</td>
							</tr>
							<tr>
								<th>Bind to Outermost</th>
								<td>if a then (if b then s) else s2</td>
								<td>a b, (c) do s end</td>
							</tr>
							<tr>
								<th>Bind to Closest</th>
								<td>if a then (if b then s else s2)</td>
								<td>a b, (c do s end)</td>
							</tr>
							</tbody>
						</table>
						<aside class="notes">
							<p>
								The dangling else problem is a problem with languages like C or Java that have an option
								else when nesting.
							</p>
							<p>
								The problem can be resolved by either saying the else binds to the outer most if or
								the closest if.
							</p>
							<p>
								This problem is also possible with do blocks in Elixir when resolving when function call
								a do block binds to.
							</p>
							<p>
								In actual Elixir grammar, the do block always binds to the outer-most function call,
								which turns out to be the easy choice for LALR parsers like yecc: it just works.  But,
								for LL parsers like Grammar Kit, all the text books on compiler design advise to pick
								binding to the closest because it's just not possible in simple LL(1) parsers to
								even do bind to outermost.  Thankfully, Grammar Kit is not a simple LL(1) parser, so
								I was able to find a solution.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-unmatched-expression">
						<h1>
							<code>unmatchedExpression</code>
						</h1>
						<figure>
							<figcaption>
								<a href="https://github.com/KronicDeth/intellij-elixir/blob/v0.3.5/src/org/elixir_lang/Elixir.bnf#L100-L2274">
									<code>src/org/elixir_lang/Elixir/bnf</code>
								</a>
							</figcaption>
							<pre><code class="stretch" data-trim style="font-size: 110%; line-height: 100%">
private expression ::= emptyParentheses |
                       unmatchedExpression |
                       unqualifiedNoParenthesesManyArgumentsCall

unmatchedExpression ::= unmatchedCaptureNonNumericOperation |
                        // ...
                        unmatchedQualifiedNoParenthesesCall |
                        // ...
                        unmatchedAccessExpression

unmatchedQualifiedNoParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument doBlock?

noParenthesesOneArgument ::= // ...
                             !(DUAL_OPERATOR SIGNIFICANT_WHITE_SPACE) matchedExpression
							</code></pre>
						</figure>
						<aside class="notes">
							<p>
								When adding unmatched expressions (<code>unmatchedExpression</code>) to Elixir dot bnf
								(<code>Elixir.bnf</code>), I ended up eliminating matched expressions
								(<code>matchedExpression</code>) from the list of valid expressions
								(<code>expression</code>)
							</p>
							<p>
								This is because the important distinction between <code>matchedExpression</code> is that
								<code>unmatchedExpressions</code> can optionally have a block, but any unparenthesised
								function call inside an unmatchedExpression function call must be a matchedExpression
								because blocks always bind to the left-most function call.
							</p>
							<p>
								Both matched expressions and unmatched expressions use no parentheses one argument, but
								crucially in unmatched expressions, it switches the grammar from looking for unmatched
								expressions and do blocks to disallowing do blocks.
							</p>
							<p>
								So, while in the yecc grammar, a block expression is matched expression followed by
								do block, in the grammar kit grammar, a matched expression is an unmatched expression
								that can't have a block.
							</p>
						</aside>
					</section>
					<section id="unmatched-expressions-v0.3.5">
						<h1>v0.3.5</h1>
						<table style="font-size: 85%">
							<thead>
							<tr>
								<th rowspan="2">Date</th>
								<th colspan="2">Days</th>
								<th colspan="2">Commits</th>
								<th colspan="2">Version</th>
							</tr>
							<tr>
								<th>Delta</th>
								<th>Total</th>
								<th>Delta</th>
								<th>Total</th>
								<th>Commits/Day</th>
								<th>Name</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>2015&#8209;07&#8209;08</td>
								<td>34</td>
								<td>346</td>
								<td>83</td>
								<td>1198</td>
								<td>2.44</td>
								<td>0.3.5</td>
							</tr>
							</tbody>
						</table>
						<ul>
							<li>
								<p>Enhancements</p>
								<ul>
									<li><code>do</code> blocks (<code>do end</code>)</li>
									<li>Unmatched expressions (operations involving <code>do</code> block calls and normal matched expressions)</li>
								</ul>
							</li>
							<li>
								<p>Bug Fixes</p>
								<ul>
									<li>Lex full atom instead of just identifier-like operator prefix (<code>:in<nospace>dex</code> before vs <code>:index</code> after)</li>
									<li><code>!</code> and <code>not</code> are properly wrapped in <code>__block__</code>s when in stab bodies</li>
								</ul>
							</li>
						</ul>
					</section>
				</section>
				<section id="bibliography">
                    <h1>Bibliography</h1>
					<ul>
						<li>
							<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">
								Backus-Naur Form
							</a>
						</li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">
                                Nondeterministic Finite Automaton
                            </a>
                        </li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Powerset_construction">
                                Powerset Construction
                            </a>
                        </li>
                        <li>
                            <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">
                                Deterministic Finite Automaton
                            </a>
                        </li>
						<li>
							Automata, Computability, and Complexity: Theory and Applications by Elaine Rich
						</li>
						<li>
							<a href="https://en.wikipedia.org/wiki/Recursive_language">
								Decidable Language
							</a>
						</li>
						<li>
							<a href="http://javascript.crockford.com/tdop/tdop.html">
								Douglas Crockford's Top Down Operator Precedence
							</a>
						</li>
					</ul>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				center: true,
				controls: true,
				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				],
				height: 1280,
				history: true,
				progress: true,
				// Slide number formatting can be configured using these variables:
				//  h: current slide's horizontal index
				//  v: current slide's vertical index
				//  c: current slide index (flattened)
				//  t: total number of slides (flattened)
				slideNumber: 'c / t',
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				width: 2048
			});

		</script>

	</body>
</html>
